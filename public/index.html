<!DOCTYPE html>
<html lang="ru" xmlns="http://www.w3.org/1999/html" xmlns="">
<head>
    <meta charset="UTF-8">

    <!-- Document title in browser tabs -->
    <title>WebDev Basics</title>
    <!-- Document Favicon in browser tabs -->
    <link rel="shortcut icon" href="icon.ico" type="image/x-icon">
    <!-- Additional approach to add favicon -->
<!--    <link rel="apple-touch-icon" href="apple-touch-icon.png">-->
<!--    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">-->
<!--    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">-->
    <!-- SEO -->
    <meta name="description" content="Test web page">
    <meta name="keywords" content="html, css, js, react, typeScript">
    <meta name="author" content="Slipbang">
    <!-- For mobile devices -->
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- For mobile & no resize -->
    <meta name="viewport" content="width=device-width, initial-scale=1 user-scalable=no">
    <!-- Use latest version of IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <!-- For external styles -->
    <link rel="stylesheet" href="styles.css">
    <!-- Google fonts -->
    <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"/>


    <!-- External scripts files -->

</head>
<body>
<header>
    <h1>Основы Front-End</h1>
    <p>Информация по HTML и CSS взята с канала <a href="https://www.youtube.com/c/YauhenKavalchuk" target="_blank">Евгения
        Ковальчука</a></p>
    <aside class="asideStyles">
        <div class="displayFlexClass">
            <button id="navButtons" class="slidingTop">Navigation</button>
            <button id="AlgorithmsAnDataStructuresNavButt" class="displayNoneClass hiddenElem">Algorithms and Data
                Structures
            </button>
        </div>
        <div class="displayFlexClass">
            <button id="HTMLnavButt" class="displayNoneClass hiddenElem">HTML</button>
            <button id="CSSnavButt" class="displayNoneClass hiddenElem">CSS</button>
            <button id="FlexboxNavButt" class="displayNoneClass hiddenElem">Flexbox</button>
            <button id="JSnavButt" class="displayNoneClass hiddenElem">JavaScript</button>
            <button id="ReactComNavButt" class="displayNoneClass hiddenElem">React</button>
            <button id="typeScriptNavButt" class="displayNoneClass hiddenElem">TypeScript</button>
        </div>

        <nav class="AlgorithmsAnDataStructuresNav displayNoneClass hiddenElem">
            <a href="#Algorithms">Алгоритмы</a>
            <a href="#dataStructures">Структура Данных</a>
        </nav>

        <nav class="HTMLnav displayNoneClass hiddenElem">
            <a href="#bsHTMLd">Базовая структура HTML документа</a>
            <a href="#metadata">Мета-данные и внешние импорты</a>
            <a href="#Validsemaccess">Валидация, семантика и доступность</a>
            <a href="#lists">Списки</a>
            <a href="#makingpictures">Оформление картинок</a>
            <a href="#tables">Таблицы</a>
            <a href="#linksandbuttons">Ссылки и кнопки</a>
            <a href="#usefultags">Полезные тэги</a>
            <a href="#globsitestruct">Глобальная структура сайта</a>
            <a href="#form">Форма</a>
            <a href="#inputtypes">Типы полей ввода</a>
            <a href="#vaf">Видео и аудио файлы</a>
            <a href="#comusfattrib">Общие и полезные атрибуты</a>
        </nav>

        <nav class="CSSnav displayNoneClass hiddenElem">
            <a href="#basesintCSSappl">Базовый синтаксис и применение стилей</a>
            <a href="#simpsel">Простые селекторы</a>
            <a href="#compsel">Составные селекторы</a>
            <a href="#pseeleclass">Псевдоэлементы и псевдоклассы</a>
            <a href="#cascinher">Каскадность и наследование</a>
            <a href="#boxmodpadmar">Блочная модель и отступы</a>
            <a href="#possiz">Позиционирование и размеры</a>
            <a href="#unitsoverflowzindex">Единицы, переполнение и уровни элементов</a>
            <a href="#floatelemclear">Плавающие элементы и очистка потока</a>
            <a href="#fnttxtstl">Шрифты и текст</a>
            <a href="#bordshad">Границы и тени</a>
            <a href="#bordradlistscol">Скругление углов, списки и цвета</a>
            <a href="#dispvisvendpref">Отображение элементов и вендорные префиксы</a>
            <a href="#Background">Фон</a>
            <a href="#gradients">Градиенты</a>
            <a href="#filters">Фильтры</a>
            <a href="#transform">Трансформации</a>
            <a href="#transition">Плавные переходы</a>
            <a href="#animations">Анимации</a>
            <a href="#tablcurs">Таблицы и курсор</a>
            <a href="#texteffectsmulticolumnstext">Текстовые эффекты и многоколоночный текст</a>
            <a href="#mediaqueries">Медиазапросы</a>
            <a href="#placeholderscrollbarsprites">Стилизация плейсхолдера и скролла, CSS-спрайты</a>
        </nav>

        <nav class="FlexboxNav displayNoneClass hiddenElem">
            <a href="#basedefinitions">Основные понятия</a>
            <a href="#flexdirection">Направление осей</a>
            <a href="#flexwrapgap">Перенос элементов и отступы</a>
            <a href="#alignmentjustifycontent">Выравнивание вдоль главной оси</a>
            <a href="#alignmentalignitems">Выравнивание вдоль поперечной оси</a>
            <a href="#aligncontent">Многострочное выравнивание</a>
            <a href="#alignself">Индивидуальное выравнивание элементов</a>
            <a href="#flexboxsizing">Размеры элементов</a>
            <a href="#order">Определение порядка элементов</a>
            <a href="#nestingflexbasisflexwrap">Вложенность. Обёртка элементов с размерами</a>
            <a href="#practicalexamples">Практические примеры использования Flexbox</a>
        </nav>

        <nav class="JSnav displayNoneClass hiddenElem">
            <a id="JSbasicsNavButt">Основы JavaScript</a>
            <a id="JSbasicsForEmploymentNavButt">Общая теория JavaScript</a>
            <a id="JSpracticeNavButt">Практика JavaScript</a>
        </nav>

        <nav class="JSbasicsNav displayNoneClass hiddenElem">
            <a href="#intro">Введениe</a>
            <a href="#objects">Объекты</a>
            <a href="#globalObjects">Глобальные объекты</a>
            <a href="#methods">Методы</a>
            <a href="#mutationInJS">Мутация в JavaScript</a>
            <a href="#functions">Функции</a>
            <a href="#linkedValues">Передача значения по ссылке</a>
            <a href="#callbackFunction">CallBack функции</a>
            <a href="#functionRules">Правила работы с функциями</a>
            <a href="#scope">Область видимости</a>
            <a href="#сhainOfScopes">Цепочка областей видимости</a>
            <a href="#variableLifeCycle">Жизненный цикл переменных</a>
            <a href="#typeOfScopes">Типы областей видимости</a>
            <a href="#strictMode">Строгий режим / Strict mode</a>
            <a href="#operators">Операторы</a>
            <a href="#operatorNotationFormats">Форматы записи операторов</a>
            <a href="#operatorPrecedence">Приоритетность операторов</a>
            <a href="#logicalOperators">Логические операторы</a>
            <a href="#falseValues">Ложные значения</a>
            <a href="#operatorTypeOf">Оператор typeof</a>
            <a href="#negationOperator">Префиксный унарный оператор "!"(не/отрицания)</a>
            <a href="#negationOfNegation">Отрицание отрицания "!!"</a>
            <a href="#andOr">Операторы короткого замыкания "и" и "или"</a>
            <a href="#chainOfAndOr">Цепочки операторов "&&" и "||"</a>
            <a href="#spreadOperator">Оператор разделения объекта на свойства "..." (spread)</a>
            <a href="#stringСoncatenation">Конкатенация строк</a>
            <a href="#functionExpressions">Функциональные выражения. Объявленная функция VS функциональное
                выражение.</a>
            <a href="#arrowFunction">Стрелочные функции</a>
            <a href="#defaultValues">Значения параметров функций по умолчанию</a>
            <a href="#tryCatch">Обработка ошибок в JavaScript</a>
            <a href="#instructions">Инструкции</a>
            <a href="#statementExpressions">Выражения-инструкции</a>
            <a href="#arrays">Массивы</a>
            <a href="#comparisonOperatorForArraysAndObjects">Оператор сравнения для массивов и объектов</a>
            <a href="#arrayVSobject">Массив против объекта</a>
            <a href="#readingValueOfArray">Чтение значения массива</a>
            <a href="#arrayMethods">Методы массивов</a>
            <a href="#objectDestructuring">Деструктуризация объектов</a>
            <a href="#arrayDestructuring">Деструктуризация массивов</a>
            <a href="#functionDestructuring">Деструктуризация в функциях</a>
            <a href="#ifElseConstruction">Условные конструкции</a>
            <a href="#ifOperator">Инструкция if() {}</a>
            <a href="#ifElse">Инструкция if() {} else {}</a>
            <a href="#ifElseElseIf">Инструкция if() {} else if() {} else {}</a>
            <a href="#ifUsage">Использование условного оператора if в функциях</a>
            <a href="#switchInstruction">Инструкция switch</a>
            <a href="#ternaryOperatorExpression">Тернарный оператор</a>
            <a href="#CallApplyBindDecorators">Методы call, apply, bind. Декораторы.</a>
            <a href="#cycles">Циклы</a>
            <a href="#cycleFor">Цикл for</a>
            <a href="#cycleWhile">Цикл while</a>
            <a href="#cycleDoWhile">Цикл do... while</a>
            <a href="#cycleForKey">Цикл for key in object</a>
            <a href="#objectKeysValues">Методы keys и values для объектов(Object.keys и Object.values)</a>
            <a href="#cycleForIn">Цикл for in для массивов</a>
            <a href="#cycleForOf">Цикл for of</a>
            <a href="#modules">Модули</a>
            <a href="#someModulesExports">Несколько экспортов в модуле</a>
            <a href="#moduleRules">Правила работы с модулями</a>
            <a href="#classesAndPrototypes">Классы и прототипы</a>
            <a href="#callingInheritedMethods">Вызов унаследованных методов</a>
            <a href="#prototypeChains">Цепочка прототипов</a>
            <a href="#inheritanceCheck">Проверка принадлежности</a>
            <a href="#objectCopyInheritanceCheck">Проверка принадлежности свойств экземпляру объекта</a>
            <a href="#creatingSomeCopies">Создание нескольких экземпляров</a>
            <a href="#staticMethods">Статическе методы</a>
            <a href="#classExtension">Расширение других классов</a>
            <a href="#prototypes">Что такое прототип</a>
            <a href="#stringAndNumberBehavior">Строки и числа ведут себя как объекты</a>
            <a href="#objectAndClassDecorators">Декораторы классов, объектов</a>
            <a href="#promises">Промисы</a>
            <a href="#promiseCreationAndUsage">Создание и использование промисов</a>
            <a href="#fetchApi">Получение данных с помощью fetch api</a>
            <a href="#callingFetchInsidePromise">Вызов fetch внутри промиса</a>
            <a href="#asyncAwait">Асинхронные функции(async/await)</a>
            <a href="#awaitInAJAX">Использование await внутри асинхронных функций</a>
            <a href="#asyncAwaitUsage">Переход(миграция) с промисов на async/await</a>
            <a href="#keyPrinciplesInAsyncAwait">Ключевые принципы в async/await</a>
        </nav>

        <nav class="JSbasicsForEmploymentNav displayNoneClass hiddenElem">
            <a href="#JSbasicsForEmployment0">
                <div class="engJSTheory">What are the possible ways to create objects in JavaScript</div>
                <div class="ruJSTheory">Способы создания объектов в JS</div>
            </a>
            <a href="#JSbasicsForEmployment1">
                <div class="engJSTheory">What is a prototype chain</div>
                <div class="ruJSTheory">Что такое цепочка прототипов</div>
            </a>
            <a href="#JSbasicsForEmployment2">
                <div class="engJSTheory">What is the difference between Call, Apply and Bind</div>
                <div class="ruJSTheory">В чем разница между Call, Apply и Bind</div>
            </a>
            <a href="#JSbasicsForEmployment3">
                <div class="engJSTheory">What is JSON and its common operations</div>
                <div class="ruJSTheory">Что такое JSON и его общие операции</div>
            </a>
            <a href="#JSbasicsForEmployment4">
                <div class="engJSTheory">What is the purpose of the array slice method</div>
                <div class="ruJSTheory">Какова цель метода массивов "slice"</div>
            </a>
            <a href="#JSbasicsForEmployment5">
                <div class="engJSTheory">What is the purpose of the array splice method</div>
                <div class="ruJSTheory">Какова цель метода массивов "splice"</div>
            </a>
            <a href="#JSbasicsForEmployment6">
                <div class="engJSTheory">What is the difference between slice and splice</div>
                <div class="ruJSTheory">В чем разница между slice и splice</div>
            </a>
            <a href="#JSbasicsForEmployment7">
                <div class="engJSTheory">How do you compare Object and Map</div>
                <div class="ruJSTheory">Как вы сравниваете Object and Map</div>
            </a>
            <a href="#JSbasicsForEmployment8">
                <div class="engJSTheory">What is the difference between == and === operators</div>
                <div class="ruJSTheory">В чем разница между операторами == и ===</div>
            </a>
            <a href="#JSbasicsForEmployment9">
                <div class="engJSTheory">What are lambda or arrow functions</div>
                <div class="ruJSTheory">Что такое лямбда или стрелочные функции?</div>
            </a>
            <a href="#JSbasicsForEmployment10">
                <div class="engJSTheory">What is a first class function</div>
                <div class="ruJSTheory">Что такое функция первого класса</div>
            </a>
            <a href="#JSbasicsForEmployment11">
                <div class="engJSTheory">What is a first order function</div>
                <div class="ruJSTheory">Что такое функция первого порядка</div>
            </a>
            <a href="#JSbasicsForEmployment12">
                <div class="engJSTheory">What is a higher order function</div>
                <div class="ruJSTheory">Что такое функция высшего порядка</div>
            </a>
            <a href="#JSbasicsForEmployment13">
                <div class="engJSTheory">What is a unary function</div>
                <div class="ruJSTheory">Что такое унарная функция</div>
            </a>
            <a href="#JSbasicsForEmployment14">
                <div class="engJSTheory">What is the currying function</div>
                <div class="ruJSTheory">Что такое функция каррирования</div>
            </a>
            <a href="#JSbasicsForEmployment15">
                <div class="engJSTheory">What is a pure function</div>
                <div class="ruJSTheory">Что такое чистая функция</div>
            </a>
            <a href="#JSbasicsForEmployment16">
                <div class="engJSTheory">What is the purpose of the let keyword</div>
                <div>Какова цель ключевого слова let</div>
            </a>
            <a href="#JSbasicsForEmployment17">
                <div class="engJSTheory">What is the difference between let and var</div>
                <div class="ruJSTheory">В чем разница между let и var</div>
            </a>
            <a href="#JSbasicsForEmployment18">
                <div class="engJSTheory">What is the reason to choose the name let as a keyword</div>
                <div class="ruJSTheory">По какой причине let выбрано в качестве ключевого слова в JS</div>
            </a>
            <a href="#JSbasicsForEmployment19">
                <div class="engJSTheory">How do you redeclare variables in a switch block without an error</div>
                <div class="ruJSTheory">Как переобъявить переменные в блоке переключателей (switch) без ошибки?</div>
            </a>
            <a href="#JSbasicsForEmployment20">
                <div class="engJSTheory">What is the Temporal Dead Zone</div>
                <div class="ruJSTheory">Что такое временная мертвая зона</div>
            </a>
            <a href="#JSbasicsForEmployment21">
                <div class="engJSTheory">What is an IIFE (Immediately Invoked Function Expression)</div>
                <div class="ruJSTheory">Что такое IIFE (выражение функции с немедленным вызовом)</div>
            </a>
            <a href="#JSbasicsForEmployment22">
                <div class="engJSTheory">How do you decode or encode a URL in JavaScript?</div>
                <div class="ruJSTheory">Как декодировать или кодировать URL-адрес в JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment23">
                <div class="engJSTheory">What is memoization</div>
                <div class="ruJSTheory">Что такое мемоизация</div>
            </a>
            <a href="#JSbasicsForEmployment24">
                <div class="engJSTheory">What is Hoisting</div>
                <div class="ruJSTheory">Что такое подъем</div>
            </a>
            <a href="#JSbasicsForEmployment25">
                <div class="engJSTheory">What are classes in ES6</div>
                <div class="ruJSTheory">Что такое классы в ES6</div>
            </a>
            <a href="#JSbasicsForEmployment26">
                <div class="engJSTheory">What are closures</div>
                <div class="ruJSTheory">Что такое замыкания</div>
            </a>
            <a href="#JSbasicsForEmployment27">
                <div class="engJSTheory">What are modules</div>
                <div class="ruJSTheory">Что такое модули</div>
            </a>
            <a href="#JSbasicsForEmployment28">
                <div class="engJSTheory">Why do you need modules</div>
                <div class="ruJSTheory">Зачем нужны модули</div>
            </a>
            <a href="#JSbasicsForEmployment29">
                <div class="engJSTheory">What is scope in javascript</div>
                <div class="ruJSTheory">Что такое область видимости в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment30">
                <div class="engJSTheory">What is a service worker</div>
                <div class="ruJSTheory">Что такое сервисный работник</div>
            </a>
            <a href="#JSbasicsForEmployment31">
                <div class="engJSTheory">How do you manipulate DOM using a service worker</div>
                <div class="ruJSTheory">Как манипулировать DOM с помощью сервис-воркера</div>
            </a>
            <a href="#JSbasicsForEmployment32">
                <div class="engJSTheory">How do you reuse information across service worker restarts</div>
                <div class="ruJSTheory">Как повторно использовать информацию при перезапуске Service Worker?</div>
            </a>
            <a href="#JSbasicsForEmployment33">
                <div class="engJSTheory">What is IndexedDB</div>
                <div class="ruJSTheory">Что такое IndexedDB</div>
            </a>
            <a href="#JSbasicsForEmployment34">
                <div class="engJSTheory">What is web storage</div>
                <div class="ruJSTheory">Что такое веб-хранилище(web storage)</div>
            </a>
            <a href="#JSbasicsForEmployment35">
                <div class="engJSTheory">What is a post message</div>
                <div>Что такое post сообщение</div>
            </a>
            <a href="#JSbasicsForEmployment36">
                <div class="engJSTheory">What is a Cookie</div>
                <div class="ruJSTheory">Что такое Cookie</div>
            </a>
            <a href="#JSbasicsForEmployment37">
                <div class="engJSTheory">Why do you need a Cookie</div>
                <div class="ruJSTheory">Зачем вам нужен Cookie</div>
            </a>
            <a href="#JSbasicsForEmployment38">
                <div class="engJSTheory">What are the options in a Cookie</div>
                <div class="ruJSTheory">Какие параметры есть в Cookie</div>
            </a>
            <a href="#JSbasicsForEmployment39">
                <div class="engJSTheory">How do you delete a cookie</div>
                <div class="ruJSTheory">Как удалить файл cookie</div>
            </a>
            <a href="#JSbasicsForEmployment40">
                <div class="engJSTheory">What are the differences between cookie, local storage and session storage
                </div>
                <div class="ruJSTheory">В чем разница между файлами cookie, локальным хранилищем и хранилищем сеансов?
                </div>
            </a>
            <a href="#JSbasicsForEmployment41">
                <div class="engJSTheory">What is the main difference between localStorage and sessionStorage</div>
                <div class="ruJSTheory">В чем основная разница между localStorage и sessionStorage?</div>
            </a>
            <a href="#JSbasicsForEmployment42">
                <div class="engJSTheory">How do you access web storage</div>
                <div class="ruJSTheory">Как получить доступ к веб-хранилищу</div>
            </a>
            <a href="#JSbasicsForEmployment43">
                <div class="engJSTheory">What are the methods available on session storage</div>
                <div class="ruJSTheory">Какие методы доступны в хранилище сеансов?</div>
            </a>
            <a href="#JSbasicsForEmployment44">
                <div class="engJSTheory">What is a storage event and its event handler</div>
                <div class="ruJSTheory">Что такое событие хранилища и его обработчик событий</div>
            </a>
            <a href="#JSbasicsForEmployment45">
                <div class="engJSTheory">Why do you need web storage</div>
                <div class="ruJSTheory">Зачем нужно веб-хранилище</div>
            </a>
            <a href="#JSbasicsForEmployment46">
                <div class="engJSTheory">How do you check web storage browser support</div>
                <div class="ruJSTheory">Как проверить поддержку веб-хранилища браузером</div>
            </a>
            <a href="#JSbasicsForEmployment47">
                <div class="engJSTheory">How do you check web workers browser support</div>
                <div class="ruJSTheory">Как проверить поддержку браузером веб-воркеров</div>
            </a>
            <a href="#JSbasicsForEmployment48">
                <div class="engJSTheory">Give an example of a web worker</div>
                <div class="ruJSTheory">Приведите пример веб-воркера</div>
            </a>
            <a href="#JSbasicsForEmployment49">
                <div class="engJSTheory">What are the restrictions of web workers on DOM</div>
                <div class="ruJSTheory">Каковы ограничения веб-воркеров в DOM</div>
            </a>
            <a href="#JSbasicsForEmployment50">
                <div class="engJSTheory">What is a promise</div>
                <div class="ruJSTheory">Что такое promise</div>
            </a>
            <a href="#JSbasicsForEmployment51">
                <div class="engJSTheory">Why do you need a promise</div>
                <div class="ruJSTheory">Для чего нужен промис</div>
            </a>
            <a href="#JSbasicsForEmployment52">
                <div class="engJSTheory">What are the three states of promise</div>
                <div class="ruJSTheory">Три состояния промиса</div>
            </a>
            <a href="#JSbasicsForEmployment53">
                <div class="engJSTheory">What is a callback function</div>
                <div class="ruJSTheory">Что такое функция обратного вызова(callback функция)</div>
            </a>
            <a href="#JSbasicsForEmployment54">
                <div class="engJSTheory">Why do we need callbacks</div>
                <div class="ruJSTheory">Почему нужны колбэк функции</div>
            </a>
            <a href="#JSbasicsForEmployment55">
                <div class="engJSTheory">What is a callback hell</div>
                <div class="ruJSTheory">Что такое "ад обратного вызова"</div>
            </a>
            <a href="#JSbasicsForEmployment56">
                <div class="engJSTheory">What are server-sent events</div>
                <div class="ruJSTheory">Что такое события, отправляемые сервером</div>
            </a>
            <a href="#JSbasicsForEmployment57">
                <div class="engJSTheory">How do you receive server-sent event notifications</div>
                <div class="ruJSTheory">Как вы получаете уведомления о событиях, отправленные сервером</div>
            </a>
            <a href="#JSbasicsForEmployment58">
                <div class="engJSTheory">How do you check browser support for server-sent events</div>
                <div class="ruJSTheory">Как проверить поддержку браузером событий, отправленных сервером?</div>
            </a>
            <a href="#JSbasicsForEmployment59">
                <div class="engJSTheory">What are the events available for server sent events</div>
                <div class="ruJSTheory">Какие события доступны для событий, отправленных сервером?</div>
            </a>
            <a href="#JSbasicsForEmployment60">
                <div class="engJSTheory">What are the main rules of promise</div>
                <div class="ruJSTheory">Каковы основные правила промисов</div>
            </a>
            <a href="#JSbasicsForEmployment61">
                <div class="engJSTheory">What is callback in callback</div>
                <div class="ruJSTheory">Что такое обратный вызов в обратном вызове</div>
            </a>
            <a href="#JSbasicsForEmployment62">
                <div class="engJSTheory">What is promise chaining</div>
                <div class="ruJSTheory">Что такое цепочка промисов</div>
            </a>
            <a href="#JSbasicsForEmployment63">
                <div class="engJSTheory">What is promise.all</div>
                <div class="ruJSTheory">Что такое promise.all</div>
            </a>
            <a href="#JSbasicsForEmployment64">
                <div class="engJSTheory">What is the purpose of the race() method in promise</div>
                <div class="ruJSTheory">Какова цель метода race() в промисе</div>
            </a>
            <a href="#JSbasicsForEmployment65">
                <div class="engJSTheory">What is a strict mode in javascript</div>
                <div class="ruJSTheory">Что такое strict mode(строгий режим) в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment66">
                <div class="engJSTheory">Why do you need strict mode</div>
                <div class="ruJSTheory">Для чего нужен строгий режим(strict mode)</div>
            </a>
            <a href="#JSbasicsForEmployment67">
                <div class="engJSTheory">How do you declare strict mode</div>
                <div class="ruJSTheory">Как объявить строгий режим</div>
            </a>
            <a href="#JSbasicsForEmployment68">
                <div class="engJSTheory">What is the purpose of double exclamation</div>
                <div class="ruJSTheory">Какова цель двойного восклицательного знака (отрицание отрицания)</div>
            </a>
            <a href="#JSbasicsForEmployment69">
                <div class="engJSTheory">What is the purpose of the delete operator</div>
                <div class="ruJSTheory">Какова цель оператора delete</div>
            </a>
            <a href="#JSbasicsForEmployment70">
                <div class="engJSTheory">What is typeof operator</div>
                <div class="ruJSTheory">Что такое оператор typeof</div>
            </a>
            <a href="#JSbasicsForEmployment71">
                <div class="engJSTheory">What is undefined property</div>
                <div class="ruJSTheory">Что такое свойство undefined</div>
            </a>
            <a href="#JSbasicsForEmployment72">
                <div class="engJSTheory">What is null value</div>
                <div class="ruJSTheory">Что такое null значение</div>
            </a>
            <a href="#JSbasicsForEmployment73">
                <div class="engJSTheory">What is the difference between null and undefined</div>
                <div class="ruJSTheory">В чем разница между null и undefined</div>
            </a>
            <a href="#JSbasicsForEmployment74">
                <div class="engJSTheory">What is eval</div>
                <div class="ruJSTheory">Что такое eval()</div>
            </a>
            <a href="#JSbasicsForEmployment75">
                <div class="engJSTheory">What is the difference between window and document</div>
                <div class="ruJSTheory">В чем разница между window и document</div>
            </a>
            <a href="#JSbasicsForEmployment76">
                <div class="engJSTheory">How do you access history in javascript</div>
                <div class="ruJSTheory">Как получить доступ к истории(history) в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment77">
                <div class="engJSTheory">How do you detect caps lock key turned on or not</div>
                <div class="ruJSTheory">Как определить, включена клавиша Caps Lock или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment78">
                <div class="engJSTheory">What is isNaN</div>
                <div class="ruJSTheory">Что такое isNaN</div>
            </a>
            <a href="#JSbasicsForEmployment79">
                <div class="engJSTheory">What are the differences between undeclared and undefined variables</div>
                <div class="ruJSTheory">В чем разница между необъявленными и неопределенными переменными</div>
            </a>
            <a href="#JSbasicsForEmployment80">
                <div class="engJSTheory">What are global variables</div>
                <div class="ruJSTheory">Что такое глобальные переменные</div>
            </a>
            <a href="#JSbasicsForEmployment81">
                <div class="engJSTheory">What are the problems with global variables</div>
                <div class="ruJSTheory">Какие проблемы с глобальными переменными</div>
            </a>
            <a href="#JSbasicsForEmployment82">
                <div class="engJSTheory">What is NaN property</div>
                <div class="ruJSTheory">Что такое свойство NaN</div>
            </a>
            <a href="#JSbasicsForEmployment83">
                <div class="engJSTheory">What is the purpose of isFinite function</div>
                <div class="ruJSTheory">Какова цель функции isFinite</div>
            </a>
            <a href="#JSbasicsForEmployment84">
                <div class="engJSTheory">What is an event flow</div>
                <div class="ruJSTheory">Что такое поток событий</div>
            </a>
            <a href="#JSbasicsForEmployment85">
                <div class="engJSTheory">What is event bubbling</div>
                <div class="ruJSTheory">Что такое всплытие событий</div>
            </a>
            <a href="#JSbasicsForEmployment86">
                <div class="engJSTheory">What is event capturing</div>
                <div class="ruJSTheory">Что такое перехват событий</div>
            </a>
            <a href="#JSbasicsForEmployment87">
                <div class="engJSTheory">How do you submit a form using JavaScript</div>
                <div class="ruJSTheory">Как отправить форму с помощью JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment88">
                <div class="engJSTheory">How do you find operating system details</div>
                <div class="ruJSTheory">Как найти сведения об операционной системе</div>
            </a>
            <a href="#JSbasicsForEmployment89">
                <div class="engJSTheory">What is the difference between document load and DOMContentLoaded events</div>
                <div class="ruJSTheory">В чем разница между загрузкой документа и событиями DOMContentLoaded</div>
            </a>
            <a href="#JSbasicsForEmployment90">
                <div class="engJSTheory">What is the difference between native, host and user objects</div>
                <div class="ruJSTheory">В чем разница между собственными, хостовыми и пользовательскими объектами</div>
            </a>
            <a href="#JSbasicsForEmployment91">
                <div class="engJSTheory">What are the tools or techniques used for debugging JavaScript code</div>
                <div class="ruJSTheory">Какие инструменты или методы используются для отладки кода JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment92">
                <div class="engJSTheory">What are the pros and cons of promises over callbacks</div>
                <div class="ruJSTheory">Каковы плюсы и минусы промисов перед обратными вызовами</div>
            </a>
            <a href="#JSbasicsForEmployment93">
                <div class="engJSTheory">What is the difference between an attribute and a property</div>
                <div class="ruJSTheory">В чем разница между атрибутом и свойством</div>
            </a>
            <a href="#JSbasicsForEmployment94">
                <div class="engJSTheory">What is same-origin policy</div>
                <div class="ruJSTheory">Что такое политика одного и того же происхождения</div>
            </a>
            <a href="#JSbasicsForEmployment95">
                <div class="engJSTheory">What is the purpose of void(0)</div>
                <div class="ruJSTheory">Какова цель void(0)</div>
            </a>
            <a href="#JSbasicsForEmployment96">
                <div class="engJSTheory">Is JavaScript a compiled or interpreted language</div>
                <div class="ruJSTheory">JavaScript является компилируемым или интерпретируемым языком?</div>
            </a>
            <a href="#JSbasicsForEmployment97">
                <div class="engJSTheory">Is JavaScript a case-sensitive language</div>
                <div class="ruJSTheory">Является ли JavaScript языком, чувствительным к регистру?</div>
            </a>
            <a href="#JSbasicsForEmployment98">
                <div class="engJSTheory">Is there any relation between Java and JavaScript</div>
                <div class="ruJSTheory">Есть ли какая-либо связь между Java и JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment99">
                <div class="engJSTheory">What are events</div>
                <div class="ruJSTheory">Что такое события</div>
            </a>
            <a href="#JSbasicsForEmployment100">
                <div class="engJSTheory">Who created javascript</div>
                <div class="ruJSTheory">Кто создал JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment101">
                <div class="engJSTheory">What is the use of preventDefault method</div>
                <div class="ruJSTheory">Для чего используется метод preventDefault()</div>
            </a>
            <a href="#JSbasicsForEmployment102">
                <div class="engJSTheory">What is the use of stopPropagation method</div>
                <div class="ruJSTheory">Для чего используется метод stopPropagation</div>
            </a>
            <a href="#JSbasicsForEmployment103">
                <div class="engJSTheory">What are the steps involved in return false usage</div>
                <div class="ruJSTheory">Какие шаги выполняются при использовании return false выражения в обработчиках
                    событий
                </div>
            </a>
            <a href="#JSbasicsForEmployment104">
                <div class="engJSTheory">What is BOM (Browser Object Model)</div>
                <div class="ruJSTheory">Что такое BOM (объектная модель браузера)</div>
            </a>
            <a href="#JSbasicsForEmployment105">
                <div class="engJSTheory">What is the use of setTimeout</div>
                <div class="ruJSTheory">Для чего используется setTimeout</div>
            </a>
            <a href="#JSbasicsForEmployment106">
                <div class="engJSTheory">What is the use of setInterval</div>
                <div class="ruJSTheory">Для чего используется setInterval</div>
            </a>
            <a href="#JSbasicsForEmployment107">
                <div class="engJSTheory">Why is JavaScript treated as Single threaded</div>
                <div class="ruJSTheory">Почему JavaScript считается однопоточным</div>
            </a>
            <a href="#JSbasicsForEmployment108">
                <div class="engJSTheory">What is an event delegation</div>
                <div class="ruJSTheory">Что такое делегирование события</div>
            </a>
            <a href="#JSbasicsForEmployment109">
                <div class="engJSTheory">What is ECMAScript</div>
                <div class="ruJSTheory">Что такое ECMAScript</div>
            </a>
            <a href="#JSbasicsForEmployment110">
                <div class="engJSTheory">What is JSON</div>
                <div class="ruJSTheory">Что такое JSON</div>
            </a>
            <a href="#JSbasicsForEmployment111">
                <div class="engJSTheory">What are the syntax rules of JSON</div>
                <div class="ruJSTheory">Каковы правила синтаксиса JSON?</div>
            </a>
            <a href="#JSbasicsForEmployment112">
                <div class="engJSTheory">What is the purpose JSON.stringify()</div>
                <div class="ruJSTheory">Какова цель JSON.stringify()</div>
            </a>
            <a href="#JSbasicsForEmployment113">
                <div class="engJSTheory">How do you parse JSON string</div>
                <div class="ruJSTheory">Как вы анализируете(парсите) строку JSON?</div>
            </a>
            <a href="#JSbasicsForEmployment114">
                <div class="engJSTheory">Why do you need JSON</div>
                <div class="ruJSTheory">Для чего нужен JSON</div>
            </a>
            <a href="#JSbasicsForEmployment115">
                <div class="engJSTheory">What are PWAs(Progressive web applications)</div>
                <div class="ruJSTheory">Что такое PWA(Progressive web applications/Прогрессивные веб-приложения)</div>
            </a>
            <a href="#JSbasicsForEmployment116">
                <div class="engJSTheory">What is the purpose of clearTimeout method</div>
                <div class="ruJSTheory">Какова цель метода clearTimeout?</div>
            </a>
            <a href="#JSbasicsForEmployment117">
                <div class="engJSTheory">What is the purpose of clearInterval method</div>
                <div class="ruJSTheory">Какова цель метода clearInterval</div>
            </a>
            <a href="#JSbasicsForEmployment118">
                <div class="engJSTheory">How do you redirect new page in javascript</div>
                <div class="ruJSTheory">Как перенаправить на новую страницу в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment119">
                <div class="engJSTheory">How do you check whether a string contains a substring</div>
                <div class="ruJSTheory">Как проверить, содержит ли строка подстроку</div>
            </a>
            <a href="#JSbasicsForEmployment120">
                <div class="engJSTheory">How do you validate an email in javascript</div>
                <div class="ruJSTheory">Как проверить электронную почту в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment121">
                <div class="engJSTheory">How do you get the current url with javascript</div>
                <div class="ruJSTheory">Как получить текущий URL с помощью JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment122">
                <div class="engJSTheory">What are the various url properties of location object</div>
                <div class="ruJSTheory">Каковы различные свойства URL объекта location?</div>
            </a>
            <a href="#JSbasicsForEmployment123">
                <div class="engJSTheory">How do get query string values in javascript</div>
                <div class="ruJSTheory">Как получить значения строки запроса в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment124">
                <div class="engJSTheory">How do you check if a key exists in an object</div>
                <div class="ruJSTheory">Как проверить, существует ли ключ в объекте</div>
            </a>
            <a href="#JSbasicsForEmployment125">
                <div class="engJSTheory">How do you loop through or enumerate javascript object</div>
                <div class="ruJSTheory">Как вы перебираете или перечисляете объект javascript</div>
            </a>
            <a href="#JSbasicsForEmployment126">
                <div class="engJSTheory">How do you test for an empty object</div>
                <div class="ruJSTheory">Как проверить пустой объект</div>
            </a>
            <a href="#JSbasicsForEmployment127">
                <div class="engJSTheory">What is an arguments object</div>
                <div class="ruJSTheory">Что такое объект arguments</div>
            </a>
            <a href="#JSbasicsForEmployment128">
                <div class="engJSTheory">How do you make first letter of the string in an uppercase</div>
                <div class="ruJSTheory">Как сделать первую букву строки заглавной?</div>
            </a>
            <a href="#JSbasicsForEmployment129">
                <div class="engJSTheory">What are the pros and cons of for loop</div>
                <div class="ruJSTheory">Каковы плюсы и минусы цикла for?</div>
            </a>
            <a href="#JSbasicsForEmployment130">
                <div class="engJSTheory">How do you display the current date in javascript</div>
                <div class="ruJSTheory">Как отобразить текущую дату в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment131">
                <div class="engJSTheory">How do you compare two date objects</div>
                <div class="ruJSTheory">Как сравнить два объекта Date</div>
            </a>
            <a href="#JSbasicsForEmployment132">
                <div class="engJSTheory">How do you check if a string starts with another string</div>
                <div class="ruJSTheory">Как проверить, начинается ли строка с искомой строки</div>
            </a>
            <a href="#JSbasicsForEmployment133">
                <div class="engJSTheory">How do you trim a string in javascript</div>
                <div class="ruJSTheory">Как обрезать строку в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment134">
                <div class="engJSTheory">How do you add a key value pair in javascript</div>
                <div class="ruJSTheory">Как добавить пару ключ-значение в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment135">
                <div class="engJSTheory">Is the !-- notation represents a special operator</div>
                <div class="ruJSTheory">Является ли обозначение !-- специальным оператором?</div>
            </a>
            <a href="#JSbasicsForEmployment136">
                <div class="engJSTheory">How do you assign default values to variables</div>
                <div>Как присвоить переменным значения по умолчанию</div>
            </a>
            <a href="#JSbasicsForEmployment137">
                <div class="engJSTheory">How do you define multiline strings</div>
                <div class="ruJSTheory">Как определить многострочные строки</div>
            </a>
            <a href="#JSbasicsForEmployment138">
                <div class="engJSTheory">What is an app shell model</div>
                <div class="ruJSTheory">Что такое модель оболочки приложения</div>
            </a>
            <a href="#JSbasicsForEmployment139">
                <div class="engJSTheory">Can we define properties for functions</div>
                <div class="ruJSTheory">Можем ли мы определить свойства для функций</div>
            </a>
            <a href="#JSbasicsForEmployment140">
                <div class="engJSTheory">What is the way to find the number of parameters expected by a function</div>
                <div class="ruJSTheory">Как найти количество параметров, ожидаемых функцией?</div>
            </a>
            <a href="#JSbasicsForEmployment141">
                <div class="engJSTheory">What is a polyfill</div>
                <div class="ruJSTheory">Что такое полифил</div>
            </a>
            <a href="#JSbasicsForEmployment142">
                <div class="engJSTheory">What are break and continue statements</div>
                <div class="ruJSTheory">Что такое операторы break и continue</div>
            </a>
            <a href="#JSbasicsForEmployment143">
                <div class="engJSTheory">What are js labels</div>
                <div class="ruJSTheory">Что такое js-метки</div>
            </a>
            <a href="#JSbasicsForEmployment144">
                <div class="engJSTheory">What are the benefits of keeping declarations at the top</div>
                <div class="ruJSTheory">Каковы преимущества размещения объявлений вверху?</div>
            </a>
            <a href="#JSbasicsForEmployment145">
                <div class="engJSTheory">What are the benefits of initializing variables</div>
                <div class="ruJSTheory">Каковы преимущества инициализации переменных</div>
            </a>
            <a href="#JSbasicsForEmployment146">
                <div class="engJSTheory">What are the recommendations to create new object</div>
                <div class="ruJSTheory">Каковы рекомендации по созданию нового объекта</div>
            </a>
            <a href="#JSbasicsForEmployment147">
                <div class="engJSTheory">How do you define JSON arrays</div>
                <div class="ruJSTheory">Как вы обозначаете массивы JSON</div>
            </a>
            <a href="#JSbasicsForEmployment148">
                <div class="engJSTheory">How do you generate random integers</div>
                <div class="ruJSTheory">Как генерировать случайные целые числа</div>
            </a>
            <a href="#JSbasicsForEmployment149">
                <div class="engJSTheory">Can you write a random integers function to print integers with in a range
                </div>
                <div class="ruJSTheory">Можете ли вы написать функцию случайных целых чисел для печати целых чисел в
                    диапазоне?
                </div>
            </a>
            <a href="#JSbasicsForEmployment150">
                <div class="engJSTheory">What is tree shaking</div>
                <div class="ruJSTheory">Что такое встряхивание дерева(tree shaking)</div>
            </a>
            <a href="#JSbasicsForEmployment151">
                <div class="engJSTheory">What is the need of tree shaking</div>
                <div class="ruJSTheory">Для чего нужно встряхивание дерева</div>
            </a>
            <a href="#JSbasicsForEmployment152">
                <div class="engJSTheory">Is it recommended to use eval</div>
                <div class="ruJSTheory">Рекомендуется ли использовать eval</div>
            </a>
            <a href="#JSbasicsForEmployment153">
                <div class="engJSTheory">What is a Regular Expression</div>
                <div class="ruJSTheory">Что такое регулярное выражение</div>
            </a>
            <a href="#JSbasicsForEmployment154">
                <div class="engJSTheory">What are the string methods available in Regular expression</div>
                <div class="ruJSTheory">Какие строковые методы доступны в регулярном выражении</div>
            </a>
            <a href="#JSbasicsForEmployment155">
                <div class="engJSTheory">What are modifiers in regular expression</div>
                <div class="ruJSTheory">Что такое модификаторы в регулярном выражении</div>
            </a>
            <a href="#JSbasicsForEmployment156">
                <div class="engJSTheory">What are regular expression patterns</div>
                <div class="ruJSTheory">Что такое шаблоны регулярных выражений</div>
            </a>
            <a href="#JSbasicsForEmployment157">
                <div class="engJSTheory">What is a RegExp object</div>
                <div class="ruJSTheory">Что такое объект RegExp</div>
            </a>
            <a href="#JSbasicsForEmployment158">
                <div class="engJSTheory">How do you search a string for a pattern</div>
                <div class="ruJSTheory">Как искать строку по шаблону</div>
            </a>
            <a href="#JSbasicsForEmployment159">
                <div class="engJSTheory">What is the purpose of exec method</div>
                <div class="ruJSTheory">Какова цель метода exec</div>
            </a>
            <a href="#JSbasicsForEmployment160">
                <div class="engJSTheory">How do you change the style of a HTML element</div>
                <div class="ruJSTheory">Как изменить стиль HTML-элемента</div>
            </a>
            <a href="#JSbasicsForEmployment161">
                <div class="engJSTheory">What would be the result of 1+2+'3'</div>
                <div class="ruJSTheory">Каким будет результат 1+2+'3'</div>
            </a>
            <a href="#JSbasicsForEmployment162">
                <div class="engJSTheory">What is a debugger statement</div>
                <div class="ruJSTheory">Что такое оператор debugger</div>
            </a>
            <a href="#JSbasicsForEmployment163">
                <div class="engJSTheory">What is the purpose of breakpoints in debugging</div>
                <div class="ruJSTheory">Какова цель точек останова(брейкпоинтов) при отладке</div>
            </a>
            <a href="#JSbasicsForEmployment164">
                <div class="engJSTheory">Can I use reserved words as identifiers</div>
                <div class="ruJSTheory">Могу ли я использовать зарезервированные слова в качестве идентификаторов</div>
            </a>
            <a href="#JSbasicsForEmployment165">
                <div class="engJSTheory">How do you detect a mobile browser</div>
                <div class="ruJSTheory">Как определить мобильный браузер</div>
            </a>
            <a href="#JSbasicsForEmployment166">
                <div class="engJSTheory">How do you detect a mobile browser without regexp</div>
                <div class="ruJSTheory">Как определить мобильный браузер без регулярного выражения</div>
            </a>
            <a href="#JSbasicsForEmployment167">
                <div class="engJSTheory">How do you get the image width and height using JS</div>
                <div class="ruJSTheory">Как получить ширину и высоту изображения с помощью JS?</div>
            </a>
            <a href="#JSbasicsForEmployment168">
                <div class="engJSTheory">How do you make synchronous HTTP request</div>
                <div class="ruJSTheory">Как сделать синхронный HTTP-запрос</div>
            </a>
            <a href="#JSbasicsForEmployment169">
                <div class="engJSTheory">How do you make asynchronous HTTP request</div>
                <div class="ruJSTheory">Как сделать асинхронный HTTP-запрос</div>
            </a>
            <a href="#JSbasicsForEmployment170">
                <div class="engJSTheory">How do you convert date to another timezone in javascript</div>
                <div class="ruJSTheory">Как преобразовать дату в другой часовой пояс в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment171">
                <div class="engJSTheory">What are the properties used to get size of window</div>
                <div class="ruJSTheory">Какие свойства используются для получения размера окна</div>
            </a>
            <a href="#JSbasicsForEmployment172">
                <div class="engJSTheory">What is a conditional operator in javascript</div>
                <div class="ruJSTheory">Что такое условный(тернарный) оператор в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment173">
                <div class="engJSTheory">Can you apply chaining on conditional operator</div>
                <div class="ruJSTheory">Можете ли вы применить цепочку к условному оператору?</div>
            </a>
            <a href="#JSbasicsForEmployment174">
                <div class="engJSTheory">What are the ways to execute javascript after page load</div>
                <div class="ruJSTheory">Каковы способы выполнения javascript после загрузки страницы?</div>
            </a>
            <a href="#JSbasicsForEmployment175">
                <div class="engJSTheory">What is the difference between proto and prototype</div>
                <div class="ruJSTheory">В чем разница между proto и prototype</div>
            </a>
            <a href="#JSbasicsForEmployment176">
                <div class="engJSTheory">Give an example where do you really need semicolon</div>
                <div class="ruJSTheory">Приведите пример, где действительно нужна точка с запятой</div>
            </a>
            <a href="#JSbasicsForEmployment177">
                <div class="engJSTheory">What is a freeze method</div>
                <div class="ruJSTheory">Что такое метод заморозки</div>
            </a>
            <a href="#JSbasicsForEmployment178">
                <div class="engJSTheory">What is the purpose of freeze method</div>
                <div class="ruJSTheory">В чем суть метода заморозки</div>
            </a>
            <a href="#JSbasicsForEmployment179">
                <div class="engJSTheory">Why do I need to use freeze method</div>
                <div class="ruJSTheory">Почему мне нужно использовать метод заморозки</div>
            </a>
            <a href="#JSbasicsForEmployment180">
                <div class="engJSTheory">How do you detect a browser language preference</div>
                <div class="ruJSTheory">Как определить языковые предпочтения браузера</div>
            </a>
            <a href="#JSbasicsForEmployment181">
                <div class="engJSTheory">How to convert string to title case with javascript</div>
                <div class="ruJSTheory">Как преобразовать строку в регистр заголовка с помощью JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment182">
                <div class="engJSTheory">How do you detect javascript disabled in the page</div>
                <div class="ruJSTheory">Как обнаружить отключен ли JavaScript на странице</div>
            </a>
            <a href="#JSbasicsForEmployment183">
                <div class="engJSTheory">What are various operators supported by javascript</div>
                <div class="ruJSTheory">Какие операторы поддерживаются JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment184">
                <div class="engJSTheory">What is a rest parameter</div>
                <div class="ruJSTheory">Что такое параметр rest</div>
            </a>
            <a href="#JSbasicsForEmployment185">
                <div class="engJSTheory">What happens if you do not use rest parameter as a last argument</div>
                <div class="ruJSTheory">Что произойдет, если вы не используете параметр rest в качестве последнего
                    аргумента
                </div>
            </a>
            <a href="#JSbasicsForEmployment186">
                <div class="engJSTheory">What are the bitwise operators available in javascript</div>
                <div class="ruJSTheory">Какие побитовые операторы доступны в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment187">
                <div class="engJSTheory">What is a spread operator</div>
                <div class="ruJSTheory">Что такое spread оператор</div>
            </a>
            <a href="#JSbasicsForEmployment188">
                <div class="engJSTheory">How do you determine whether object is frozen or not</div>
                <div class="ruJSTheory">Как определить, заморожен объект или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment189">
                <div class="engJSTheory">How do you determine two values same or not using object</div>
                <div class="ruJSTheory">Как определить одинаковы ли два значения или нет используя объект</div>
            </a>
            <a href="#JSbasicsForEmployment190">
                <div class="engJSTheory">What is the purpose of using object is method</div>
                <div class="ruJSTheory">Какая цель использования метода Object.is()</div>
            </a>
            <a href="#JSbasicsForEmployment191">
                <div class="engJSTheory">How do you copy properties from one object to other</div>
                <div class="ruJSTheory">Как скопировать свойства одного объекта в другой?</div>
            </a>
            <a href="#JSbasicsForEmployment192">
                <div class="engJSTheory">What are the applications of assign method</div>
                <div class="ruJSTheory">Какие есть применения метода assign?</div>
            </a>
            <a href="#JSbasicsForEmployment193">
                <div class="engJSTheory">What is a proxy object</div>
                <div class="ruJSTheory">Что такое прокси-объект</div>
            </a>
            <a href="#JSbasicsForEmployment194">
                <div class="engJSTheory">What is the purpose of seal method</div>
                <div class="ruJSTheory">В чем суть метода seal()</div>
            </a>
            <a href="#JSbasicsForEmployment195">
                <div class="engJSTheory">What are the applications of seal() method</div>
                <div class="ruJSTheory">Каковы применения метода seal()</div>
            </a>
            <a href="#JSbasicsForEmployment196">
                <div class="engJSTheory">What are the differences between freeze and seal methods</div>
                <div class="ruJSTheory">В чем разница между методами freeze() и seal()</div>
            </a>
            <a href="#JSbasicsForEmployment197">
                <div class="engJSTheory">How do you determine if an object is sealed or not</div>
                <div class="ruJSTheory">Как определить, применен ли к объекту метод seal() или нет</div>
            </a>
            <a href="#JSbasicsForEmployment198">
                <div class="engJSTheory">How do you get enumerable key and value pairs</div>
                <div class="ruJSTheory">Как получить перечислимые пары ключей и значений?</div>
            </a>
            <a href="#JSbasicsForEmployment199">
                <div class="engJSTheory">What is the main difference between Object.values and Object.entries method
                </div>
                <div class="ruJSTheory">В чем основное различие между методом Object.values и Object.entries?</div>
            </a>
            <a href="#JSbasicsForEmployment200">
                <div class="engJSTheory">How can you get the list of keys of any object</div>
                <div class="ruJSTheory">Как получить список ключей любого объекта</div>
            </a>
            <a href="#JSbasicsForEmployment201">
                <div class="engJSTheory">How do you create an object with prototype</div>
                <div class="ruJSTheory">Как создать объект с прототипом</div>
            </a>
            <a href="#JSbasicsForEmployment202">
                <div class="engJSTheory">What is a WeakSet</div>
                <div class="ruJSTheory">Что такое WeakSet</div>
            </a>
            <a href="#JSbasicsForEmployment203">
                <div class="engJSTheory">What are the differences between WeakSet and Set</div>
                <div class="ruJSTheory">В чем разница между WeakSet и Set</div>
            </a>
            <a href="#JSbasicsForEmployment204">
                <div class="engJSTheory">List down the collection of methods available on WeakSet</div>
                <div class="ruJSTheory">Перечислите методы, доступные в WeakSet.</div>
            </a>
            <a href="#JSbasicsForEmployment205">
                <div class="engJSTheory">What is a WeakMap</div>
                <div class="ruJSTheory">Что такое WeakMap</div>
            </a>
            <a href="#JSbasicsForEmployment206">
                <div class="engJSTheory">What are the differences between WeakMap and Map</div>
                <div class="ruJSTheory">В чем разница между WeakMap и Map</div>
            </a>
            <a href="#JSbasicsForEmployment207">
                <div class="engJSTheory">List down the collection of methods available on WeakMap.</div>
                <div class="ruJSTheory">Перечислите коллекцию методов, доступных для WeakMap.</div>
            </a>
            <a href="#JSbasicsForEmployment208">
                <div class="engJSTheory">What is the purpose of uneval(deprecated)</div>
                <div class="ruJSTheory">Какова цель uneval(устарела)</div>
            </a>
            <a href="#JSbasicsForEmployment209">
                <div class="engJSTheory">How do you encode an URL</div>
                <div class="ruJSTheory">Как вы кодируете URL-адрес</div>
            </a>
            <a href="#JSbasicsForEmployment210">
                <div class="engJSTheory">How do you decode an URL</div>
                <div class="ruJSTheory">Как декодировать URL</div>
            </a>
            <a href="#JSbasicsForEmployment211">
                <div class="engJSTheory">How do you print the contents of web page</div>
                <div class="ruJSTheory">Как распечатать содержимое веб-страницы</div>
            </a>
            <a href="#JSbasicsForEmployment212">
                <div class="engJSTheory">What is the difference between uneval and eval</div>
                <div class="ruJSTheory">В чем разница между uneval и eval</div>
            </a>
            <a href="#JSbasicsForEmployment213">
                <div class="engJSTheory">What is an anonymous function</div>
                <div class="ruJSTheory">Что такое анонимная функция</div>
            </a>
            <a href="#JSbasicsForEmployment214">
                <div class="engJSTheory">What is the precedence order between local and global variables</div>
                <div class="ruJSTheory">Каков порядок приоритета между локальными и глобальными переменными?</div>
            </a>
            <a href="#JSbasicsForEmployment215">
                <div class="engJSTheory">What are javascript accessors</div>
                <div class="ruJSTheory">Что такое аксессоры JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment216">
                <div class="engJSTheory">How do you define property on Object constructor</div>
                <div class="ruJSTheory">Как определить свойство в конструкторе объекта</div>
            </a>
            <a href="#JSbasicsForEmployment217">
                <div class="engJSTheory">What is the difference between get and defineProperty</div>
                <div class="ruJSTheory">В чем разница между get и defineProperty</div>
            </a>
            <a href="#JSbasicsForEmployment218">
                <div class="engJSTheory">What are the advantages of Getters and Setters</div>
                <div class="ruJSTheory">Каковы преимущества геттеров и сеттеров</div>
            </a>
            <a href="#JSbasicsForEmployment219">
                <div class="engJSTheory">Can I add getters and setters using defineProperty method</div>
                <div class="ruJSTheory">Могу ли я добавить геттеры и сеттеры, используя метод defineProperty?</div>
            </a>
            <a href="#JSbasicsForEmployment220">
                <div class="engJSTheory">What is the purpose of switch-case</div>
                <div class="ruJSTheory">Какова цель switch-case</div>
            </a>
            <a href="#JSbasicsForEmployment221">
                <div class="engJSTheory">What are the conventions to be followed for the usage of switch case</div>
                <div class="ruJSTheory">Каковы правила использования switch case?</div>
            </a>
            <a href="#JSbasicsForEmployment222">
                <div class="engJSTheory">What are primitive data types</div>
                <div class="ruJSTheory">Что такое примитивные типы данных</div>
            </a>
            <a href="#JSbasicsForEmployment223">
                <div class="engJSTheory">What are the different ways to access object properties</div>
                <div class="ruJSTheory">Какие существуют способы доступа к свойствам объекта?</div>
            </a>
            <a href="#JSbasicsForEmployment224">
                <div class="engJSTheory">What are the function parameter rules</div>
                <div class="ruJSTheory">Каковы правила параметров функции</div>
            </a>
            <a href="#JSbasicsForEmployment225">
                <div class="engJSTheory">What is an error object</div>
                <div class="ruJSTheory">Что такое объект error</div>
            </a>
            <a href="#JSbasicsForEmployment226">
                <div class="engJSTheory">When you get a syntax error</div>
                <div class="ruJSTheory">Когда вы получаете синтаксическую ошибку</div>
            </a>
            <a href="#JSbasicsForEmployment227">
                <div class="engJSTheory">What are the different error names from error object</div>
                <div class="ruJSTheory">Какие есть имена ошибок из объекта error?</div>
            </a>
            <a href="#JSbasicsForEmployment228">
                <div class="engJSTheory">What are the various statements in error handling</div>
                <div class="ruJSTheory">Какие существуют операторы обработки ошибок?</div>
            </a>
            <a href="#JSbasicsForEmployment229">
                <div class="engJSTheory">What are the two types of loops in javascript</div>
                <div class="ruJSTheory">Какие два типа циклов существуют в JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment230">
                <div class="engJSTheory">What is nodejs</div>
                <div class="ruJSTheory">Что такое nodejs</div>
            </a>
            <a href="#JSbasicsForEmployment231">
                <div class="engJSTheory">What is an Intl object</div>
                <div class="ruJSTheory">Что такое Intl объект</div>
            </a>
            <a href="#JSbasicsForEmployment232">
                <div class="engJSTheory">How do you perform language specific date and time formatting</div>
                <div class="ruJSTheory">Как выполнить форматирование даты и времени для конкретного языка?</div>
            </a>
            <a href="#JSbasicsForEmployment233">
                <div class="engJSTheory">What is an Iterator</div>
                <div class="ruJSTheory">Что такое итератор</div>
            </a>
            <a href="#JSbasicsForEmployment234">
                <div class="engJSTheory">How does synchronous iteration works</div>
                <div class="ruJSTheory">Как работает синхронная итерация</div>
            </a>
            <a href="#JSbasicsForEmployment235">
                <div class="engJSTheory">What is an event loop</div>
                <div class="ruJSTheory">Что такое цикл событий</div>
            </a>
            <a href="#JSbasicsForEmployment236">
                <div class="engJSTheory">What is call stack</div>
                <div class="ruJSTheory"> Что такое стек вызовов</div>
            </a>
            <a href="#JSbasicsForEmployment237">
                <div class="engJSTheory">What is an event queue</div>
                <div class="ruJSTheory">Что такое очередь событий</div>
            </a>
            <a href="#JSbasicsForEmployment238">
                <div class="engJSTheory">What is a decorator</div>
                <div class="ruJSTheory">Что такое декоратор</div>
            </a>
            <a href="#JSbasicsForEmployment239">
                <div class="engJSTheory">What are the properties of Intl object</div>
                <div class="ruJSTheory">Какие есть свойства у объекта Intl</div>
            </a>
            <a href="#JSbasicsForEmployment240">
                <div class="engJSTheory">What is an Unary operator</div>
                <div class="ruJSTheory">Что такое унарный оператор</div>
            </a>
            <a href="#JSbasicsForEmployment241">
                <div class="engJSTheory">How do you sort elements in an array</div>
                <div class="ruJSTheory">Как сортировать элементы в массиве</div>
            </a>
            <a href="#JSbasicsForEmployment242">
                <div class="engJSTheory">What is the purpose of compareFunction while sorting arrays</div>
                <div class="ruJSTheory">Какова цель compareFunction при сортировке массивов?</div>
            </a>
            <a href="#JSbasicsForEmployment243">
                <div class="engJSTheory">How do you reversing an array</div>
                <div class="ruJSTheory">Как вы переворачиваете массив</div>
            </a>
            <a href="#JSbasicsForEmployment244">
                <div class="engJSTheory">How do you find min and max value in an array</div>
                <div class="ruJSTheory">Как найти минимальное и максимальное значение в массиве</div>
            </a>
            <a href="#JSbasicsForEmployment245">
                <div class="engJSTheory">How do you find min and max values without Math functions</div>
                <div class="ruJSTheory">Как найти минимальные и максимальные значения без математических функций?</div>
            </a>
            <a href="#JSbasicsForEmployment246">
                <div class="engJSTheory">What is an empty statement and purpose of it</div>
                <div class="ruJSTheory">Что такое пустое заявление и его цель</div>
            </a>
            <a href="#JSbasicsForEmployment247">
                <div class="engJSTheory">How do you get metadata of a module</div>
                <div class="ruJSTheory">Как получить метаданные модуля</div>
            </a>
            <a href="#JSbasicsForEmployment248">
                <div class="engJSTheory">What is a comma operator</div>
                <div class="ruJSTheory">Что такое оператор запятая</div>
            </a>
            <a href="#JSbasicsForEmployment249">
                <div class="engJSTheory">What is the advantage of a comma operator</div>
                <div class="ruJSTheory">В чем преимущество оператора запятой</div>
            </a>
            <a href="#JSbasicsForEmployment250">
                <div class="engJSTheory">What is typescript</div>
                <div class="ruJSTheory">Что такое typescript</div>
            </a>
            <a href="#JSbasicsForEmployment251">
                <div class="engJSTheory">What are the differences between javascript and typescript</div>
                <div class="ruJSTheory">В чем разница между javascript и typescript</div>
            </a>
            <a href="#JSbasicsForEmployment252">
                <div class="engJSTheory">What are the advantages of typescript over javascript</div>
                <div class="ruJSTheory">Каковы преимущества машинописного текста перед javascript</div>
            </a>
            <a href="#JSbasicsForEmployment253">
                <div class="engJSTheory">What is an object initializer</div>
                <div class="ruJSTheory">Что такое инициализатор объекта</div>
            </a>
            <a href="#JSbasicsForEmployment254">
                <div class="engJSTheory">What is a constructor method</div>
                <div class="ruJSTheory">Что такое метод конструктора</div>
            </a>
            <a href="#JSbasicsForEmployment255">
                <div class="engJSTheory">What happens if you write constructor more than once in a class</div>
                <div>Что произойдет, если вы напишете конструктор более одного раза в классе</div>
            </a>
            <a href="#JSbasicsForEmployment256">
                <div class="engJSTheory">How do you call the constructor of a parent class</div>
                <div class="ruJSTheory">Как вызвать конструктор родительского класса?</div>
            </a>
            <a href="#JSbasicsForEmployment257">
                <div class="engJSTheory">How do you get the prototype of an object</div>
                <div class="ruJSTheory">Как получить прототип объекта</div>
            </a>
            <a href="#JSbasicsForEmployment258">
                <div class="engJSTheory">What happens If I pass string type for getPrototype method</div>
                <div class="ruJSTheory">Что произойдет, если я передам тип строки для метода getPrototype</div>
            </a>
            <a href="#JSbasicsForEmployment259">
                <div class="engJSTheory">How do you set prototype of one object to another</div>
                <div class="ruJSTheory">Как вы устанавливаете прототип одного объекта на другой?</div>
            </a>
            <a href="#JSbasicsForEmployment260">
                <div class="engJSTheory">How do you check whether an object can be extendable or not</div>
                <div class="ruJSTheory">Как проверить, может ли объект быть расширяемым или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment261">
                <div class="engJSTheory">How do you prevent an object to extend</div>
                <div class="ruJSTheory">Как предотвратить расширение объекта</div>
            </a>
            <a href="#JSbasicsForEmployment262">
                <div class="engJSTheory">What are the different ways to make an object non-extensible</div>
                <div class="ruJSTheory">Каковы различные способы сделать объект нерасширяемым?</div>
            </a>
            <a href="#JSbasicsForEmployment263">
                <div class="engJSTheory">How do you define multiple properties on an object</div>
                <div class="ruJSTheory">Как определить/изменить несколько свойств объекта</div>
            </a>
            <a href="#JSbasicsForEmployment264">
                <div class="engJSTheory">What is MEAN in javascript</div>
                <div class="ruJSTheory">Что такое MEAN в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment265">
                <div class="engJSTheory">What Is Obfuscation in javascript</div>
                <div class="ruJSTheory">Что такое обфускация в JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment266">
                <div class="engJSTheory">Why do you need Obfuscation</div>
                <div class="ruJSTheory">Зачем нужна обфускация</div>
            </a>
            <a href="#JSbasicsForEmployment267">
                <div class="engJSTheory">What is Minification</div>
                <div class="ruJSTheory">Что такое минификация</div>
            </a>
            <a href="#JSbasicsForEmployment268">
                <div class="engJSTheory">What are the advantages of minification</div>
                <div class="ruJSTheory">В чем преимущества минификации</div>
            </a>
            <a href="#JSbasicsForEmployment269">
                <div class="engJSTheory">What are the differences between Obfuscation and Encryption</div>
                <div class="ruJSTheory">В чем разница между обфускацией и шифрованием</div>
            </a>
            <a href="#JSbasicsForEmployment270">
                <div class="engJSTheory">What are the common tools used for minification</div>
                <div class="ruJSTheory">Какие общие инструменты используются для минификации</div>
            </a>
            <a href="#JSbasicsForEmployment271">
                <div class="engJSTheory">How do you perform form validation using javascript</div>
                <div class="ruJSTheory">Как выполнить валидацию формы с помощью JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment272">
                <div class="engJSTheory">How do you perform form validation without javascript</div>
                <div class="ruJSTheory">Как выполнить валидацию формы без JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment273">
                <div class="engJSTheory">What are the DOM methods available for constraint validation</div>
                <div class="ruJSTheory">Какие методы DOM доступны для проверки ограничений</div>
            </a>
            <a href="#JSbasicsForEmployment274">
                <div class="engJSTheory">What are the available constraint validation DOM properties</div>
                <div class="ruJSTheory">Какие есть доступные свойства DOM для проверки ограничений?</div>
            </a>
            <a href="#JSbasicsForEmployment275">
                <div class="engJSTheory">What are the list of validity properties</div>
                <div class="ruJSTheory">Каков список свойств validity</div>
            </a>
            <a href="#JSbasicsForEmployment276">
                <div class="engJSTheory">Give an example usage of rangeOverflow property</div>
                <div class="ruJSTheory">Приведите пример использования свойства rangeOverflow.</div>
            </a>
            <a href="#JSbasicsForEmployment277">
                <div class="engJSTheory">Is enums feature available in javascript</div>
                <div class="ruJSTheory">Доступна ли функционал enums в JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment278">
                <div class="engJSTheory">What is an enum</div>
                <div class="ruJSTheory">Что такое enum(перечисление)</div>
            </a>
            <a href="#JSbasicsForEmployment279">
                <div class="engJSTheory">How do you list all properties of an object</div>
                <div class="ruJSTheory">Как составить список всех свойств объекта</div>
            </a>
            <a href="#JSbasicsForEmployment280">
                <div class="engJSTheory">How do you get property descriptors of an object</div>
                <div class="ruJSTheory">Как получить дескрипторы свойств объекта</div>
            </a>
            <a href="#JSbasicsForEmployment281">
                <div class="engJSTheory">What are the attributes provided by a property descriptor</div>
                <div class="ruJSTheory">Какие есть атрибуты, предоставляемые дескриптором свойства?</div>
            </a>
            <a href="#JSbasicsForEmployment282">
                <div class="engJSTheory">How do you extend classes</div>
                <div class="ruJSTheory">Как создавать цепочку наследований классов(extends)</div>
            </a>
            <a href="#JSbasicsForEmployment283">
                <div class="engJSTheory">How do I modify the URL without reloading the page</div>
                <div class="ruJSTheory">Как изменить URL без перезагрузки страницы</div>
            </a>
            <a href="#JSbasicsForEmployment284">
                <div class="engJSTheory">How do you check whether an array includes a particular value or not</div>
                <div class="ruJSTheory">Как проверить, содержит ли массив определенное значение или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment285">
                <div class="engJSTheory">How do you compare scalar arrays</div>
                <div class="ruJSTheory">Как сравнивать скалярные массивы</div>
            </a>
            <a href="#JSbasicsForEmployment286">
                <div class="engJSTheory">How to get the value from get parameters</div>
                <div class="ruJSTheory">Как получить значение из параметров get</div>
            </a>
            <a href="#JSbasicsForEmployment287">
                <div class="engJSTheory">How do you print numbers with commas as thousand separators</div>
                <div class="ruJSTheory">Как печатать числа через запятую в виде разделителей тысяч?</div>
            </a>
            <a href="#JSbasicsForEmployment288">
                <div class="engJSTheory">What is the difference between java and javascript</div>
                <div class="ruJSTheory">В чем разница между Java и JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment289">
                <div class="engJSTheory">Does JavaScript supports namespace</div>
                <div class="ruJSTheory">Поддерживает ли JavaScript namespace(пространство имен)</div>
            </a>
            <a href="#JSbasicsForEmployment290">
                <div class="engJSTheory">How do you declare namespace</div>
                <div class="ruJSTheory">Как вы объявляете пространство имен</div>
            </a>
            <a href="#JSbasicsForEmployment291">
                <div class="engJSTheory">How do you invoke javascript code in an iframe from parent page(deprecated)
                </div>
                <div class="ruJSTheory">Как вызвать код JavaScript в iframe с родительской страницы?(deprecated)</div>
            </a>
            <a href="#JSbasicsForEmployment292">
                <div class="engJSTheory">How do get the timezone offset from date</div>
                <div class="ruJSTheory">Как получить смещение часового пояса относительно даты</div>
            </a>
            <a href="#JSbasicsForEmployment293">
                <div class="engJSTheory">How do you load CSS and JS files dynamically</div>
                <div class="ruJSTheory">Как динамически загружать файлы CSS и JS</div>
            </a>
            <a href="#JSbasicsForEmployment294">
                <div class="engJSTheory">What are the different methods to find HTML elements in DOM</div>
                <div class="ruJSTheory">Какие существуют методы поиска HTML-элементов в DOM?</div>
            </a>
            <a href="#JSbasicsForEmployment295">
                <div class="engJSTheory">What is jQuery</div>
                <div class="ruJSTheory">Что такое jQuery</div>
            </a>
            <a href="#JSbasicsForEmployment296">
                <div class="engJSTheory">What is V8 JavaScript engine</div>
                <div class="ruJSTheory">Что такое движок JavaScript V8</div>
            </a>
            <a href="#JSbasicsForEmployment297">
                <div class="engJSTheory">Why do we call javascript as dynamic language</div>
                <div class="ruJSTheory">Почему JavaScript называется динамическим языком</div>
            </a>
            <a href="#JSbasicsForEmployment298">
                <div class="engJSTheory">What is a void operator</div>
                <div class="ruJSTheory">Что такое оператор void</div>
            </a>
            <a href="#JSbasicsForEmployment299">
                <div class="engJSTheory">How to set the cursor to wait</div>
                <div class="ruJSTheory">Как поставить курсор на ожидание</div>
            </a>
            <a href="#JSbasicsForEmployment300">
                <div class="engJSTheory">How do you create an infinite loop</div>
                <div class="ruJSTheory">Как создать бесконечный цикл</div>
            </a>
            <a href="#JSbasicsForEmployment301">
                <div class="engJSTheory">Why do you need to avoid "with" statement</div>
                <div class="ruJSTheory">Почему нужно избегать оператора "with"</div>
            </a>
            <a href="#JSbasicsForEmployment302">
                <div class="engJSTheory">What is the output of below for loops</div>
                <div class="ruJSTheory">Каков вывод для приведенных ниже примеров циклов for</div>
            </a>
            <a href="#JSbasicsForEmployment303">
                <div class="engJSTheory">List down some of the features of ES6</div>
                <div class="ruJSTheory">Перечислите некоторые возможности ES6.</div>
            </a>
            <a href="#JSbasicsForEmployment304">
                <div class="engJSTheory">What is ES6</div>
                <div class="ruJSTheory">Что такое ES6</div>
            </a>
            <a href="#JSbasicsForEmployment305">
                <div class="engJSTheory">Can I redeclare let and const variables</div>
                <div class="ruJSTheory">Могу ли я переопределить переменные let и const?</div>
            </a>
            <a href="#JSbasicsForEmployment306">
                <div class="engJSTheory">Is const variable makes the value immutable</div>
                <div class="ruJSTheory">Константная переменная делает значение неизменяемым?</div>
            </a>
            <a href="#JSbasicsForEmployment307">
                <div class="engJSTheory">What are default parameters</div>
                <div class="ruJSTheory">Что такое параметры по умолчанию</div>
            </a>
            <a href="#JSbasicsForEmployment308">
                <div class="engJSTheory">What are template literals</div>
                <div class="ruJSTheory">Что такое шаблонные литералы</div>
            </a>
            <a href="#JSbasicsForEmployment309">
                <div class="engJSTheory">How do you write multi-line strings in template literals</div>
                <div class="ruJSTheory">Как писать многострочные строки в литералах шаблона</div>
            </a>
            <a href="#JSbasicsForEmployment310">
                <div class="engJSTheory">What are nesting templates</div>
                <div class="ruJSTheory">Что такое шаблоны вложения(nesting templates)</div>
            </a>
            <a href="#JSbasicsForEmployment311">
                <div class="engJSTheory">What are tagged templates</div>
                <div class="ruJSTheory">Что такое теговые шаблоны(tagged templates)</div>
            </a>
            <a href="#JSbasicsForEmployment312">
                <div class="engJSTheory">What are raw strings</div>
                <div class="ruJSTheory">Что такое String.raw()</div>
            </a>
            <a href="#JSbasicsForEmployment313">
                <div class="engJSTheory">What is destructuring assignment</div>
                <div class="ruJSTheory">Что такое деструктуризация присваивания</div>
            </a>
            <a href="#JSbasicsForEmployment314">
                <div class="engJSTheory">What are default values in destructuring assignment</div>
                <div class="ruJSTheory">Значения по умолчанию при назначении деструктуризации</div>
            </a>
            <a href="#JSbasicsForEmployment315">
                <div class="engJSTheory">How do you swap variables in destructuring assignment</div>
                <div class="ruJSTheory">Как поменять местами переменные при деструктурировании присваивания</div>
            </a>
            <a href="#JSbasicsForEmployment316">
                <div class="engJSTheory">What are enhanced object literals</div>
                <div class="ruJSTheory">Что такое расширенные литералы объектов</div>
            </a>
            <a href="#JSbasicsForEmployment317">
                <div class="engJSTheory">What are dynamic imports</div>
                <div class="ruJSTheory">Что такое динамический импорт</div>
            </a>
            <a href="#JSbasicsForEmployment318">
                <div class="engJSTheory">What are the use cases for dynamic imports</div>
                <div class="ruJSTheory">Каковы варианты использования динамического импорта</div>
            </a>
            <a href="#JSbasicsForEmployment319">
                <div class="engJSTheory">What are typed arrays</div>
                <div class="ruJSTheory">Что такое типизированные массивы</div>
            </a>
            <a href="#JSbasicsForEmployment320">
                <div class="engJSTheory">What are the advantages of module loaders</div>
                <div class="ruJSTheory">В чем преимущества загрузчиков модулей</div>
            </a>
            <a href="#JSbasicsForEmployment321">
                <div class="engJSTheory">What is collation</div>
                <div class="ruJSTheory">Что такое параметры сортировки</div>
            </a>
            <a href="#JSbasicsForEmployment322">
                <div class="engJSTheory">What is for...of statement</div>
                <div class="ruJSTheory">Что такое цикл for...of</div>
            </a>
            <a href="#JSbasicsForEmployment323">
                <div class="engJSTheory">What is the output of below spread operator array</div>
                <div class="ruJSTheory">Каков вывод массива операторов распространения ниже?</div>
            </a>
            <a href="#JSbasicsForEmployment324">
                <div class="engJSTheory">Is PostMessage secure</div>
                <div class="ruJSTheory">Безопасно ли использовать PostMessage</div>
            </a>
            <a href="#JSbasicsForEmployment325">
                <div class="engJSTheory">What are the problems with postmessage target origin as wildcard</div>
                <div class="ruJSTheory">Какие существуют проблемы с целевым происхождением postmessage в качестве <a
                        href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Regular_expressions/Wildcard">wildcard?</a>
                </div>
            </a>
            <a href="#JSbasicsForEmployment326">
                <div class="engJSTheory">How do you avoid receiving postMessages from attackers</div>
                <div class="ruJSTheory">Как избежать получения postMessage от злоумышленников</div>
            </a>
            <a href="#JSbasicsForEmployment327">
                <div class="engJSTheory">Can I avoid using postMessages completely</div>
                <div class="ruJSTheory">Можно ли полностью избежать использования postMessage?</div>
            </a>
            <a href="#JSbasicsForEmployment328">
                <div class="engJSTheory">Is postMessages synchronous</div>
                <div class="ruJSTheory">Синхронен ли postMessages?</div>
            </a>
            <a href="#JSbasicsForEmployment329">
                <div class="engJSTheory">What paradigm is Javascript</div>
                <div class="ruJSTheory">Какая парадигма представляет собой Javascript</div>
            </a>
            <a href="#JSbasicsForEmployment330">
                <div class="engJSTheory">What is the difference between internal and external javascript</div>
                <div class="ruJSTheory">В чем разница между внутренним и внешним JavaScript</div>
            </a>
            <a href="#JSbasicsForEmployment331">
                <div class="engJSTheory">Is JavaScript faster than server side script</div>
                <div class="ruJSTheory">JavaScript быстрее, чем серверный скрипт?</div>
            </a>
            <a href="#JSbasicsForEmployment332">
                <div class="engJSTheory">How do you get the status of a checkbox</div>
                <div class="ruJSTheory">Как узнать статус checkbox инпута</div>
            </a>
            <a href="#JSbasicsForEmployment333">
                <div class="engJSTheory">What is the purpose of double tilde operator</div>
                <div class="ruJSTheory">Какова цель оператора двойной тильды</div>
            </a>
            <a href="#JSbasicsForEmployment334">
                <div class="engJSTheory">How do you convert character to ASCII code</div>
                <div class="ruJSTheory">Как преобразовать символ в код ASCII</div>
            </a>
            <a href="#JSbasicsForEmployment335">
                <div class="engJSTheory">What is ArrayBuffer</div>
                <div class="ruJSTheory">Что такое ArrayBuffer</div>
            </a>
            <a href="#JSbasicsForEmployment336">
                <div class="engJSTheory">What is the output of below string expression</div>
                <div class="ruJSTheory">Каков вывод приведенного ниже строкового выражения</div>
            </a>
            <a href="#JSbasicsForEmployment337">
                <div class="engJSTheory">What is the purpose of Error object</div>
                <div class="ruJSTheory">Какова цель объекта Error</div>
            </a>
            <a href="#JSbasicsForEmployment338">
                <div class="engJSTheory">What is the purpose of EvalError object</div>
                <div class="ruJSTheory">Какова цель объекта EvalError</div>
            </a>
            <a href="#JSbasicsForEmployment339">
                <div class="engJSTheory">What are the list of cases error thrown from non-strict mode to strict mode
                </div>
                <div class="ruJSTheory">Каков список случаев ошибки, возникающей при переходе из нестрогого
                    режима(non-strict
                    mode) в строгий режим(strict mode)?
                </div>
            </a>
            <a href="#JSbasicsForEmployment340">
                <div class="engJSTheory">Do all objects have prototypes</div>
                <div class="ruJSTheory">У всех ли объектов есть прототипы?</div>
            </a>
            <a href="#JSbasicsForEmployment341">
                <div class="engJSTheory">What is the difference between a parameter and an argument</div>
                <div class="ruJSTheory">В чем разница между параметром и аргументом</div>
            </a>
            <a href="#JSbasicsForEmployment342">
                <div class="engJSTheory">What is the purpose of some() method in arrays</div>
                <div class="ruJSTheory">Какова цель метода some() в массивах</div>
            </a>
            <a href="#JSbasicsForEmployment343">
                <div class="engJSTheory">How do you combine two or more arrays</div>
                <div class="ruJSTheory">Как объединить два или более массива</div>
            </a>
            <a href="#JSbasicsForEmployment344">
                <div class="engJSTheory">What is the difference between Shallow and Deep copy</div>
                <div class="ruJSTheory">В чем разница между поверхностной и глубокой копией</div>
            </a>
            <a href="#JSbasicsForEmployment345">
                <div class="engJSTheory">How do you create specific number of copies of a string</div>
                <div class="ruJSTheory">Как создать определенное количество копий строки</div>
            </a>
            <a href="#JSbasicsForEmployment346">
                <div class="engJSTheory">How do you return all matching strings against a regular expression</div>
                <div class="ruJSTheory">Как вернуть все совпадающие строки по регулярному выражению</div>
            </a>
            <a href="#JSbasicsForEmployment347">
                <div class="engJSTheory">How do you trim a string at the beginning or ending</div>
                <div class="ruJSTheory">Как обрезать строку в начале или конце?</div>
            </a>
            <a href="#JSbasicsForEmployment348">
                <div class="engJSTheory">What is the output of below console statement with unary operator</div>
                <div class="ruJSTheory">Каков вывод приведенного ниже оператора консоли с унарным оператором?</div>
            </a>
            <a href="#JSbasicsForEmployment349">
                <div class="engJSTheory">Does javascript uses mixins</div>
                <div class="ruJSTheory">Использует ли JavaScript миксины(примеси)?</div>
            </a>
            <a href="#JSbasicsForEmployment350">
                <div class="engJSTheory">What is a thunk function</div>
                <div class="ruJSTheory">Что такое функция thunk</div>
            </a>
            <a href="#JSbasicsForEmployment351">
                <div class="engJSTheory">What are asynchronous thunks</div>
                <div class="ruJSTheory">Что такое асинхронный thunk</div>
            </a>
            <a href="#JSbasicsForEmployment352">
                <div class="engJSTheory">What is the output of below function calls</div>
                <div class="ruJSTheory">Каков результат следующих вызовов функций?</div>
            </a>
            <a href="#JSbasicsForEmployment353">
                <div class="engJSTheory">How to remove all line breaks from a string</div>
                <div class="ruJSTheory">Как удалить все разрывы строк из строки</div>
            </a>
            <a href="#JSbasicsForEmployment354">
                <div class="engJSTheory">What is the difference between reflow and repaint</div>
                <div class="ruJSTheory">В чем разница между reflow и repaint</div>
            </a>
            <a href="#JSbasicsForEmployment355">
                <div class="engJSTheory">What happens with negating an array</div>
                <div class="ruJSTheory">Что происходит при отрицании(!) массива</div>
            </a>
            <a href="#JSbasicsForEmployment356">
                <div class="engJSTheory">What happens if we add two arrays</div>
                <div class="ruJSTheory">Что произойдет, если мы добавим два массива</div>
            </a>
            <a href="#JSbasicsForEmployment357">
                <div class="engJSTheory">What is the output of prepend additive operator on falsy values</div>
                <div class="ruJSTheory">Каков результат операции добавления аддитивного оператора(+) к ложным
                    значениям?
                </div>
            </a>
            <a href="#JSbasicsForEmployment358">
                <div class="engJSTheory">How do you create self string using special characters</div>
                <div class="ruJSTheory">Как создать собственную строку, используя специальные символы</div>
            </a>
            <a href="#JSbasicsForEmployment359">
                <div class="engJSTheory">How do you remove falsy values from an array</div>
                <div class="ruJSTheory">Как удалить ложные значения из массива</div>
            </a>
            <a href="#JSbasicsForEmployment360">
                <div class="engJSTheory">How do you get unique values of an array</div>
                <div class="ruJSTheory">Как получить уникальные значения массива</div>
            </a>
            <a href="#JSbasicsForEmployment361">
                <div class="engJSTheory">What is destructuring aliases</div>
                <div class="ruJSTheory">Что такое деструктуризация псевдонимов</div>
            </a>
            <a href="#JSbasicsForEmployment362">
                <div class="engJSTheory">How do you map the array values without using map method</div>
                <div class="ruJSTheory">Напишите полифил метода map для массивов(Как мэппизировать значения массива без
                    использования map метода)
                </div>
            </a>
            <a href="#JSbasicsForEmployment363">
                <div class="engJSTheory">How do you empty an array</div>
                <div class="ruJSTheory">Как очистить массив</div>
            </a>
            <a href="#JSbasicsForEmployment364">
                <div class="engJSTheory">How do you rounding numbers to certain decimals</div>
                <div class="ruJSTheory">Как округлить числа до определенных десятичных знаков?</div>
            </a>
            <a href="#JSbasicsForEmployment365">
                <div class="engJSTheory">What is the easiest way to convert an array to an object</div>
                <div class="ruJSTheory">Как проще всего преобразовать массив в объект?</div>
            </a>
            <a href="#JSbasicsForEmployment366">
                <div class="engJSTheory">How do you create an array with some data</div>
                <div class="ruJSTheory">Как создать массив с данными</div>
            </a>
            <a href="#JSbasicsForEmployment367">
                <div class="engJSTheory">What are the placeholders from console object</div>
                <div class="ruJSTheory">Что такое заполнители(placeholders) из объекта console</div>
            </a>
            <a href="#JSbasicsForEmployment368">
                <div class="engJSTheory">Is it possible to add CSS to console messages</div>
                <div class="ruJSTheory">Можно ли добавить CSS в сообщения консоли?</div>
            </a>
            <a href="#JSbasicsForEmployment369">
                <div class="engJSTheory">What is the purpose of dir method of console object</div>
                <div class="ruJSTheory">Какова цель метода dir объекта console</div>
            </a>
            <a href="#JSbasicsForEmployment370">
                <div class="engJSTheory">Is it possible to debug HTML elements in console</div>
                <div class="ruJSTheory">Можно ли отлаживать HTML-элементы в консоли?</div>
            </a>
            <a href="#JSbasicsForEmployment371">
                <div class="engJSTheory">How do you display data in a tabular format using console object</div>
                <div class="ruJSTheory">Как отображать данные в табличном формате с помощью объекта console?</div>
            </a>
            <a href="#JSbasicsForEmployment372">
                <div class="engJSTheory">How do you verify that an argument is a Number or not</div>
                <div class="ruJSTheory">Как проверить, является ли аргумент числом или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment373">
                <div class="engJSTheory">How do you create copy to clipboard button</div>
                <div class="ruJSTheory">Как создать кнопку "Копировать в буфер обмена"</div>
            </a>
            <a href="#JSbasicsForEmployment374">
                <div class="engJSTheory">What is the shortcut to get timestamp</div>
                <div class="ruJSTheory">Какой ярлык позволяет получить текущую дату</div>
            </a>
            <a href="#JSbasicsForEmployment375">
                <div class="engJSTheory">How do you flattening multi dimensional arrays</div>
                <div class="ruJSTheory">Как вы выравниваете многомерные массивы?</div>
            </a>
            <a href="#JSbasicsForEmployment376">
                <div class="engJSTheory">What is the easiest multi condition checking</div>
                <div class="ruJSTheory">Какая самая простая проверка нескольких условий?</div>
            </a>
            <a href="#JSbasicsForEmployment377">
                <div class="engJSTheory">How do you capture browser back button</div>
                <div class="ruJSTheory">Как активировать кнопку возврата браузера(не щелкая по ней в самом браузере)
                </div>
            </a>
            <a href="#JSbasicsForEmployment378">
                <div class="engJSTheory">How do you disable right click in the web page</div>
                <div class="ruJSTheory">Как отключить щелчок правой кнопкой мыши на веб-странице</div>
            </a>
            <a href="#JSbasicsForEmployment379">
                <div class="engJSTheory">What are wrapper objects</div>
                <div class="ruJSTheory">Что такое объекты-обертки</div>
            </a>
            <a href="#JSbasicsForEmployment380">
                <div class="engJSTheory">What is AJAX</div>
                <div class="ruJSTheory">Что такое AJAX(асинхронный JS и XML)</div>
            </a>
            <a href="#JSbasicsForEmployment381">
                <div class="engJSTheory">What are the different ways to deal with Asynchronous Code</div>
                <div class="ruJSTheory">What are the different ways to deal with Asynchronous Code</div>
            </a>
            <a href="#JSbasicsForEmployment382">
                <div class="engJSTheory">How to cancel a fetch request</div>
                <div class="ruJSTheory">Как отменить fetch запрос</div>
            </a>
            <a href="#JSbasicsForEmployment383">
                <div class="engJSTheory">What is web speech API</div>
                <div class="ruJSTheory">Что такое web speech API</div>
            </a>
            <a href="#JSbasicsForEmployment384">
                <div class="engJSTheory">What is minimum timeout throttling</div>
                <div class="ruJSTheory">Что такое регулирование минимального таймаута(minimum timeout throttling)</div>
            </a>
            <a href="#JSbasicsForEmployment385">
                <div class="engJSTheory">How do you implement zero timeout in modern browsers</div>
                <div class="ruJSTheory">Как реализовать нулевой таймаут в современных браузерах</div>
            </a>
            <a href="#JSbasicsForEmployment386">
                <div class="engJSTheory">What are tasks in event loop</div>
                <div class="ruJSTheory">Что такое задачи в цикле событий</div>
            </a>
            <a href="#JSbasicsForEmployment387">
                <div class="engJSTheory">What is microtask</div>
                <div class="ruJSTheory">Что такое микрозадача</div>
            </a>
            <a href="#JSbasicsForEmployment388">
                <div class="engJSTheory">What are different event loops</div>
                <div class="ruJSTheory">Что такое разные циклы событий</div>
            </a>
            <a href="#JSbasicsForEmployment389">
                <div class="engJSTheory">What is the purpose of queueMicrotask</div>
                <div class="ruJSTheory"> Какова цель queueMicrotask</div>
            </a>
            <a href="#JSbasicsForEmployment390">
                <div class="engJSTheory">How do you use javascript libraries in typescript file</div>
                <div class="ruJSTheory">Как использовать библиотеки JavaScript в typescript файле?</div>
            </a>
            <a href="#JSbasicsForEmployment391">
                <div class="engJSTheory">What are the differences between promises and observables</div>
                <div class="ruJSTheory">В чем разница между promise и observable</div>
            </a>
            <a href="#JSbasicsForEmployment392">
                <div class="engJSTheory">What is heap</div>
                <div class="ruJSTheory">Что такое heap</div>
            </a>
            <a href="#JSbasicsForEmployment393">
                <div class="engJSTheory">What is an event table</div>
                <div class="ruJSTheory">Что такое таблица событий</div>
            </a>
            <a href="#JSbasicsForEmployment394">
                <div class="engJSTheory">What is a microTask queue</div>
                <div class="ruJSTheory">Что такое очередь микрозадач</div>
            </a>
            <a href="#JSbasicsForEmployment395">
                <div class="engJSTheory">What is the difference between shim and polyfill</div>
                <div class="ruJSTheory">В чем разница между шиммом и полифиллом</div>
            </a>
            <a href="#JSbasicsForEmployment396">
                <div class="engJSTheory">How do you detect primitive or non primitive value type</div>
                <div class="ruJSTheory">Как определить примитивный или не примитивный тип значения</div>
            </a>
            <a href="#JSbasicsForEmployment397">
                <div class="engJSTheory">What is babel</div>
                <div class="ruJSTheory">Что такое babel</div>
            </a>
            <a href="#JSbasicsForEmployment398">
                <div class="engJSTheory">Is Node.js completely single threaded</div>
                <div class="ruJSTheory">Является ли Node.js полностью однопоточным?</div>
            </a>
            <a href="#JSbasicsForEmployment399">
                <div class="engJSTheory">What are the common use cases of observables</div>
                <div class="ruJSTheory">Каковы распространенные случаи использования observable</div>
            </a>
            <a href="#JSbasicsForEmployment400">
                <div class="engJSTheory">What is RxJS</div>
                <div class="ruJSTheory">Что такое RxJS</div>
            </a>
            <a href="#JSbasicsForEmployment401">
                <div class="engJSTheory">What is the difference between Function constructor and function declaration
                </div>
                <div class="ruJSTheory">В чем разница между конструктором функции и объявлением функции</div>
            </a>
            <a href="#JSbasicsForEmployment402">
                <div class="engJSTheory">What is a Short circuit condition</div>
                <div class="ruJSTheory">Что такое короткое замыкание</div>
            </a>
            <a href="#JSbasicsForEmployment403">
                <div class="engJSTheory">What is the easiest way to resize an array</div>
                <div class="ruJSTheory">Как проще всего изменить размер массива</div>
            </a>
            <a href="#JSbasicsForEmployment404">
                <div class="engJSTheory">What is an observable</div>
                <div class="ruJSTheory">Что такое observable</div>
            </a>
            <a href="#JSbasicsForEmployment405">
                <div class="engJSTheory">What is the difference between function and class declarations</div>
                <div class="ruJSTheory">В чем разница между объявлениями функций и классов</div>
            </a>
            <a href="#JSbasicsForEmployment406">
                <div class="engJSTheory">What is an async function</div>
                <div class="ruJSTheory">Что такое асинхронная функция</div>
            </a>
            <a href="#JSbasicsForEmployment407">
                <div class="engJSTheory">How do you prevent promises swallowing errors</div>
                <div class="ruJSTheory">Как предотвратить ошибки, связанные с проглатыванием промисов?</div>
            </a>
            <a href="#JSbasicsForEmployment408">
                <div class="engJSTheory">What is deno</div>
                <div class="ruJSTheory">Что такое deno</div>
            </a>
            <a href="#JSbasicsForEmployment409">
                <div class="engJSTheory">How do you make an object iterable in javascript</div>
                <div class="ruJSTheory">Как сделать объект итерируемым в JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment410">
                <div class="engJSTheory">What is a Proper Tail Call</div>
                <div class="ruJSTheory">Что такое правильный хвостовой вызов</div>
            </a>
            <a href="#JSbasicsForEmployment411">
                <div class="engJSTheory">How do you check an object is a promise or not</div>
                <div class="ruJSTheory">Как проверить, является ли объект промисом или нет?</div>
            </a>
            <a href="#JSbasicsForEmployment412">
                <div class="engJSTheory">How to detect if a function is called as constructor</div>
                <div class="ruJSTheory">Как определить, вызывается ли функция как конструктор</div>
            </a>
            <a href="#JSbasicsForEmployment413">
                <div class="engJSTheory">What are the differences between arguments object and rest parameter</div>
                <div class="ruJSTheory">Каковы различия между объектом аргументов и параметром rest</div>
            </a>
            <a href="#JSbasicsForEmployment414">
                <div class="engJSTheory">What are the differences between spread operator and rest parameter</div>
                <div class="ruJSTheory">В чем разница между spread оператором и rest параметром</div>
            </a>
            <a href="#JSbasicsForEmployment415">
                <div class="engJSTheory">What are the different kinds of generators</div>
                <div class="ruJSTheory">Какие существуют виды генераторов</div>
            </a>
            <a href="#JSbasicsForEmployment416">
                <div class="engJSTheory">What are the built-in iterables</div>
                <div class="ruJSTheory">Какие есть встроенные итерируемые сущности</div>
            </a>
            <a href="#JSbasicsForEmployment417">
                <div class="engJSTheory">What are the differences between for...of and for...in statements</div>
                <div class="ruJSTheory">В чем разница между операторами for...of и for...in</div>
            </a>
            <a href="#JSbasicsForEmployment418">
                <div class="engJSTheory">How do you define instance and non-instance properties</div>
                <div class="ruJSTheory">Как вы определяете свойства экземпляра и неэкземпляра</div>
            </a>
            <a href="#JSbasicsForEmployment419">
                <div class="engJSTheory">What is the difference between isNaN and Number.isNaN?</div>
                <div class="ruJSTheory">В чем разница между isNaN и Number.isNaN?</div>
            </a>
            <a href="#JSbasicsForEmployment420">
                <div class="engJSTheory">How to invoke an IIFE without any extra brackets?</div>
                <div class="ruJSTheory">Как вызвать IIFE без дополнительных скобок?</div>
            </a>
            <a href="#JSbasicsForEmployment421">
                <div class="engJSTheory">Is that possible to use expressions in switch cases?</div>
                <div class="ruJSTheory">Можно ли использовать выражения в switch case цикле?</div>
            </a>
            <a href="#JSbasicsForEmployment422">
                <div class="engJSTheory">What is the easiest way to ignore promise errors?</div>
                <div class="ruJSTheory">Как проще всего игнорировать ошибки промисов?</div>
            </a>
            <a href="#JSbasicsForEmployment423">
                <div class="engJSTheory">How do style the console output using CSS?</div>
                <div class="ruJSTheory">Как оформить вывод консоли с помощью CSS?</div>
            </a>
            <a href="#JSbasicsForEmployment424">
                <div class="engJSTheory">What is nullish coalescing operator (??)?</div>
                <div class="ruJSTheory">Что такое нулевой оператор слияния (??)?</div>
            </a>
            <a href="#JSbasicsForEmployment425">
                <div class="engJSTheory">How do you group and nest console output?</div>
                <div class="ruJSTheory">Как группировать и вкладывать вывод консоли?</div>
            </a>
            <a href="#JSbasicsForEmployment426">
                <div class="engJSTheory">What is the difference between dense and sparse arrays?</div>
                <div class="ruJSTheory">В чем разница между плотными и разреженными массивами?</div>
            </a>
            <a href="#JSbasicsForEmployment427">
                <div class="engJSTheory">What are the different ways to create sparse arrays?</div>
                <div class="ruJSTheory">Какие существуют способы создания разреженных массивов?</div>
            </a>
            <a href="#JSbasicsForEmployment428">
                <div class="engJSTheory">What is the difference between setTimeout, setImmediate and process.nextTick?
                </div>
                <div class="ruJSTheory">В чем разница между setTimeout, setImmediate и process.nextTick?</div>
            </a>
            <a href="#JSbasicsForEmployment429">
                <div class="engJSTheory">How do you reverse an array without modifying original array?</div>
                <div class="ruJSTheory">Как перевернуть массив, не изменяя исходный массив?</div>
            </a>
            <a href="#JSbasicsForEmployment430">
                <div class="engJSTheory">How do you create custom HTML element?</div>
                <div class="ruJSTheory">Как создать кастомный HTML-элемент?</div>
            </a>
            <a href="#JSbasicsForEmployment431">
                <div class="engJSTheory">What is global execution context?</div>
                <div class="ruJSTheory">Что такое глобальный контекст выполнения?</div>
            </a>
            <a href="#JSbasicsForEmployment432">
                <div class="engJSTheory">What is function execution context?</div>
                <div class="ruJSTheory">Что такое контекст выполнения функции?</div>
            </a>
            <a href="#JSbasicsForEmployment433">
                <div class="engJSTheory">What is debouncing?</div>
                <div class="ruJSTheory">Что такое debouncing?</div>
            </a>
            <a href="#JSbasicsForEmployment434">
                <div class="engJSTheory">What is throttling</div>
                <div class="ruJSTheory">Что такое троттлинг(throttling)</div>
            </a>
            <a href="#JSbasicsForEmployment435">
                <div class="engJSTheory">What is optional chaining?</div>
                <div class="ruJSTheory">Что такое optional chaining?</div>
            </a>
            <a href="#JSbasicsForEmployment436">
                <div class="engJSTheory">What is an environment record?</div>
                <div class="ruJSTheory">Что такое запись environment record?</div>
            </a>
            <a href="#JSbasicsForEmployment437">
                <div class="engJSTheory">How to verify if a variable is an array?</div>
                <div class="ruJSTheory">Как проверить, является ли переменная массивом?</div>
            </a>
            <a href="#JSbasicsForEmployment438">
                <div class="engJSTheory">What is pass by value and pass by reference?</div>
                <div class="ruJSTheory">Что такое передача по значению и передача по ссылке?</div>
            </a>
            <a href="#JSbasicsForEmployment439">
                <div class="engJSTheory">What are the differences between primitives and non-primitives?</div>
                <div class="ruJSTheory">В чем разница между примитивами и непримитивами?</div>
            </a>
            <a href="#JSbasicsForEmployment440">
                <div class="engJSTheory">How do you create your own bind method using either call or apply method?</div>
                <div class="ruJSTheory">Как создать свой собственный метод bind, используя метод call или apply?</div>
            </a>
            <a href="#JSbasicsForEmployment441">
                <div class="engJSTheory">What are the differences between pure and impure functions?</div>
                <div class="ruJSTheory">В чем разница между чистыми и нечистыми функциями?</div>
            </a>
            <a href="#JSbasicsForEmployment442">
                <div class="engJSTheory">What is referential transparency?</div>
                <div class="ruJSTheory">Что такое ссылочная прозрачность?</div>
            </a>
            <a href="#JSbasicsForEmployment443">
                <div class="engJSTheory">What are the possible side-effects in javascript?</div>
                <div class="ruJSTheory">Какие существуют побочные эффекты в JavaScript?</div>
            </a>
            <a href="#JSbasicsForEmployment444">
                <div class="engJSTheory">What are compose and pipe functions?</div>
                <div class="ruJSTheory">Что такое функции компоновки и конвейера?</div>
            </a>
            <a href="#JSbasicsForEmployment445">
                <div class="engJSTheory">What is module pattern?</div>
                <div class="ruJSTheory">Что такое шаблон модуля?</div>
            </a>
            <a href="#JSbasicsForEmployment446">
                <div class="engJSTheory">What is Function Composition?</div>
                <div class="ruJSTheory">Что такое композиция функций?</div>
            </a>
            <a href="#JSbasicsForEmployment447">
                <div class="engJSTheory">How to use await outside of async function prior to ES2022?</div>
                <div class="ruJSTheory">Как использовать await вне асинхронной функции до ES2022?</div>
            </a>
        </nav>

        <nav class="JSpracticeNav displayNoneClass hiddenElem">
            <a href="#JSlesson1">UNIT 1. СТАРТУЕМ И ПИШЕМ ПЕРВУЮ ПРОГРАММУ</a>
            <a href="#JSlesson2">UNIT 2. ОСНОВЫ ВВОДА ДАННЫХ</a>
            <a href="#JSlesson3">UNIT 3. ОПЕРАТОР IF, ELSE, SWITCH CASE - ВЫБОР В JAVASCRIPT</a>
            <a href="#JSlesson4">UNIT 4. РАБОТАЕМ С ФОРМАМИ: INPUT, RANGE, TEXTAREA, CHECKBOX...</a>
            <a href="#JSlesson5">UNIT 5. ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 1)</a>
            <a href="#JSlesson6">UNIT 6. ВЛОЖЕННЫЕ ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 2)</a>
            <a href="#JSlesson7">UNIT 7. ФУНКЦИИ И ВСЕ О НИХ</a>
            <a href="#JSlesson8">UNIT 8. ЦИКЛ WHILE, DO WHILE</a>
            <a href="#JSlesson9">UNIT 9. РАБОТАЕМ С DOM</a>
            <a href="#JSlesson10">UNIT 10. МАССИВЫ В JAVASCRIPT</a>
            <a href="#JSlesson11">UNIT 11. ДОБАВЛЕНИЕ И УДАЛЕНИЕ ЭЛЕМЕНТОВ В МАССИВЕ, POP, PUSH,SPLICE</a>
            <a href="#JSlesson12">UNIT 12. ДВУМЕРНЫЕ МАССИВЫ</a>
            <a href="#JSlesson13">UNIT 13. АССОЦИАТИВНЫЙ МАССИВ (ОБЪЕКТ) В JAVASCRIPT</a>
            <a href="#JSlesson14">UNIT 14. ПРАКТИКА ПО МАССИВАМ - ПОЛУЧАЕМ ПРОГНОЗ ПОГОДЫ ПО API</a>
            <a href="#JSlesson15">UNIT 15. SET В JAVASCRIPT</a>
            <a href="#JSlesson16">UNIT 16. ПЕРЕБОР МАССИВОВ: FOR, FOR IN, FOR OF</a>
            <a href="#JSlesson17">UNIT 17. МЕТОДЫ МАССИВОВ: MAP, FILTER ( ЧАСТЬ 1)</a>
            <a href="#JSlesson18">UNIT 18. МЕТОДЫ МАССИВОВ: JOIN, SPLIT, FOREACH ( ЧАСТЬ 2)</a>
            <a href="#JSlesson19">UNIT 19. СОБЫТИЯ МЫШИ В JAVASCRIPT</a>
            <a href="#JSlesson20">UNIT 20. СОБЫТИЯ КЛАВИАТУРЫ В JAVASCRIPT</a>
            <a href="#JSlesson21">UNIT 21. КРАТКИЙ ОБЗОР TOUCH СОБЫТИЙ</a>
            <a href="#JSlesson22">UNIT 22. ОБРАБАТЫВАЕМ ОШИБКИ С ПОМОЩЬЮ TRY CATCH</a>
            <a href="#JSlesson23">UNIT 23. LOCALSTORAGE. СОХРАНЯЕМ ВСЕ</a>
            <a href="#JSlesson24">UNIT 24. НЕМНОГО ТЕОРИИ - РАБОТА С POST, GET ЗАПРОСАМИ</a>
            <a href="#JSlesson25">UNIT 25. AJAX - АСИНХРОННЫЙ JAVASCRIPT</a>
            <a href="#JSlesson26">UNIT 26. УЧИМ FETCH НА ПРАКТИКЕ</a>
            <a href="#JSlesson27">UNIT 27. РАБОТАЕМ С ПРОМИСАМИ (PROMISE)</a>
            <a href="#JSlesson28">UNIT 28. ООП В ES6</a>
            <a href="#JSlesson29">UNIT 29. ЗАМЫКАНИЯ</a>
            <a href="#JSlesson30">UNIT 30. РЕКУРСИЯ</a>
        </nav>

        <nav class="ReactFullCoursesNav displayNoneClass hiddenElem">
            <a id="ReactNavButt">Основы React</a>
            <a id="reactReduxNavButt">Основы React Redux</a>
            <a id="reactRouterBNavButt">Основы React Router</a>
            <a id="RTQQueryNavButt">Основы RTK Query</a>
        </nav>

        <nav class="ReactNav displayNoneClass hiddenElem">
            <a href="#ReactBase">Основы React</a>
            <a href="#Components">Компоненты</a>
            <a href="#DeclatationMethod">Декларативный подход</a>
            <a href="#JSX">JSX код</a>
            <a href="#CSSstyling">Стилизация CSS</a>
            <a href="#JSXrender">Отображение динамических данных в JSX</a>
            <a href="#Props">Передача данных при помощи props</a>
            <a href="#dividingComponents">Разделение компонента на несколько компонентов</a>
            <a href="#propsChildren">Композиция {props.children}</a>
            <a href="#oldReactMethod">Старый метод программирования React</a>
            <a href="#folderOrganization">Организация файлов компонентов</a>
            <a href="#onHandlers">Прослушивание событий и работа с обработчиками событий</a>
            <a href="#workWithState">Работа с состоянием</a>
            <a href="#twoWayBinding">Добавление двустороннего связывания</a>
            <a href="#liftingStateUp">Коммуникация компонентов наследник-родитель (Снизу Вверх)</a>
            <a href="#dummyComponentsVsComponentsWithState">Компоненты - контролируемые vs неконтролируемые, с
                состоянием vs без состояния</a>
            <a href="#dynamicContent">Отображение списков данных(Работа с динамическим контентом)</a>
            <a href="#useState">Использование списков с состоянием</a>
            <a href="#keysConcept">концепция Keys</a>
            <a href="#ternaryOperator">Отображение контента по условию</a>
            <a href="#returnValueByCondition">Возвращение значения по условию</a>
            <a href="#dynamicStyles">Динамические стили</a>
            <a href="#title">Title</a>
            <a href="#CssReact">CSS в React</a>
            <a href="#dynamicCss">Динамическое добавление стилей</a>
            <a href="#dynamicClasses">Динамическое добавление классов</a>
            <a href="#StyledComponents">Знакомство со Styled Components</a>
            <a href="#DynamicProps">Styled Components и Динамические Props</a>
            <a href="#StyledCopmponentsMediaQueries">Styled Components и Media Queries</a>
            <a href="#CssModules">Использование CSS Модулей</a>
            <a href="#dynamicModules">Динамические Стили и CSS Модули</a>
            <a href="#Debugging">Отладка (Debugging) приложений React</a>
            <a href="#ReactDevTools">Использование React DevTools</a>
            <a href="#JSXrestrictions">Ограничения JSX</a>
            <a href="#Portals">Порталы</a>
            <a href="#useRef">Работа с хуком useRef</a>
            <a href="#useEffect">Побочные эффекты</a>
            <a href="#Debouncing">Функция очистки</a>
            <a href="#useReducer">хук useReducer</a>
            <a href="#useStateVSuseReducer">useState VS useReducer</a>
            <a href="#Context">Context</a>
            <a href="#useContext">Хук useContext</a>
            <a href="#dynamicContext">Динамический Context</a>
            <a href="#customProviderComponent">Кастомный компонент Context Provider</a>
            <a href="#contextRestriction">Ограничения context</a>
            <a href="#hookRooles">Правила использования хуков</a>
            <a href="#forwardRefUseImperativeHandle">forwardRef и useImperativeHandle</a>
            <a href="#howReactWorks">Как работает React</a>
            <a href="#childComponentsEvaluation">Переоценка дочернего компонента</a>
            <a href="#ReactMemo">Предотвращение Ненужных Переоценок при Помощи React.memo()</a>
            <a href="#useCallback">Предотвращение Пересоздания Функций при Помощи useCallback()</a>
            <a href="#planningState">Обновление состояний и Планирование</a>
            <a href="#classBasedComponents">Компоненты на основе классов</a>
            <a href="#classBasedComponentStructure">Структура Компонента на Основе Класса</a>
            <a href="#workWithStateInClassBasedComponent">Работа с Состояниями и Событиями в Компонентах на Основе
                Класса</a>
            <a href="#lifeCycleMethods">Жизненный Цикл Компонентов на Основе Классов</a>
            <a href="#classBasedComponentContext">Компоненты на Основе Классов и Контекст</a>
            <a href="#errorBoundaries">Error Boundaries</a>
            <a href="#connectinWithBD">Соединение с базой данных</a>
            <a href="#getFetching">Отправка GET запроса</a>
            <a href="#fetchState">Управление загрузкой и состояниями данных</a>
            <a href="#reactRouteTryCatch">Обработка HTTP Ошибок</a>
            <a href="#reactRouteUseEffectForFetch">Использование useEffect для Запросов</a>
            <a href="#postFetching">Отправка Запроса POST</a>
            <a href="#customReactRouteHook">Создание Функции Custom React Hook</a>
            <a href="#customHooksParams">Конфигурация Custom Hooks</a>
            <a href="#workingWithReactRouteForm">Работа с вводом данных из форм</a>
        </nav>

        <nav class="reactReduxNav displayNoneClass hiddenElem">
            <a href="#reduxAPI">Библиотека Redux</a>
            <a href="#reduxVSReactContext">Redux VS React Context</a>
            <a href="#reduxBasics">Как работает Redux</a>
            <a href="#reduxStoreCreation">Создание хранилища</a>
            <a href="#reduxStoreProviding">Предоставление хранилище всему React приложению</a>
            <a href="#useSelector">Использование Данных Redux в React Компонентах</a>
            <a href="#useDispatch">Отправка actions</a>
            <a href="#reactReduxInClassBasedComponents">Redux в Классовых Компонентах</a>
            <a href="#workingWithSeveralStates">Работа с Несколькими Свойствами Состояний</a>
            <a href="#reduxRules">Правилa Работы с Redux Состоянием</a>
            <a href="#reduxToolkit">Redux Toolkit</a>
            <a href="#reduxUseEffect">Работа с Побочными Эффектами в Redux</a>
            <a href="#frontendvsBackend">Frontend vs Backend</a>
            <a href="#logicPlace">Где размещать логику?</a>
            <a href="#actionCreatorSlice">Запись и извлечение данных с сервера</a>
            <a href="#createAsyncThunk">createAsyncThunk в Redux Toolkit</a>
            <a href="#thunkApi">ThunkApi в Redux Toolkit</a>
            <a href="#reduxDevTools">Redux DevTools</a>
        </nav>

        <nav class="reactRouterBNav displayNoneClass hiddenElem">
            <a href="#reactRouterBasics">React Router. Что такое маршрутизация?(Routing)</a>
            <a href="#urlInfo">Что такое URL?</a>
            <a href="#httpMethods">Методы HTTP запросов.</a>
            <a href="#reactRouter">Работа с React Router v5</a>
            <a href="#linkInRouterApp">Работа со Ссылками</a>
            <a href="#navLinkComponent">Компонент NavLink</a>
            <a href="#dynamicRouter">Добавление Динамических Маршрутов с Параметрами</a>
            <a href="#switchComponent">Использование компонента Switch</a>
            <a href="#inneredRouters">Вложенные Маршруты и Перенаправление Пользователя</a>
        </nav>

        <nav class="typeScriptNav displayNoneClass hiddenElem">
            <a href="#typescript">TypeScript</a>
            <a href="#typeAnnotationsAndTypeInference">Аннотации и вывод типов</a>
            <a href="#typeAlias">Type Alias (Псевдонимы типов)</a>
            <a href="#functionTypeAnnotations">Аннотации TS для функций и объектов</a>
            <a href="#nullAndUndefinedTypes">Типы null и undefined</a>
            <a href="#symbolAndBigIntTypes">Типы symbol и BigInt</a>
            <a href="#typeAny">Тип any</a>
            <a href="#typeUnknown">Тип unknown</a>
            <a href="#returnVoid">Возвращаемый функцией тип void</a>
            <a href="#requestsType">Запросы типа</a>
            <a href="#optionalOperatorReadonly">Опциональный (Optional operator) и notNull/notUndefined операторы и
                модификатор readonly</a>
            <a href="#arraysInTS">Массивы в TS</a>
            <a href="#tuples">Tuples(Кортежи) в TS</a>
            <a href="#interfaces">Интерфейсы</a>
            <a href="#interfaceVSTypes">Interface VS Types</a>
            <a href="#classesInTS">Классы в TS</a>
            <a href="#typeGuard">Type Guard (защита типов)</a>
            <a href="#functionOverloads">Перегрузка функций (function overloads)</a>
            <a href="#designPatternsInTS">Использование шаблонов проектирования(Design Patterns) в TS</a>
            <a href="#abstractClasses">Абстрактные классы</a>
            <a href="#enumerations">Enumerations(enum)</a>
            <a href="#typeAssertions">Type assertions(утверждение типа)</a>
            <a href="#typesOfConstructorCreatedVariables">Типы переменных значения которых созданы при помощи
                конструкторов класса</a>
            <a href="#objectCreation">Создание объектов на базе другого или других</a>
            <a href="#TSGenerics">Дженерики/Обобщения (generics) в TS</a>
            <a href="#TSOperators">TypeScript операторы</a>
            <a href="#TSClassPropertiesAndMethodsModifieres">TypeScript модификаторы свойств и методов класса</a>
            <a href="#indexedAccessTypes">Доступ по индексному ключу (Indexed Access Types)</a>
            <a href="#ternaryOperatorWithTS">Тернарный оператор и TS</a>
            <a href="#mappedTypes">Сопоставление типов (mapped types)</a>
            <a href="#templatesLiteralTypes">Шаблонные литеральные типы (Templates Literal Types)</a>
            <a href="#utilityTypes">Utility Types</a>
            <a href="#TSFetchAndPromise">TS, Fetch и Promise</a>
            <a href="#inheritanceVSComposition">Inheritance vs Composition</a>
            <a href="#staticMethodsAndProperties">Статические методы и свойства(static)</a>
            <a href="#TSWithJSLibraries">TS с JS библиотеками</a>
            <a href="#ES2015ClassesInTS">Классы в ES2015 и TS</a>
            <a href="#setAnGetInTS">Сеттеры и геттеры в TS</a>
            <a href="#indexClassSignaturesInTS">Индексные сигнатуры классов в TS</a>
            <a href="#classInheritanceInTS">Наследование классов в TS и перезапись свойств и методов потомков</a>
            <a href="#classInterfaces">Интерфейсы для классов(имплементация интерфейсов)</a>
            <a href="#contextInClass">Контекст вызова в классе(this)</a>
            <a href="#decoratorsWithTS">Декораторы в TypeScript</a>
            <a href="#decoratorFactory">Decorator Factory (Фабрика декораторов)</a>
            <a href="#ESDecorators">ES декораторы из версии 5+, ES декораторы классов.</a>
            <a href="#methodsDecoratorsAndThis">Декораторы методов класса и работа с this</a>
            <a href="#decoratorsAndClassProperties">Декораторы и свойства класса</a>
            <a href="#argumentsDecorators">Декораторы аргументов методов класса и декораторы самого класса</a>
            <a href="#propertiesDecorators">Декораторы свойств класса</a>
            <a href="#accessorsDecorators">Декоратор аксесоров класса</a>
            <a href="#parameterDecorators">Декораторы параметров</a>
            <a href="#decoratorsOrder">Порядок выполнения всех типов декораторов</a>
            <a href="#typeUnion">Type union(Объединение типов)</a>
            <a href="#typeIntersection">Пересечение типов(intersection)</a>
            <a href="#reactWithRedux1">React при работе с TypeScript 1</a>
            <a href="#reactWithRedux2">React+Redux при работе с TypeScript 2</a>
            <a href="#reduxWithTS3">Redux + TS 3</a>
        </nav>

        <nav class="RTQQueryNav displayNoneClass hiddenElem">
            <a href="#RTQQueryBasics">Основной функционал Redux Toolkit Query</a>
        </nav>
    </aside>
</header>
<main>
    <h1>Алгоритмы и структуры данных</h1>
    <h3 id="Algorithms">Алгоритмы</h3>

    <section>
        <div>
            <p>Алгоритм это набор последовательных действий, которые решают какую-то задачу.</p>
            <p>Сложность алгоритмов:</p>
            <ul>
                <li>O(log2n)</li>
                <li>O(n)</li>
                <li>O(n*log2n)</li>
                <li>O(n*n)</li>
                <li>O(n!)</li>
            </ul>
            <p>Где О - большое специальная аннотация, а n - количество операций(в которой указывают предполагаемый
                худший результат).</p>
            <img src="./images/AlgorithmsDifficulties.png" alt="AlgorithmsDifficulties" width="644">
            <p><strong>Алгоритм линейного поиска</strong> в массиве начинается с первого элемента, и последовательно
                сравнивается с каждым элементом искомый элемент.</p>
            <p><strong>Бинарный поиск</strong> в массиве начинается с середины массива, далее идет сравнение
                срединного числа с искомым, если искомое число меньше,
                то отсеиваются числа больше срединного числа, если же больше, то отсеиваются меньшие числа, далее
                алгоритм повторяется пока искомое число не будет найдено. Массив изначально должен быть
                отсортирован, если он не отсортирован, то нужно применить другой алгоритм т.к. сортировка будет
                дольше, чем линейный поиск</p>
            <p><strong>Поиск в ширину (англ. breadth-first search, BFS)</strong> — один из методов обхода графа.
                Пусть задан граф
                G=(V,E) и выделена исходная вершина s. Алгоритм поиска в ширину систематически обходит все ребра G
                для «открытия» всех вершин, достижимых из s, вычисляя при этом расстояние (минимальное количество
                рёбер) от s до каждой достижимой из s вершины. Алгоритм работает как для ориентированных, так и для
                неориентированных графов.</p>
            <p><strong>Поиск в глубину(Depth-First Search)</strong> второй метод обхода графа. Идея заключается в том,
                что мы двигаемся от начальной вершины (точки, места) в определенном направлении (по определенному пути)
                до тех пор, пока не достигнем конца пути или пункта назначения (искомой вершины). Если мы достигли конца
                пути,
                но он не является пунктом назначения, то мы возвращаемся назад (к точке разветвления или расхождения
                путей)
                и идем по другому маршруту.</p>
            <p>Пример DFS и BFS алгоритмов для графов разных типов на <a
                    href="https://github.com/Slipbang/algorithms/blob/main/BFS_DFS.js" target="_blank">Гитхабе</a></p>
            <p><strong>Алгоритм Дейкстры</strong> - это алгоритм поиска кратчайшего пути для одной исходной точки.
                Основные идеи заключаются в следующем:</p>
            <ol>
                <li>
                    Разделите вершины на две части: множество вершин Q, которое уже знает текущий кратчайший путь, и
                    множество недостижимых вершин R.
                </li>
                <li>
                    Определите массив расстояний (расстояние), чтобы записать расстояние от исходной точки до каждой
                    вершины. Нижний индекс представляет вершину, а значение элемента - расстояние. Расстояние от
                    исходной точки (начала) до самого себя равно 0, а расстояние между вершиной, которой исходная
                    точка
                    не может достичь, является большим числом (например, бесконечность).
                </li>
                <li>
                    Используйте вершину V с бесконечностью в массиве расстояний в качестве точки перехода. Если
                    предположить, что расстояние от V до вершины W плюс расстояние от вершины V до исходной точки
                    меньше, чем расстояние от вершины W до исходной точки, то ее можно обновить. Расстояние от
                    вершины W
                    до исходной точки. То есть расстояние [V] + матрица [V] [W] &lt; расстояние [W],
                    тогда расстояние [W]=расстояние [V] + матрица [V] [W].
                </li>
                <li>
                    Повторите предыдущий шаг, который состоит в том, чтобы пройти массив расстояний и не достичь
                    набора вершин R, который пуст.
                </li>
            </ol>

            <p></p>
        </div>
    </section>

    <h3 id="dataStructures">Структуры данных</h3>

    <section>
        <div>
            <p>Очередь(Queue) - это структура данных состоящая из каких-то элементов, основной принцип построения
                которой -
                добавление элемента происходит в конец, а извлечение с начала
                FIFO - first in first out(первый вошел первый вышел)</p>
            <img src="./images/queue.jpeg" alt="queue">
            <p>Реализация очереди в JS на <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Queue.js"
                    target="_blank">Гитхаб</a></p>

            <p>Деревья(Tree) - это рекурсивная структура данных, где каждый узел является так же деревом, но для данного
                дерева каждый узел является поддеревом</p>

            <img src="./images/tree.png" alt="tree" width="644">

            <p>Стек(Stack) - это структура данных, основной принцип построения которой - добавление элемента происходит
                в конец и извлечение
                тоже с конца. LIFO - Last in First out(и кладем и берем сверху, основные использующиеся методы push
                и pop)</p>
            <img src="./images/stack.png" alt="stack">

            <p>Реализация стэка JS на <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Stack.js"
                    target="_blank">Гитхаб</a></p>

            <p>Массив(Array) - последовательный набор каких-то объектов. Отличительные особенности массивов - они
                занимают
                конкретный участок в памяти и изначально определено,
                сколько объектов в них будет находиться. Так же, чтобы добавить элемент, нужно создать новый массив,
                скопировать в него значения из старого и добавить новый элемент</p>
            <img src="./images/arrays.jpeg" alt="arrays">

            <p>Граф(Graph) - также известный как сеть (Network), представляет собой коллекцию связанных между собой
                узлов.
                Бывает два вида графов — ориентированный и неориентированный, в зависимости от того,
                имеют ли ссылки направление. Графы могут быть представлены в виде списка или матрицы.</p>

            <img src="./images/graph.jpeg" alt="graph">
            <p>Поиск по графу осуществляется двумя методами — <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/BFS_DFS.js"
                    target="_blank">поиск в ширину (Breath-First-Search, BFS) и поиск в глубину (Depth-First-Search,
                DFS)</a></p>

            <p>Связный список(Linked List) - каждый отдельный элемент списка занимает отдельный элемент в памяти.
                Связность
                списка происходит за счет того, что каждый предыдущий элемент хранит
                ссылку на следующий элемент который лежит в списке. Можно мгновенно добавлять элементы в конец или
                начало списка. Чтобы получить какой-то элемент, нужно итерироваться
                и сравнивать с самого начала списка</p>
            <img src="./images/linkedList.jpeg" alt="Linked list">

            <p>Реализация Linked List в JS(typeScript) на <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/LinkedList.ts">Гитхаб</a>
            </p>

            <p>Бинарное дерево поиска(Binary Search Tree) - структура данных, где каждый узел так же является
                деревом(структура
                рекурсивна) и у каждого узла может быть только два потомка.
                Если добавляемое в дерево значение меньше по значению чем текущий угол, то значение уходит в левое
                поддерево, если больше - то в правое, сравнение происходит с каждым узлом</p>
            <img src="./images/binarySearchTree.png" alt="BST">

            <p>Реализация деревьев в JS(Binary Search Tree) на <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/BST.js" target="_blank">Гитхаб</a>
            </p>

            <p>Куча/пирамида(Heap) - по своей структуре напоминает бинарное дерево поиска, но в отличии него имеет
                следующие требования:</p>
            <ul>
                <li>Значение в любой вершине не меньше, чем значения её потомков для max-heap.</li>
                <li>ЛИБО, значение в любой вершине не больше, чем значения её потомков для min-heap.</li>
                <li>Глубина всех листьев (расстояние до корня) различается не более чем на 1 слой.</li>
                <li>Последний слой заполняется слева направо без пропусков.</li>
            </ul>
            <p>Пример классической двоичной кучи:</p>
            <img src="./images/maxHeap.png" alt="maxHeap">
            <p>Как видно по структуре сортировка ответвлений не обязательна.</p>
            <p>JS реализация сортировки кучей на <a
                    href="https://github.com/Slipbang/algorithms_and_data_structures/blob/main/Heap.js" target="_blank">Гитхаб</a>
            </p>

            <p>Map(словарь/карта) - хранит в себе пары "ключ: значение". Основное преимущество, что можно за
                константное время добавлять (и извлекать) элементы в структуру. Как ключ можно хранить не только
                строковые значения, но и объекты. В JS включен в дефолтный функционал.</p>
            <p>Set(множество) - массив, который хранит только уникальные значения. В JS включен в дефолтный
                функционал.</p>
        </div>
    </section>

    <h1>Основы HTML</h1>

    <h3 id="bsHTMLd">Базовая структура HTML документа</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/01QJmn0vDxs" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <hr>
        <p>Некоторые из ниже приведенных тегов устарели!.</p>
        <h1>заголовок, обозначается тегом "h1"; (размер текста уменьшается от 1 до 6, "hr" - тэг отделяет линией,
            как под этим заголовком)</h1>
        <hr>
        <h2>Заголовок h2; (тэг "br" добавляет межстрочный интервал как под этой строкой)</h2>
        <h4>Заголовок h4</h4>
        <h5>Заголовок h5</h5>
        <h6>Заголовок h6</h6>
        <p> тэг "p" - обычный текст любой величины</p>
        <address> тэг "address" - ссылка на автора</address>
        <br>
        <q>
            Тэг &lt;q&gt; - какая-то умная мысль автора, кавычки ставит сам тэг
        </q>
        <address>Тэг &lt;adress&gt;. Вкупе с тегом &lt;q&gt; дает семантически правильное построение цитаты с
            авторством
        </address>
        <blockquote>
            <p>
                Тэг &lt;blockquote&gt; применяется совместно с тегом "p", для каких-то ну очень умных и
                соответственно длинных мыслей автора
            </p>
        </blockquote>
        <address>Конфуций</address>
        <br>
        <time>Тэг &lt;time&gt; предназначен для обозначения дат: 03.08.2022</time>
        <br>
        <time datetime="03.08.2022">Тег &lt;time&gt; с атрибутом " datetime='дата' ", херня для даунов, которые
            думают, что их сайт из говна и палок будут считывать через ИИ. Дата присвоенная к атрибуту не
            отображается.
        </time>
        <br>
        <b>Тэг "b", по семантической составляющей эквивалентно тэгу "p", изменяет только визуальную составляющую
            (делает текст жирным), лучше редактировать стиль с помощью CSS дабы не было путаницы</b>
        <br>
        <i>Тег "i", та же, что и с "b",но в данном случае меняет шрифт</i>
        <br>
        <br>
        <s>Тег "s", и зачеркнутый текст.</s>
        <br>
        <strong>Тег "strong"- а вот тут уже присутствует семантическое выделение, помимо визуального</strong>
        <br>
        <code>
            Тэг &lt;code&gt; - записанный этим тегом код будет отображаться как текст, но без сохранения
            форматирования:
            const args = {
            name: "Yauhen",
            age: 30
            };
            const getDate = () => new Date;
        </code>
        <br>
        <pre>
    <code>
    Тэг &lt;pre&gt;, внутри которого помещают тэг &lt;code&gt; в котором пишут код для отображения, с сохранением форматирования:

    const args = {
         name: "Yauhen",
         age: 30
    };
    const getDate = () => new Date;
    </code>
        </pre>
        <br>
        <P>Тэг "small"-<small>Cемантическое выделение</small> в тексте, с его уменьшением. Якобы используется для
            сносок. <small>Но это не точно.</small></P>
        <br>
        <del>Тэг &lt;del&gt;-зачеркивает текст, имеет семантический смысл неактуальности текста.</del>
        <br>
        <ins>Тэг &lt;ins&gt;- подчеркивает текст, симантическое выделение текста</ins>
        <br>
        <p>Тэг &lt;sub&gt; выводит букву или слово в нижний индекс, как правило используется для написания формул:
            H<sub>2</sub>O
        </p>
        <br>
        <p>Тэг &lt;sup&gt; выводит букву или слово уже в верхний индекс, так же используется для написания формул:
            x<sup>2</sup>=9
        </p>
    </section>

    <h3 id="metadata">Мета-данные и внешние импорты</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/RTqHlz8VsQA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <hr>
        <p>Пример метаданных вебстраницы</p>
        <img src="./images/meta.png" alt="Just image">
        <p>Тэг "meta" нужен для установки кодировки документа. Так же с помощью этого тега и атрибута "name" и
            "content" можно описать различную SEO информацию, "name" задает тип данных, описание, ключевые слова,
            имя автора, а атрибут "content" описывает эти данные. В пикче-примере всего лишь часть данных.</p>
        <p>Тэг "meta" c атрибутом name="viewport" и content="width=device-width, initial-scale=1" добавляет
            респонсив дизайн на вебстраницу, тоесть размер элементов будет меняться пропорционально экрану
            девайса:</p>
        <pre> &lt;meta name="viewport" content="width=device-width, initial-scale=1 (так же есть атрибут
            "user-scalable=no", но им лучше пользоваться аккуратно)"&gt;</pre>
        <br>
        <p>Следующая конструкция поможет корректно отобразить сайт в Internet explorer и Edge</p>
        <pre>&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;</pre>
        <br>
        <p>Тэг "title" определяет заголовок вкладки в браузере.</p>
        <p>"link" универсальный одиночный тэг, описывается атрибутом "rel" который содержит в себе следующие
            значения:</p>
        <p>Добавление иконки на вкладке вебстраницы:</p>
        <pre>&lt;link rel="shortcut icon" href="icon.ico" type="image/x-icon"&gt;</pre>
        <br>
        <p>Следующая конструкция позволяет добавить иконки различного разрешения на вкладке вебстраницы в
            зависимости от физических параметров экрана девайса, на котором открыта страница:</p>
        <pre>
            &lt;link rel="apple-touch-icon" href="apple-touch-icon.png"&gt;
            &lt;link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png"&gt;
            &lt;link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png"&gt;
        </pre>
        <br>
        <p>Конструкция ниже позволяет подключить таблицу стилей CSS:</p>
        <pre>&lt;link rel="stylesheet" href="styles.css"&gt;</pre>
    </section>

    <h3 id="Validsemaccess">Валидация, семантика и доступность</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/6-9m0I19_Hc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Данный урок лучше смотреть на ютубе, в текстовом варианте можно лишь показать структуру вебстраницы и
            расписать разве что пару определений:</p>
        <pre>
            &lt;!DOCTYPE html&gt;
            &lt;html lang="en"&gt;
            &lt;head&gt;
            &lt;meta charset="UTF-8"&gt;
            &lt;title&gt;Название HTML странице на вкладке&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
            &lt;div&gt;Блочный текст&lt;/div&gt;
            &lt;span&gt;Текст выделение которого распространяется во всю линию&lt;/span&gt;
            &lt;header&gt;Шапка сайта&lt;/header&gt;
            &lt;nav&gt;Навигация&lt;/nav&gt;
            &lt;article&gt;Блок с новостями или информацией&lt;/article&gt;
            &lt;footer&gt;Подвал&lt;/footer&gt;
            &lt;/body&gt;
            &lt;/html&gt;
        </pre>
        <p>Валидность- соответствие HTML документа установленным веб стандартам. Валидацию можно пройти на <a
                href="https://validator.w3.org" target="_blank">сайте консорциума всемирной паутины W3C</a></p>
        <br>
        <p> Семантичный тег это тег который носит смысловое объяснение. Теги делятся на блочные и строчные.(&lt;тэг&gt;...&lt;/тэг&gt;
            и &lt;тэг&gt;)</p>
    </section>

    <h3 id="lists">Списки</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/xXCOXsBzm48" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Непронумерованные списки задаются тэгом "ul", каждый отдельный элемент списка задается тегом "li"</p>
        <p>пример:</p>
        <pre>
            &lt;ul&gt;
                &lt;li&gt;Фронтэнд&lt;/li&gt;
                &lt;li&gt;Бэкэнд&lt;/li&gt;
                &lt;li&gt;фулстэк&lt;/li&gt;
            &lt;/ul&gt;
        </pre>
        <ul>
            <li>Фронтэнд</li>
            <li>Бэкэнд</li>
            <li>фулстэк</li>
        </ul>
        <br>
        <p>Пронумерованные же списки задаются тегом "ol", каждый отдельный элемент списка так же задается тэгом
            "li", из особенностей- имеет два атрибута: start="число с которого нужно начать отсчет списка" и
            reversed - ведет нумерацию списка в обратном порядке.</p>
        <p>примеры:</p>
        <p>без атрибутов</p>
        <pre>
            &lt;ol&gt;
                &lt;li&gt;Фронтэнд&lt;/li&gt;
                &lt;li&gt;Бэкэнд&lt;/li&gt;
                &lt;li&gt;фулстэк&lt;/li&gt;
            &lt;/ol&gt;
        </pre>
        <ol>
            <li>Фронтэнд</li>
            <li>Бэкэнд</li>
            <li>фулстэк</li>
        </ol>
        <p>атрибут start="10"</p>
        <pre>
            &lt;ol start="10"&gt;
               &lt;li&gt;Фронтэнд&lt;/li&gt;
               &lt;li&gt;Бэкэнд&lt;/li&gt;
               &lt;li&gt;фулстэк&lt;/li&gt;
            &lt;/ol&gt;
        </pre>
        <ol start="10">
            <li>Фронтэнд</li>
            <li>Бэкэнд</li>
            <li>фулстэк</li>
        </ol>
        <p>атрибут reversed</p>
        <ol reversed>
            <li>Фронтэнд</li>
            <li>Бэкэнд</li>
            <li>фулстэк</li>
        </ol>
        <p>Так же списки можно вкладывать друг в друга, при этом абсолютно неважна нумерация или ее отсутствие, а
            так же наличие атрибутов.</p>
        <p>Пример маркированного списка с вложенным нумерным реверсивным:</p>
        <ul>
            <li>
                Фронтэнд
                <ol reversed>
                    <li>Mobile</li>
                    <li>UI</li>
                    <li>Node.js</li>
                </ol>
            </li>
            <li>Бэкэнд</li>
            <li>фулстэк</li>
        </ul>
        <p>Список определений включает себя тэг-контейнер "dl", вложенный в него тэг "dt", который содержит в себе
            термин, и тэг "dd", который содержит в себе определение </p>
        <p>пример:</p>
        <dl>
            <dt>Front-end Developer</dt>
            <dd>It's a person who works with the visible part of website</dd>
            <dt>Back-end Developer</dt>
            <dd>It's a person who works with hidden part of a website, including databases and environments</dd>
        </dl>
    </section>

    <h3 id="makingpictures">Оформление картинок</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/nZ8XPmXn2Jk" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Стандартная конструкция для отображение пикчи: &lt;img src="ссылка на пикчу" alt="Just image"&gt; где с
        помощью "img src=" мы подгружаем картинку, а "alt='Just image'"- описание пикчи в случае если браузер не
        может ее отрисовать по каким-то причинам()</p>
        <p id="Billy">
        <pre>
            &lt;img src="./images/imageExample.png" alt="image example"&gt;
    </pre>

        <img src="./images/imageExample.png" alt="image example" width="660" height="440">
        <br>
        <p>Тк вебстраница может быть просмотрена на разных устройствах, то требуется оптимизация картинок под
            различные экраны, в данном случае можно использовать тэг-контейнер "picture"</p>
        <p>Пример верстки:</p>
        <pre>
            &lt;picture&gt;
                &lt;source media="(min-width: 1024px)" srcset="https://picsum.photos/600/600"&gt;
                &lt;source media="(min-width: 768px)" srcset="https://picsum.photos/300/300"&gt;
                &lt;source media="(min-width: 360px)" srcset="https://picsum.photos/100/100"&gt;
                &lt;img src="https://picsum.photos/300/300" alt="Just image"&gt;
            &lt;/picture&gt;
        </pre>
        <!--        <picture>-->
        <!--                <source media="(min-width: 1024px)" srcset="https://picsum.photos/600/600">-->
        <!--                <source media="(min-width: 768px)" srcset="https://picsum.photos/300/300">-->
        <!--                <source media="(min-width: 360px)" srcset="https://picsum.photos/100/100">-->
        <!--                <img src="https://picsum.photos/300/300" alt="Just image">-->
        <!--        </picture>-->
        <br>
        <p>Если нужно дать коммент к пикче то используется тэг-контейнер "fugure", а так же тэг "figcaption",
            который и задает собственно описание пикчи. Данная конструкция может описать сразу несколько
            картинок.</p>
        <p>Пример верстки:</p>
        <pre>
            &lt;figure&gt;
               &lt;img src="./images/imageExample.png" alt="Just image" /&gt;
               &lt;figcaption&gt;It is a simple description for a picture above&lt;/figcaption&gt;
            &lt;/figure&gt;
        </pre>
        <figure>
            <img src="./images/imageExample.png" alt="Just image" width="660" height="440"/>
            <figcaption>It is a simple description for a picture above</figcaption>
        </figure>
        <figure>
                <img src="./images/imageExample.png" alt="Just image" width="330" height="220" />
                <img src="./images/imageExample.png" alt="Just image" width="330" height="220" />
                <img src="./images/imageExample.png" alt="Just image" width="330" height="220" />
            <figcaption>
                <p>It is a simple description for a couple pictures above.It is a simple description for a couple
                    pictures above.It is a simple description for a couple pictures above</p>
            </figcaption>
        </figure>
    </section>

    <h3 id="tables">Таблицы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Fm0gSGQFmec" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Теги для создания таблиц.</p>
        <p>Таблицы строятся последовательно вложенными тегами:</p>
        <ol>
            <li> Во-первых идёт главный образующий тег < table>< /table></li>
            <li> После тега table идёт тег заголовка < caption>< /caption> (если требуется)</li>
            <li> Далее таблица делится на три основные части:
                <ul>
                    <li>
                        <pre>&lt;thead&gt;&lt;/thead&gt;</pre>
                        Cтрока заголовка/шапка таблицы. Нужен для хранения одной или нескольких
                        строк, которые представлены вверху таблицы. Используется только 1 раз в 1 таблице. Чтобы
                        заголовок был выделен жирным шрифтом, вместо тега td нужно использовать тег < th>< /th>.
                    </li>
                    <li>
                        <pre>&lt;tbody&gt;&lt;/tbody&gt;</pre>
                        Основная часть таблицы. Предназначен для хранения основного контента
                        таблицы. Может содержать неограниченное количество строк. Может повторятся несколько раз в 1
                        таблице.
                    </li>
                    <li>
                        <pre>&lt;tfoot&gt;&lt;/tfoot&gt;</pre>
                        Низ таблицы/футер/”подвал” (итоги, результаты). Нужен для хранения
                        одной или нескольких строк, которые идут внизу таблицы. Используется только 1 раз в 1
                        таблице.
                    </li>
                </ul>
            </li>
        </ol>
        <p>Эти теги идут строго друг за другом!</p>
        <p>Внутренная организация таблицы</p>
        <ul>
            <li>Чтобы образовать строку таблицы, используется тег &lt;tr&gt;&lt;/tr&gt; (table row, табличная строка).
            </li>
            <li>Чтобы образовать ряд таблицы (ячейку с информацией), используется тег &lt;td&gt;&lt;/td&gt; (table data,
                данные). Ячейка таблицы записывается уже с какой-либо информацией.
            </li>
            <li>Чтобы объединить несколько ячеек, используется тег td с атрибутами:
                <ul>
                    <li>Colspan – объединяет ячейки по горизонтали.</li>
                    <li>Rowspan – объединяет ячейки по вертикали.</li>
                    <li>В качестве значений указываются числа, которые отображают сколько ячеек должно быть
                        объединено.
                    </li>
                </ul>
            </li>
        </ul>
        <p>Примеры верстки таблиц</p>
        <table>
            <caption>Team members list</caption>
            <thead>
            <tr>
                <td>Speciality</td>
                <td>Quantity</td>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Front-end</td>
                <td>1 Person</td>
            </tr>
            <tr>
                <td>Back-end</td>
                <td>7 Persons</td>
            </tr>
            <tr>
                <td>Full-stack</td>
                <td>2 Persons</td>
            </tr>
            <tr>
                <td>QA</td>
                <td>5 Persons</td>
            </tr>
            </tbody>
            <tfoot>
            <tr>
                <td></td>
                <td>15</td>
            </tr>
            </tfoot>
        </table>
        <p>с обьединенными ячейками и семантическим выделением наименований столбцов:</p>
        <table>
            <caption>Team members list</caption>
            <thead>
            <tr>
                <th>Speciality</th>
                <th>Quantity</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Front-end</td>
                <td>1 Person</td>
            </tr>
            <tr>
                <td>Back-end</td>
                <td>7 Persons</td>
            </tr>
            <tr>
                <td>Full-stack</td>
                <td>2 Persons</td>
            </tr>
            <tr>
                <td>QA</td>
                <td>5 Persons</td>
            </tr>
            </tbody>

            <tfoot>
            <tr>
                <td colspan="2">15</td>
            </tr>
            </tfoot>
        </table>
    </section>

    <h3 id="linksandbuttons">Ссылки и кнопки</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/FA0jjOjTChA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Ссылки:</p>
        <p>Ссылка задается тегом с атрибутом: &lt;а href="ссылка на сайт"&gt;Имя ссылки&lt;/a&gt;</p>
        <p>Пример с переходом в текущей странице браузера:</p>
        <a href="https://youtube.com/YauhenKavalchuk">EXAMPLE</a>
        <hr>
        <p>Приоритетно, чтобы ссылка открывалась на новой странице браузера, тогда в этом случае нужно задать
            атрибут:</p>
        <pre>&lt;a href="ссылка на сайт" target="_blank"&gt;Имя ссылки&lt;/a&gt;</pre>
        <a href="https://youtube.com/YauhenKavalchuk" target="_blank">Канал webDev Кавальчука</a>
        <hr>
        <p>Так же для функции href есть значения tel/mailto/skype.</p>
        <p>пример верстки и результирующие</p>
        <pre>&lt;a href="tel:номер телефона"&gt;текст который будет виден на вебстр&lt/a&gt;</pre>
        <a href="tel:88005553535">88005553535</a>
        <pre>&lt;a href="mailto:емейл на который хотим написать"&gt;текст который будет виден на вебстр&lt;/a&gt;</pre>
        <a href="mailto:someEmail@mail.ru">someEmail@mail.ru</a>
        <pre>&lt;a href="skype:скайп на который хотим позвонить"&gt;текст который будет виден на вебстр&lt;/a&gt;</pre>
        <a href="skype:skypeshkolnikakotoryiyhochetnapisatbtvoeymamke">skypeshkolbnikakotoryiyhochetnapisatbtvoeymamke</a>
        <hr>
        <p>Чтобы было удобно передвигаться по странице с ключевой точки, например с некоего примера, на текст
            описывающий этот пример, можно создать кнопку при помощи функции href="#айдисекция">название кнопки<; и
            функции id="айдисекция"</p>
        <p>пример верстки и результирующая:</p>
        <pre>&lt;а href="#айди атрибут"&gt;Отображаемый текст&lt;/а&gt;</pre>
        <pre>&lt;p id="айди атрибут"&gt;...&lt;/p&gt;</pre>
        <a href="#Billy"> Борьба на подчиние </a>
        <hr>
        <p>Кнопки:</p>
        <p>Что же касается кнопок - это не самостоятельный элемент который задается следующей конструкцией:</p>
        <pre>&lt;button type="button/submit/reset(выбрать одно из)"&gt;Имя кнопки&lt;/button&gt;</pre>
        <p>Тип button определяет просто кнопку, далее ей объявляют логику в JS. Тип submit может отправить форму,
            а reset очистить введеные данные.</p>
        <button type="button">Просто кнопка</button>
        <button type="reset">Кнопка reset</button>
        <button type="submit">Кнопка submit</button>
        <p>Так же для кнопок есть функция autofocus, при открытии страницы кнопка с этим атрибутом сразу
            выделится:</p>
        <button type="button" autofocus>Кнопка</button>
        <p>Функция disabled делает кнопку не активной:</p>
        <button type="button" disabled>Заблокированная кнопка</button>
    </section>

    <h3 id="usefultags">Полезные тэги</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/I8VAlRiGpq4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Тэг "abbr"- пользуется для расшифровки аббревиатур:</p>
        <pre>&lt;abbr title="HyperText Markup Language"&gt;<code><abbr
                title="HyperText Markup Language">HTML</abbr></code>&lt;/abbr&gt;</pre>
        <hr>
        <p>Тэг "datalist" позволяет создать список опций из которых можно выбрать одну опцию, создается список при
            помощи связки тэгов "input","datalist" и "option":</p>
        <pre>
            &lt;input list="list"&gt;
            &lt;datalist id="list"&gt;
                &lt;option value="Front-end"&gt;&lt;/option&gt;
                &lt;option value="Back-end"&gt;&lt;/option&gt;
                &lt;option value="Full-stack"&gt;&lt;/option&gt;
                &lt;option value="Boy Next Door"&gt;&lt;/option&gt;
            &lt;/datalist&gt;
        </pre>

        <input aria-label="list input" list="list">
        <datalist id="list">
            <option value="Front-end"></option>
            <option value="Back-end"></option>
            <option value="Full-stack"></option>
            <option value="Boy Next Door"></option>
        </datalist>
        <p>Тег "meter"- визуальное отображение некоего прогресса в неком диапазоне:</p>
        <pre>&lt;meter value="0" max="100" low="10" high="60"&gt;Course Progress&lt;/meter&gt;</pre>
        <br>

        <meter value="0" max="100" low="10" high="60">Course Progress</meter>
        <br>
        <meter value="20" max="100" low="40" high="60">Course Progress</meter>
        <br>
        <meter value="80" max="100" low="10" high="60">Course Progress</meter>
        <br>
        <meter value="100" max="100">Course Progress</meter>
        <hr>
        <p>Тэг "progress" визуально задает некий прогресс какой-то выполняемой операции:
        <pre>&lt;progress value="30" max="100"&gt;&lt;/progress&gt;</pre>
        <progress value="30" max="100"></progress>
        <hr>
        <p>Тэг "marked" позволяет выделить важный момент в тексте</p>
        <h2>To know HTML
            <mark>semantic</mark>
            is important
        </h2>
        <hr>
        <p>Тэг "canvas" создает область в которой можно рисовать при помощи JS</p>
        <canvas id="example" width="200" height="200"></canvas>
        <pre>
    <code>
    &lt;script&gt;
        const drawingCanvas = document.getElementById('example');
        if(drawingCanvas && drawingCanvas.getContext) {
            const context = drawingCanvas.getContext('2d');
            context.fillStyle = "#000";
            context.beginPath();
            context.arc(100,100,100,0,Math.PI*2,true);
            context.closePath();
            context.stroke();
            context.fill();
        }
    &lt;/script&gt;
    </code>
        </pre>
        <script>
            const drawingCanvas = document.getElementById('example');
            if (drawingCanvas && drawingCanvas.getContext) {
                const context = drawingCanvas.getContext('2d');
                context.fillStyle = "#969f15";
                context.beginPath();
                context.arc(100, 100, 100, 0, Math.PI * 2, true);
                context.closePath();
                context.stroke();
                context.fill();
            }
        </script>
    </section>

    <h3 id="globsitestruct">Глобальная структура сайта</h3>

    <section>
        <p>Глобальная структура сайта создается при помощи набора тегов хронящих в себе различные разделы сайта:</p>
        <ul>
            <li>"header"- Задает шапку сайта или раздел в котором обычно распологается заголовок</li>
            <li>"nav"-Задает навигацию по сайту(допустимо использование несколько nav в одном документе</li>
            <li>"main"- тег предназначенный для основного содержимого в документе</li>
            <li>"section"- применяется для блока новостей, контактной информации, глав текста, различных описаний,
                самый универсальный тег для хранения информации
            </li>
            <li>"aside"- т.н. СайдБар или боковая панель. Определяет блок сбоку от основного контента, предназначен
                для размещения ссылок, банеров, дополнительной навигации и меток.
            </li>
            <li>"footer"- он же подвал сайта. Содержит в себе имя автора, дату документа, контактную информацию,
                копирайт и ссылки на соцсети.
            </li>
        </ul>
        <p>Все глобальные теги можно разделить на две группы: теги расположения и теги содержания.</p>
        <p>Теги расположения отвечают за то, где находится тот или иной элемент на странице, к ним относятся
            "header", "main", "nav", "aside" и "footer". Предназначены для определения позиции группы элементов</p>
        <p>К тегам содержания можно отнести: "article", "figure", а так же аудио и видео теги. Эти же теги сообщают
            о типе контента.</p>
        <a href="http://localhost:63342/01_Base_HTML_Document_Structure/index1.html?_ijt=iiglb08b119ts3ejaobuol0pac&_ij_reload=RELOAD_ON_SAVE"
           target="_blank">Пример</a>
    </section>

    <h3 id="form">Форма</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/N-2-kF1q6j4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Пример самой элементарной формы:</p>

        <pre>
            &lt;form action="formhander.php" name="single form" autocomplete="on"&gt;
                &lt;input type="text"&gt;
                &lt;br&gt;
                &lt;select&gt;
                    &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
                    &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
                &lt;/select&gt;
                &lt;br&gt;
                &lt;textarea rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;
                &lt;br&gt;
                &lt;input type="submit"&gt;
                &lt;br&gt;
            &lt;/form&gt;
        </pre>

        <form action="formHandler.php" name="single form" autocomplete="on">
            <input aria-label="text input" type="text">
            <br>
            <select aria-label="selector">
                <option value="Front-end">Front-end</option>
                <option value="Back-end">Back-end</option>
            </select>
            <br>
            <textarea aria-label="textarea" rows="10" cols="45" name="text"></textarea>
            <br>
            <input type="submit">
            <br>
        </form>
        <hr>

        <pre>
            &lt;form action="formhander.php" name="simple form2" autocomplete="on"&gt;
                &lt;fieldset&gt;
                    &lt;legend&gt;Simple form legend&lt;/legend&gt;
                    &lt;input type="text"&gt;
                    &lt;br&gt;
                    &lt;select&gt;
                        &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
                        &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
                    &lt;/select&gt;
                    &lt;br&gt;
                    &lt;textarea rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;
                    &lt;br&gt;
                    &lt;input type="submit"&gt;
                    &lt;br&gt;
                &lt;/fieldset&gt;
            &lt;/form&gt;
        </pre>

        <form action="formHandler.php" name="simple form2" autocomplete="on">
            <fieldset>
                <legend>Simple form legend</legend>
                <input aria-label="text input" type="text">
                <br>
                <select aria-label="selector">
                    <option value="Front-end">Front-end</option>
                    <option value="Back-end">Back-end</option>
                </select>
                <br>
                <textarea aria-label="textarea" rows="10" cols="45" name="text"></textarea>
                <br>
                <input type="submit">
                <br>
            </fieldset>
        </form>
        <hr>
        <p>Так же "fieldset" можно применять для визуального разделения форм на составные:</p>
        <form action="formHandler.php" name="simple form3">

            <fieldset>
                <legend>Personal data</legend>
                <input aria-label="text input" type="text"/><br>
                <select aria-label="selector">
                    <option value="Front-end">Front-end</option>
                    <option value="Back-end">Back-end</option>
                </select><br>
            </fieldset>
            <fieldset>
                <legend>Personal Message</legend>
                <textarea aria-label="textarea" rows="10" cols="45" name="text"></textarea><br>
            </fieldset>
            <input type="submit">
        </form>
        <hr>
        <p> Тэг "label" добавляет метку для элемента формы и устанавливает связь между этой меткой и полем, при
            нажатии на элемент - курсор устанавливается на форме:</p>
        <p> Пример использования тэга "label":</p>

        <pre>
            &lt;form action="formHandler.php" name="simple form3"&gt;
               &lt;fieldset&gt;
                  &lt;legend&gt;Personal data&lt;/legend&gt;
                  &lt;label for="name"&gt;Your name&lt;/label&gt;
                  &lt;input type="text" id="name" /&gt;&lt;br&gt;
                  &lt;label for="speciality"&gt;Choose your speciality&lt;/label&gt;
                  &lt;select id="speciality"&gt;
                     &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
                     &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
                  &lt;/select&gt;&lt;br&gt;
               &lt;/fieldset&gt;
               &lt;fieldset&gt;
                  &lt;legend&gt;Personal Message&lt;/legend&gt;
                  &lt;label for="message"&gt;Enter your message&lt;/label&gt;
                  &lt;textarea id="message" rows="10" cols="45" name="text"&gt;&lt;/textarea&gt;&lt;br&gt;
               &lt;/fieldset&gt;
               &lt;input type="submit"&gt;
               &lt;br&gt;
            &lt;/form&gt;
            &lt;hr&gt;
        </pre>
        <hr>
        <form action="formHandler.php" name="simple form3">
            <fieldset>
                <legend>Personal data</legend>
                <label for="name">Your name</label>
                <input type="text" id="name"/><br>
                <label for="speciality">Choose your speciality</label>
                <select id="speciality">
                    <option value="Front-end">Front-end</option>
                    <option value="Back-end">Back-end</option>
                </select><br>
            </fieldset>
            <fieldset>
                <legend>Personal Message</legend>
                <label for="message">Enter your message</label>
                <textarea id="message" rows="10" cols="45" name="text"></textarea><br>
            </fieldset>
            <input type="submit">
            <br>
        </form>
        <hr>
        <p>Тэг "textarea" имеет множество атрибутов, например "rows" и "cols", которые задают размер формы:</p>
        <pre>&lt;textarea rows="10" cols="45"&gt;&lt;/textarea&gt;&lt;textarea rows="5" cols="20"&gt;&lt;/textarea&gt;</pre>
        <textarea aria-label="textarea" rows="10" cols="45"></textarea><textarea aria-label="textarea" rows="5" cols="20"></textarea>
        <br>
        <p>Атрибут name="" задает имя форме:</p>
        <pre>&lt;textarea rows="5" cols="20" name="test"&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" name="test"></textarea><br>
        <p>Атрибут autofocus автоматически фокусирует поле</p>
        <pre>&lt;textarea rows="5" cols="20" autofocus&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" autofocus></textarea><br>
        <p>Тэг "disabled" блокирует форму:</p>
        <pre>&lt;textarea rows="5" cols="20" disabled>&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" disabled></textarea><br>
        <p>Тэг "readonly" записывает в форму текст, который невозможно изменить:</p>
        <pre>&lt;textarea rows="5" cols="20" readonly&gt;This text you can't change&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" readonly>This text you can't change</textarea><br>
        <p>Тэг "placeholder" добавляет текст-заменитель,самый используемый атрибут:</p>
        <pre>&lt;textarea rows="5" cols="20" placeholder="your message..."&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" placeholder="your message..."></textarea><br>
        <p>Тэг "maxlength" устанавливает для вводимых символов</p>
        <pre>&lt;textarea rows="5" cols="20" maxlength="5"&gt;&lt;/textarea&gt;&lt;br&gt;</pre>
        <textarea aria-label="textarea" rows="5" cols="20" maxlength="5"></textarea><br>
        <p>Тэг "required" задает обязательным заполнение поля:</p>
        <pre>
            &lt;form&gt;
                &lt;textarea rows="5" cols="20" required&gt;&lt;/textarea&gt;&lt;br&gt;
                &lt;input type="submit" value="send"&gt;
            &lt;/form&gt;
        </pre>

        <form>
            <textarea aria-label="textarea" rows="5" cols="20" required></textarea><br>
            <input type="submit" value="send">
        </form>
        <hr>
        <p>Тэг "select" создает поле с выпадающим списком, имеет все ранее рассмотренные атрибуты, а так же
            дополнительно следующие:</p>
        <p>Тэг "multiple", позволяет сделать несколько выборов из списка:</p>
        <pre>
            &lt;select multiple&gt;
               &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
               &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
            &lt;/select&gt;
        </pre>
        <select aria-label="selector" multiple>
            <option value="Front-end">Front-end</option>
            <option value="Back-end">Back-end</option>
        </select>
        <hr>
        <p>Атрибуты "sel" и "dis" автоматически выбирают или блокируют элементы из списка</p>
        <select aria-label="selector">
            <option value="Front-end">Front-end</option>
            <option value="Back-end" label="Back-end"></option>
            <option value="sel" selected>Selected</option>
            <option value="dis" disabled>Disabled</option>
        </select>
        <p>Тэг "optgroup" разделяет выбор по группам:</p>
        <pre>
            &lt;select&gt;
               &lt;optgroup label="Speciality"&gt;
                  &lt;option value="Front-end"&gt;Front-end&lt;/option&gt;
                  &lt;option value="Back-end"&gt;Back-end&lt;/option&gt;
               &lt;/optgroup&gt;
               &lt;optgroup label="Direction"&gt;
                  &lt;option value="Mobile"&gt;Mobile development&lt;/option&gt;
                  &lt;option value="Node"&gt;Node.js development&lt;/option&gt;
               &lt;/optgroup&gt;
            &lt;/select&gt;
            &lt;hr&gt;
        </pre>
        <select aria-label="selector">
            <optgroup label="Speciality">
                <option value="Front-end">Front-end</option>
                <option value="Back-end">Back-end</option>
            </optgroup>
            <optgroup label="Direction">
                <option value="Mobile">Mobile development</option>
                <option value="Node">Node.js development</option>
            </optgroup>
        </select>
        <hr>
    </section>

    <h3 id="inputtypes">Типы полей ввода</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/JSmINYpl5B4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Элемент "number" у тега "input" предназначен для введения ТОЛЬКО числовых значений. "min"/"max"-
            миним/максимальные значения, "step"- шаг изменения числа:</p>
        <pre>&lt;input type="number" min="0" max="100" step="2"&gt;</pre>
        <input aria-label="number input" type="number" min="0" max="100" step="2">
        <br>
        <hr>
        <p>Элемент "password" предназначен для задания поля пароля</p>
        <pre>&lt;input type="password"&gt;</pre>
        <input aria-label="password input" type="password">
        <hr>
        <p>Элемент "date" задает поле выбора даты</p>
        <pre>&lt;input type="date"&gt;</pre>
        <input aria-label="date input" type="date">
        <hr>
        <p>Элемент "color" предназначен для поля выбора цвета:</p>
        <pre>&lt;input type="color"&gt;</pre>
        <input aria-label="color input" type="color">
        <hr>
        <p>Элемент "submit" и "reset",создают кнопки "отправить" и "сбросить" соответственно. Работают только внутри
            компонента формы. Для изменения названия кнопки используется атрибут "value":</p>
        <pre>&lt;input type="submit" value="отправить"&gt;&lt;input type="reset" value="сбросить"&gt;</pre>
        <input type="submit" value="отправить"><input type="reset" value="сбросить">
        <hr>
        <p>Элемент "text" совместно с "list" задают выпадающий список опций:</p>
        <pre>
            &lt;input type="text" list="list1"&gt;
            &lt;datalist id="list1"&gt;
               &lt;option value="Front-end"&gt;&lt;/option&gt;
               &lt;option value="Back-end"&gt;&lt;/option&gt;
               &lt;option value="Full-stack"&gt;&lt;/option&gt;
            &lt;/datalist&gt;
        </pre>
        <input aria-label="list1" type="text" list="list1">
        <datalist id="list1">
            <option value="Front-end"></option>
            <option value="Back-end"></option>
            <option value="Full-stack"></option>
        </datalist>
        <hr>
        <p>Элемент "emmail" предназначен для создания поля ввода емейл. Автоматически валидирует введенное в строку
            на предмет @ и точки:</p>
        <pre>
            &lt;form action="formhander.php" name="simple form5" autocomplete="on"&gt;
                &lt;input type="email"&gt;
                &lt;input type="submit"&gt;
            &lt;/form&gt;
        </pre>
        <form action="formHandler.php" name="simple form5" autocomplete="on">
            <input aria-label="email input" type="email">
            <input type="submit">
        </form>
        <hr>
        <p>Элемент "url" предназначен для создания поля ввода адреса вебстраницы, так же валидирует введенное
            значение:</p>
        <pre>
            &lt;form action="formhander.php" name="simple form6" autocomplete="on"&gt;
                &lt;input type="url"&gt;
                &lt;input type="submit"&gt;
            &lt;/form&gt;
        </pre>
        <form action="formHandler.php" name="simple form6" autocomplete="on">
            <input aria-label="url input" type="url">
            <input type="submit">
        </form>
        <hr>
        <p>Элемент "image" создает своеобразную кнопку из картинки:</p>
        <pre>
            &lt;form action="formhander.php" name="simple form7" autocomplete="on"&gt;
               &lt;input type="image" src="https://i.ytimg.com/vi/2SYCJK-vXrY/maxresdefault.jpg" width="50" height="30" alt="just gachiimage"&gt;
            &lt;/form&gt;
        </pre>
        <form action="formHandler.php" name="simple form7" autocomplete="on">
            <input type="image" src="https://i.ytimg.com/vi/2SYCJK-vXrY/maxresdefault.jpg" width="50"
                   height="30"
                   alt="just gachiimage">
        </form>
        <hr>
        <p>Элемент "tel" создает поле ввода для номера телефона, если открыть ссылку в браузере телефона, то при
            выборе поля откроется клавиатура для набора номера:</p>
        <pre>&lt;imput type="tel"&gt;</pre>
        <input aria-label="tel input" type="tel">
        <hr>
        <p>Элемент "search" создает поле для введения поисковых запросов:</p>
        <pre>&lt;input type="search"&gt;</pre>
        <input aria-label="search input" type="search">
        <hr>
        <p>Элемент "datetime-local" похож на "date", но использует формат времени пользователя и дополнительно имеет
            время*:</p>
        <pre>&lt;input type="datetime-local"&gt;</pre>
        <input aria-label="datetime-local input" type="datetime-local">
        <hr>
        <p>Элемент "month" относится к предыдущим и позволяет выбрать только месяц´*:</p>
        <pre>&lt;input type="month"&gt;</pre>
        <input aria-label="month input" type="month">
        <hr>
        <p>Элемент "time" предназначен для введения только времени*:</p>
        <pre>&lt;input type="time"&gt;</pre>
        <input aria-label="time input" type="time">
        <hr>
        <p>Элемент "week" выводит только неделю*:</p>
        <pre>&lt;input type="week"&gt;</pre>
        <input aria-label="week input" type="week">
        <hr>
        <p>*ВАЖНО!!! элементы дат поддерживаются не всеми браузерами!</p>
        <p>Элемент "hidden" c атрибутом "value"- данный элемент скрывает дополнительное значение "value",
            используется для корректной работы скриптов или трекинга информации:</p>
        <p>&lt;input type="hidden" value="webDew"&gt;(внизу под скриптом между двумя < hr> невидимый результат)</p>
        <hr>
        <input type="hidden" value="webDew">
        <hr>
        <p>Элемент "file"- предназначен для хранения и передачи пользовательских файлов на сервер. Имеет атрибут
            "multiple"(позволяет загружать несколько файлов):</p>
        <pre>&lt;input type="file" multiple&gt;</pre>
        <input type="file" multiple>
        <hr>
        <p>Элемент "checkbox" и "radio" предназначены для выбора каких-то дополнительных опций, "checkbox" позволяет
            выбрать несколько опций, а "radio" только одну, атрибут checked позволяет выбрать опцию по
            умолчанию:</p>
        <pre>
            &lt;label&gt;&lt;input type="checkbox" value="обозначениe checkbox(z.B. option1)" checked(опция поумолчанию)&gt;Имя опции&lt;label&gt;
        </pre>
        <pre>
            &lt;label&gt;&lt;input type="radio" name="value" value="z.B. option1" checked(опция по умолчанию, у radio толькоодин раз)&gt;Имя опции&lt;/label&gt;
        </pre>
        <label><input type="checkbox" value="option1" checked>Front-end</label>
        <br>
        <label><input type="checkbox" value="option2">Back-end</label>
        <br>
        <label><input type="checkbox" value="option3">Full-stack</label>
        <br>
        <label><input type="radio" name="value" value="option1" checked>Front-end</label>
        <br>
        <label><input type="radio" name="value" value="option2">Back-end</label>
        <br>
        <label><input type="radio" name="value" value="option3">Full-stack</label>
        <hr>
    </section>

    <h3 id="vaf">Видео и аудио файлы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/t4y7atN_RJY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Теги "audio src=" и "video src=" добавляют аудио и видео файлы на страницу. Есть два способа
            подключения:</p>

        <pre>
            &lt;audio controls src="аудиофайл.формат"&gt;Отображаемый текст в случае невозможности воспроизведения&lt;/audio&gt;
        </pre>
        <audio controls src="example.mp3">Your browser does not support the audio tag.</audio>
        <pre>
            &lt;audio controls&gt;
               &lt;source src="аудиофайл.формат" type="audio/формат"&gt;
            &lt;/audio&gt;:
        </pre>
        <audio controls>
            <source src="example.mp3" type="audio/mp3">
        </audio>

        <pre>
            &lt;video controls width="560" height="315" src="видеофайл.формат"&gt;Отображаемый текст в случае невозможности воспроизведения&lt;/video&gt;
        </pre>
        <video controls width="560" height="315" src="example.mp4"></video>
        <pre>
            &lt;video poster="preview.png" preload="auto" muted controls width="560" height="315"&gt;
                &lt;source src="видеофайл.формат" type="video/ogg(f.e.)"&gt;
                &lt;source src="видеофайл.формат" type="video/mp4(f.e.)"&gt;
                "Отображаемый текст в случае невозможности воспроизведения"
            &lt;/video&gt;:
        </pre>
        <video poster="images/preview.png" preload="auto" muted controls width="560" height="315">
            <!-- <source src="example.ogg" type="video/ogg"> -->
            <source src="example.mp4" type="video/mp4">
            "Your browser does not support the audio tag."
        </video>
        <p>Набор поддерживаемых тегов практически одинаковый:</p>
        <ol>
            <li>width/height- размер окна видео.</li>
            <li>controls- добавляет элементы контроля для медийных файлов.</li>
            <li>loop- запускает бесконечное воспроизведение аудио/видео файлов.</li>
            <li>autoplay- автоматическое воспроизведение аудио/видео файла.(использовать осторожно!)</li>
            <li>muted- позволяет убрать звук у файла по умолчанию при загрузке страницы</li>
            <li>poster="адрес картинки" - добавляет постер к видео пока оно грузится или не доступно.</li>
            <li>preload="auto/metadata/none"- auto-Загрузить видео целиком при загрузке страницы; metadata-Загрузить
                только служебную информацию (размеры видео, первый кадр, продолжительность и др.); none-Не загружать
                видео.
            </li>
        </ol>
    </section>

    <h3 id="comusfattrib">Общие и полезные атрибуты.</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/EfiZ4RUOm_o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section>
        <p>Атрибут "id=" используется для подключения навигации и JS.</p>
        <p>Атрибут "class=" используется для связывания тега с определенными стилями. Классов может быть несколько:</p>
        <pre>
            &lt;p class="text idea"&gt;текст&lt;/p&gt;
        </pre>
        <p>Атрибут
            <ins title="добавляет всплывающую подсказку для текста если на него навести курсор.">"title="</ins>
            добавляет всплывающую подсказку для текста если на него навести курсор.
        </p>
        <p>Атрибут "style" - с помощью этого атрибута можно добавить стили. Лучше использовать CSS ибо приоритет
            отдается "style" и в CSS нужно будет городить колхоз в виде атрибута important.</p>
        <p>Атрибут "contenteditable=" добавляет возможность пользователю изменить текст под этим атрибутом, сам по
            себе текст в HTML не изменяется, изменение видит только пользователь:<span contenteditable="true">Этот текст можно изменить</span>
        </p>
        <p>Атрибут "spellcheck=true" включает проверку правописания. Применяется к тегам "imput", "textarea", а так
            же к тегам у которых есть атрибут "contenteditable". В браузере должна быть включена проверка
            правописания:<span contenteditable="true" spellcheck="true">Этат текст можна изминить.</span></p>
        <p>Атрибут "tabindex" позволяет передвигать курсор по странице при помощи tab по заданным меткам.
            Используется для улучшения аксесебилити.</p>
        <p>Атрибуты "dir" и "lang" используются при работе с нюансами разных языков. "dir" задает направление
            тексту, "lang" позволяет задать код языка, в резуьтате чего включаются грамматические особенности
            выбранного языка.</p>
    </section>

    <h2>Основы CSS</h2>

    <h3 id="basesintCSSappl">Базовый синтаксис и применение стилей</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/qxAnaoPI8cE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Пример задания стиля однострочным вариантом:</p>
        <pre>
            &lt;style&gt;
               h1(f.e.) { color: red; }
            &lt;/style&gt;
        </pre>
        <p>либо многострочным вариантом:</p>
        <pre>
            &lt;style&gt;
               h1(f.e.) {
                  color: red;
               }
            &lt;/style&gt;
        </pre>
        <p>Где "h1" является селектором, к которому мы обращаемся и стилизируем, а "color: red;"- блок объявлений из
            набора правил/declaration, правил может быть неограниченное количество. "color"- объявление
            своства/property(то что планируем менять), "red"- значение/value на которое будет изменено свойство.</p>
        <p>Варианты подключения стилей</p>
        <ol>
            <li>Внутренние стили. Тэг "style" указывается внутри тэга "head" непосредственно в HTML документе.<a
                    class="tooltip" href="#"> Пример:<span><img src="./images/example1.png"
                                                                alt="example1"/></span></a></li>
            <li>Инлайновые стили применяются непосредственно к определенному элементу. Не рекомендуется к использованию!
                Пример с результатом:
                <ul>
                    <li>&lt;bb style="color:blue"&gt;Hello World!&lt;/bb&gt;</li>
                    <li>
                        <p style="color:blue">Hello World!</p>
                    </li>
                </ul>
            <li>При подключение внешних стилей создается отдельный файл с расширением .css в котором описывается весь
                CSS код. Пример подключения:
                <ul>
                    <li>&lt;link rel="stylesheet" href="styles.css"&gt;</li>
                </ul>
            <li>Импорт стилей из уже существующих файлов CSS. Импорт встраивается в текущий файл CSS.<a class="tooltip"
                                                                                                        href="#">
                Пример:<span><img src="./images/example2.png" alt="example2"/></span></a></li>
        </ol>
    </section>

    <h3 id="simpsel">Простые селекторы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/vnmfn31G988" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Селектор это синтаксис который помогает выбрать элемент в HTML разметке и добавить на него необходимые стили.
            Селектора делятся на простые и составные.</p>
        <p>Простые селектора:</p>
        <p>Селектор "*" именуемый универсальным селектором. Применяет стили ко всем элементам на странице.</p>
        <p>Селектор по имени тега. Применяет стили к выбранному тэгу.</p>
        <p>Для более точного описания стилизируемого элемента применяются классы (class=""). Пример:</p>
        <pre>
            &lt;h2 class="heading1"&gt;Заголовок&lt;/h2&gt;
               .heading1 {
                  text-decoration: underline;
               }
        </pre>
        <h2 class="heading1">Заголовок</h2>
        <p>Так же можно добавить стилизацию по "id" атрибуту. Пример:</p>
        <pre>
            &lt;p id="cond"&gt;Условный текст&lt;/p&gt;
               #cond {
                  front-size: 25px
                  border: 2px solid black;
               }
        </pre>
        <p id="cond">Условный текст</p>
        <p>Чтобы стилистика класса применялась к нужному тегу, нужно указать этот тег перед классом в CSS:</p>
        <pre>
            искомый тег.заданный класс {
               заданный стиль
            }
        </pre>
        <p>Какой именно стиль будет применен в случае если к одному элементу их несколько, зависит от веса примененных
            стилей. У инлайнового стиля вес 1000, у стиля заданного id атрибутом вес 100, у стиля заданного классом
            атрибутом и псевдоатрибутом вес 10 и у стиля заданного тэгом(элементом) и псевдоэлементом вес 1.</p>
        <pre>
            body q.simple {
               color: aqua
            }
        </pre>
        <p>Вес селектора выше равен 12, по одному на два тега(body и q), и десять на класс(simple). Данная конструкция
            называется составным селектором.</p>
    </section>

    <h3 id="compsel">Составные селекторы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/fyI_K_Oya74" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
        -->
    <section>
        <p>Составной селектор это комбинация селекторов, образующие новый более конкретный селектор.</p>
        <ol>
            <li>Групповые селектора:
                <pre>
                    h1,
                    h2,
                    span {
                       color: red;
                    }
                </pre>
                <h1 class="example1">Hello world!(h1)</h1>
                <h2 class="example1">Heading 1!(h2)</h2>
                <span class="example1">Simple span element(span)</span>
            </li>
            <li>Селектор вложенности:
                <pre>
                div p {
                  color: green;
                }
                div p span {
                  color: blue;
                }

                &lt;div&gt;
                   &lt;p&gt;Super &lt;span&gt;Paragraph&lt;/span&gt; 1&lt;/p&gt;
                &lt;/div&gt;
            </pre>
                <p class="example2">Super<span class="example3"> Paragraph</span> 1</p>
                <p>Где "span" является дочерним элементом для "p", а "p"- для "div", "div" является родительским
                    элементом для обоих.</p>
            </li>
            <li>Элемент прямого потомка:
                <pre>
                    <, >
                    ul li > example4 {
                       font-weight: bold;
                    }
                    &lt;ul&gt;
                       &lt;li&gt;&lt;p&gt;&lt;span class="example4"&gt;Span 1&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;
                       &lt;li&gt;&lt;span class="example4"&gt;Span 2&lt;/span&gt;&lt;/li&gt;
                    &lt;/ul&gt;
            </pre>
                <hr>
                <ul>
                    <li><p><span class="example4">Span 1</span></p></li>
                    <li><span class="example4">Span 2</span></li>
                </ul>
                <hr>
            </li>
            <li>Элемент соседнего селектора:
                <pre>
                    ul .example5 + .example5 {
                       color: aqua;
                    }
                    &lt;ul&gt;
                       &lt;li class="example5"&gt;Li 1&lt;/li&gt;
                       &lt;li class="example5"&gt;Li 2&lt;/li&gt;
                       &lt;li class="example5"&gt;Li 3&lt;/li&gt;
                       &lt;li class="example5"&gt;Li 4&lt;/li&gt;
                    &lt;/ul&gt;
            </pre>
                <hr>
                <ul>
                    <li class="example5">Li 1</li>
                    <li class="example5">Li 2</li>
                    <li class="example5">Li 3</li>
                    <li class="example5">Li 4</li>
                </ul>
                <hr>
            </li>
            <li>Селектор "следующий элемент":
                <pre>
                    br ~ .example6 {
                    font-size: 20px;
                    }

                    &lt;p class="example6"&gt;Paragraph 1&lt;/p&gt;
                    &lt;p class="example6"&gt;Paragraph 2&lt;/p&gt;
                    &lt;br /&gt;
                    &lt;p class="example6"&gt;Paragraph 3&lt;/p&gt;
                    &lt;p class="example6"&gt;Paragraph 4&lt;/p&gt;
            </pre>
                <hr>
                <p class="example6">Paragraph 1</p>
                <p class="example6">Paragraph 2</p>
                <br/>
                <p class="example6">Paragraph 3</p>
                <p class="example6">Paragraph 4</p>
            </li>
            <li>Селектор атрибута:
                <pre>
                    a[target] {
                       backgroung-color: yellow;
                    }
                    a[target="_blank"] {
                       backgroung-color: blue;
                    }

                    Проверка начала ссылки на соответствие:

                    a[href^="https://123"] {
                       backgroung-color: aqua;
                    }

                    Проверка конца ссылки на соответствие:

                    a[href$=".jpg"] {
                       backgroung-color: teal;
                    }

                    Проверка на наличие указанных символов:

                    a[href*="link1"] {
                       backgroung-color: rebeccapurple;
                    }

                    &lt;a href="http://test1.com">Test Link 1&lt;/a&gt;
                    &lt;a href="http://test2.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
                    &lt;a href="http://test3.org" target="_top"&gt;Test Link 3&lt;/a&gt;

                    &lt;a href="http://test1.com"&gt;Test Link 1&lt;/a&gt;
                    &lt;a href="http://test2.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
                    &lt;a href="http://test3.org" target="_top"&gt;Test Link 3&lt;/a&gt;

                    &lt;a href="http://123.com"&gt;Test Link 1&lt;/a&gt;
                    &lt;a href="http://4link56.com" target="_blank"&gt;Test Link 2&lt;/a&gt;
                    &lt;a href="http://678.jpg" target="_top"&gt;Test Link 3&lt;/a&gt;

                    <a href="http://test1.com">Test Link 1</a>
                    <a href="http://test2.com" target="_blank">Test Link 2</a>
                    <a href="http://test3.com" target="_top">Test Link 3</a>

                    <a href="http://test1.com">Test Link 1</a>
                    <a href="http://test2.com" target="_blank">Test Link 2</a>
                    <a href="http://test3.com" target="_top">Test Link 3</a>

                    <a href="http://123.com">Test Link 1</a>
                    <a href="http://4link156.com" target="_blank" class="hrefWithLink">Test Link 2</a>
                    <a href="http://678.jpg" target="_top">Test Link 3</a>
                </pre>
            </li>
        </ol>
    </section>

    <h3 id="pseeleclass">Псевдоэлементы и псевдоклассы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/C40ePbYJxmM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Псевдоклассы.</p>
        <p class="example7">Чтобы цвет текста менялся по наведению мыши используют псевдокласс "hover":</p>
        <pre>
            .example7:hover {
               color: red;
            }
        </pre>
        <a class="example7" href="https://www.youtube.com/YauhenKavalchuk">webDev YouTube Chanel</a>
        <p>Чтобы цвет ссылки менялся после посещения сайта используют псевдокласс "visited":</p>
        <pre>
            .example8:visited {
               color: aqua;
            }
        </pre>
        <a class="example8" href="https://www.youtube.com/YauhenKavalchuk">webDev YouTube Chanel</a>
        <p>Чтобы цвет ссылки/кнопки менялся при клике мыши используют псевдокласс "active":</p>
        <pre>
        .example9:active {
            color: qreen;
        }
    </pre>
        <a class="example9" href="https://www.youtube.com/YauhenKavalchuk">webDev YouTube Chanel</a>
        <hr>
        <p>Псевдоэлементы.</p>
        <p>Чтобы при передвижении по странице при помощи таба выделенный текст менялся- используют псевдоэлемент
            "focus":</p>
        <pre>
            .example10:focus {
               font-weight: bold;
            }
        </pre>
        <a class="example10" href="https://www.youtube.com/YauhenKavalchuk">webDev YouTube Chanel</a>
        <p>При стилизации фрагмента текста используются два псевдоэлемента- "first-letter" и "first-line":</p>
        <pre>
            .example11::first-letter {
               font-size: 30px;
            }
            .example11::first-line {
               text-decoration: underline;
            }
        </pre>
        <p class="example11">Wer fremde Sprachen nicht kennt, weiß nichts von seiner eigenen.</p>
        <p>Чтобы стилизировать выделение текста используют селектор "selection"(!размер текста увеличить
            нельзя!):</p>
        <pre>
            .example12::selection {
               background-color: yellow;
               color: red;
            }
        </pre>
        <p class="example12">Wer fremde Sprachen nicht kennt, weiß nichts von seiner eigenen.</p>
        <p>Для добавления дополнительного текста и раздельной его стилизации используют псевдоэлементы "before" и
            "after":
        <pre>
           .example13::before {
              content: "This is "
              text-transform: uppercase;
           }
           .example13::after {
              content: " lesson"
              color: red;
           }
           &lt;p clas="example13"&gt;CSS&lt;/p&gt;
        </pre>
        <p class="example13">CSS</p>
        <hr>
        <p>Селектора для работы со списками "first-child", "last-child", и дополнительными значениями в скобках
            "even",
            "odd", и номер элемента:</p>
        <pre>
            .list1 li:first-child {
               color: blue;
            }
            .list1 li:last-child {
               color: green;
            }

            &lt;ul class="list1"&gt;
               &lt;li&gt;One&lt;/li&gt;
               &lt;li&gt;Two&lt;/li&gt;
               &lt;li&gt;Three&lt;/li&gt;
               &lt;li&gt;Four&lt;/li&gt;
               &lt;li&gt;Five&lt;/li&gt;
               &lt;li&gt;Six&lt;/li&gt;
            &lt;/ul&gt;
    </pre>
        <ul class="list1">
            <li>One</li>
            <li>Two</li>
            <li>Three</li>
            <li>Four</li>
            <li>Five</li>
            <li>Six</li>
        </ul>
        <pre>
            .list2 li:nth-child(even) {
               color: blue;
            }
            .list2 li:nth-child(odd) {
               color: green;
            }
            .list2 li:nth-child(3) {
               color: red !important;
            }

            &lt;ul class="list2"&gt;
               &lt;li&gt;One&lt;/li&gt;
               &lt;li&gt;Two&lt;/li&gt;
               &lt;li&gt;Three&lt;/li&gt;
               &lt;li&gt;Four&lt;/li&gt;
               &lt;li&gt;Five&lt;/li&gt;
               &lt;li&gt;Six&lt;/li&gt;
            &lt;/ul&gt;
        </pre>
        <ul class="list2">
            <li>One</li>
            <li>Two</li>
            <li>Three</li>
            <li>Four</li>
            <li>Five</li>
            <li>Six</li>
        </ul>
        <pre>
            .list3 li:nth-child(3n+1) {
               text-transform: uppercase;
            }
            .list3 li:nth-child(2n+1) {
               color: aqua;
            }

            &lt;ul class="list3"&gt;
               &lt;li&gt;One&lt;/li&gt;
               &lt;li&gt;Two&lt;/li&gt;
               &lt;li&gt;Three&lt;/li&gt;
               &lt;li&gt;Four&lt;/li&gt;
               &lt;li&gt;Five&lt;/li&gt;
               &lt;li&gt;Six&lt;/li&gt;
            &lt;/ul&gt;
        </pre>
        <ul class="list3">
            <li>One</li>
            <li>Two</li>
            <li>Three</li>
            <li>Four</li>
            <li>Five</li>
            <li>Six</li>
        </ul>
        <br>
        <p>"first-of-type", "last-of-type" и "nth-of-type()":</p>
        <pre>
            .text1 p:first-of-type {
               color: red;
            }
            .text1 p:nth-of-type(2) {
               text-transform: uppercase;
            }
            .text1 p:last-of-type {
               color: aqua;
            }

            &lt;div class="text1"&gt;
               &lt;p&gt;First paragraph&lt;/p&gt;
               &lt;span&gt;First span text.&lt;/span&gt;
               &lt;span&gt;Second span text&lt;/span&gt;
               &lt;p&gt;Second paragraph&lt;/p&gt;
               &lt;p&gt;Third paragrapf&lt;/p&gt;
            &lt;/div&gt;
    </pre>
        <div class="text1">
            <p>First paragraph</p>
            <span>First span text.</span>
            <span>Second span text</span>
            <p>Second paragraph</p>
            <p>Third paragrapf</p>
        </div>
        <p>Псевдоклассическое отрицание "not()"</p>
        <pre>
            .list4 li:not(.item) {
               text-transofm: uppercase;
               color: red;
            }

            &lt;ul class="list4"&gt;
               &lt;li class="item"&gt;One&lt;/li&gt;
               &lt;li class="item"&gt;Two&lt;/li&gt;
               &lt;li&gt;Three&lt;/li&gt;
               &lt;li&gt;Four&lt;/li&gt;
               &lt;li class="item"&gt;Five&lt;/li&gt;
               &lt;li&gt;Six&lt;/li&gt;
            &lt;/ul&gt;
        </pre>
        <ul class="list4">
            <li class="item">One</li>
            <li class="item">Two</li>
            <li>Three</li>
            <li>Four</li>
            <li class="item">Five</li>
            <li>Six</li>
        </ul>
    </section>


    <h3 id="cascinher">Каскадность и наследование</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Y8UFzOoKkvQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Каскадность- это ряд правил которое определяет какие именно свойства должны быть добавлены на элемент
            если в
            нем определено несколько конфликтующих свойств.</p>
        <p>Факторы приоритета стилей:</p>
        <ol>
            <li>Важность. Если помечено !important, то безоговорочно применяется данный стиль.</li>
            <li>Специфичность. Применяется тот стиль, специфичность которого больше.</li>
            <li>Порядок в документе. Если селектора имеют одинаковый вес то применяется свойство которое ниже.</li>
        </ol>
        <pre>
            tt p { (специфичность 2)
               background-color: green;
               color: white;
               padding: 10px;
            }
            .styleq { (специфичность 10)
               background-color: aqua;
               color: black;
               border: none !important;
            }
               #stylew { (специфичность 100)
               background-color: pink;
               border: 2px solid black;
            }
            tt p{
               background-color: gray;
            }
        </pre>
        <tt>
            <p>Просто tt параграф</p>
            <p class="styleq">класс styleq описывает этот tt параграф.</p>
            <p class="styleq">а айди stylew этот tt параграф.</p>
            <p id="stylew">и этот.</p>
            <p>DEPRECATED</p>
        </tt>
        <p>Как видно стили применяются строго по специфичности, исключение составляет значение "border: none;" так
            как
            он помечен !important.</p>
        <p>Наследование в CSS это способность элементов потомков перенимать правило форматирования которое присвоено
            их
            предкам.</p>
        <pre>
            .example14 {
                color: red;
                margin-bottom: 10px;
                border: 1px solid black;
            }
            big p {
                border: inherit;
                margin: inherit;
            }
        </pre>

        <big class="example14">
            <p>First paragraph</p>
            <p>Second paragraph</p>
            <p>Third paragraph</p>
            <p>Fours paragraph</p>
            <p>DEPRECATED</p>
        </big>
        <p>В данном случае все параграфы наследовали все значения родительского класса "example14" включая
            нетекстовое
            оформление. Без "inherit" от родителя наследуется только стиль текста!</p>
        <p>У каждого браузера свои дефолтные стили ссылок, отступов и тд, чтобы прийти к одному стилю в любом
            браузере
            используют сброс или нормализацию стилей. Нормализуют или сбрасывают стиль при помощи подключения
            отдельного
            CSS документа со стилями или при помощи копии кода в текущий CSS документ. Важно чтобы подключение или
            копия
            нормализующего стиля были первее задаваемых вебразрабом.</p>
    </section>

    <h3 id="boxmodpadmar">Блочная модель и отступы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/1jvIi039-i4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <pre>
            .example15 {
               display: inline;
            }
        </pre>
        <p>"padding" это промежуток между контентом и его границами.</p>
        <p>"margin" это пустое пространство которое отделяет один тег от другого и находится за пределами их
            границ</p>
        <div class="example15"> Div элемент example15 со значением "display: inline;"</div>
        <br>
        <pre>
            .example16, .example17 {
               border: 5px solid red;
               margin: 10px 20px 30px 40px;
               padding: 10px 20px 30px 40px;
            }
        </pre>
        <div class="example16">Div элемент example16</div>
        <br>
        <span class="example17">Span элемент example17</span>
        <br><br> <!-- дада бэдпрактис. пошел на###. -->
        <p>Для строчных элементов не работает свойство "margin-top"и"margin-bottom"</p>
        <p>Схлопывание отступов - если два элемента с разными "margin" стоят рядом, то промежуток между ними будет
            равен
            большему "margin", без суммирования и т.д.:</p>
        <pre>
            .example18 {
               border: 1px solid red;
               margin: 30px 0;
            }
            .example19 {
               border: 1px solid red;
               margin-top: 50px;
            }
    </pre>
        <div class="example18">div элемент example18</div>
        <div class="example19">div элемент example19</div>
        <br>
        <p>Для строчного элемента нельзя задать размеры:</p>
        <pre>
            .example20 {
               margin-top: 100px 0;
               width: 100px;
               height: 100px;
            }
        </pre>
        <span class="example20">span элемент example20</span>
        <br>
        <p>А для блочного можно("display: inline-block;" смесь блока и строки и к нему применяется все ствойства
            обоих
            типов при этом размер коробки будет не 100на100 а больше тк в него будет включен "padding" и
            "border"):</p>
        <pre>
            .example21 {
               border: 5px solid red;
               margin: 50px;
               padding: 50px;
               width: 100px;
               height: 100px;
            }
        </pre>
        <div class="example21">div элемент example21</div>
        <p>Чтобы размеры не приходилось считать самому есть свойство "box-sizing: border-box", в данном случае
            размер
            коробки будет ровно 100на100:</p>
        <pre>
            .example22 {
                border: 5px solid red;
                margin: 20px;
                padding: 10px;
                width: 100px;
                height: 100px;
                box-sizing: border-box;
            }
        </pre>
        <div class="example22">div элемент example22</div>
    </section>

    <h3 id="possiz">Позиционирование и размеры</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/iydD985acAc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Позиционирование элемента объявляется с помощью "position" который имеет 5 значений: "static"(дефолтное
            состояние элементов, применять не нужно); "relative"; "absolute"; "fixed" и "sticky":</p>
        <p>"position: relative;"- В данном случае элемент отделяется от основного потока и формирует новый, и его
            положением можно управлять с помощью "top/bottom/left/right", на пустом месте, где ранее располагался
            элемент остается "shadow-element":</p>
        <pre>
            .example23 {
                border: 5px solid red;
                margin: 20px;
                padding: 10px;
                width: 100px;
                height: 100px;
                box-sizing: border-box;
                position: relative;
                top: 20px;
                left: 150px;
            }
    </pre>
        <h4> Просто текст Просто текст Просто текст Просто текст
            <div class="example23">div элемент example23</div>
            Просто текст Просто текст Просто текст Просто текст
        </h4>
        <br>
        <p>"position: absolute;"- В данном случае основной поток теряет связь с элементом и его место заполняется,
            его
            положением так же можно управлять с помощью "top/bottom/left/right". В случае если родительский элемент
            имеет дефолтное позиционирование, то элемент с "absolute" будет позиционироваться относительно окна
            браузера, если же у родительского элемента задано иное позиционирование, то тогда элемент с "absolute"
            будет
            позиционироваться относительно родительского элемента, связка "position: relative;" и "position:
            absolute;"
            используется часто:</p>
        <pre>
            .example24 {
                border: 5px solid red;
                margin: 20px;
                padding: 10px;
                width: 100px;
                height: 100px;
                box-sizing: border-box;
                position: absolute;
                top: 30px;
                left: 250px;
            }
    </pre>
        <h4 class="example25"> Просто текст Просто текст Просто текст Просто текст
            <div class="example24">div элемент example24</div>
            Просто текст Просто текст Просто текст Просто текст
        </h4>
        <br><br><br><br><br><br><br>
        <p>"position: fixed;" аналог "position: absolute;" с тем различием, что позиционирование будет ВСЕГДА
            отсчитываться от края окна браузера!!! Изменить ничего нельзя какие бы типы позиционирования ни были у
            родительского элемента!</p>
        <pre>
            .example26 {
                border: 5px solid red;
                margin: 20px;
                padding: 10px;
                width: 100px;
                height: 100px;
                box-sizing: border-box;
                position: fixed;
                top: 50px;
                right: 150px;
            }
    </pre>
        <div class="example26">div элемент example26</div>
        <button id="buttonexample" type="button">Показать пример</button>
        <br>
        <p>"position: sticky;" прикрепляется к родительскому элементу и передвигается вдоль всего его периметра пока
            скролится экран:</p>
        <pre>
    .example28 {
        border: 5px solid red;
        display: inline-block;
        width: 100px;
        height: 100px;
        box-sizing: border-box;
        position: sticky;
    }
        </pre>
        <h4 class="example29">
            <div class="example28">div элемент example28</div>
            Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
            Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
            Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
            Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
            Просто текстv Просто текст Просто текст Просто текст Просто текст Просто текст Просто текст
        </h4>
        <br>
        <p>Практически для каждого элемента можно задать размер, размер может быть как фиксированным
            "width/height"так и
            диапазонными "min-width/height" и "max-width/height";</p>
    </section>

    <h3 id="unitsoverflowzindex">Единицы, переполнение и уровни элементов</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/pEdt0afL2-o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <table class="bor1">
            <caption class="bor1">Размеры элементов</caption>
            <thead>
            <tr>
                <th>Абсолютные</th>
                <th>Относительные</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Pixels(px)</td>
                <td>Percentages(%)</td>
            </tr>
            <tr>
                <td>Centimeters(cm)</td>
                <td>Font-sizes(em&rem)</td>
            </tr>
            <tr>
                <td>Millimeters(mm)</td>
                <td>Character-sizes(ex&ch)</td>
            </tr>
            <tr>
                <td>Inches(in)</td>
                <td>Vievport Dimensions(vw&vh)</td>
            </tr>
            <tr>
                <td>Points(pt)</td>
                <td>Vievport Max(vmax)</td>
            </tr>
            <tr>
                <td>Picas(pc)</td>
                <td>Vievport Min(vmin)</td>
            </tr>
            </tbody>
        </table>
        <p>При задании относительной величины для элементов списка (li) в процентах (или любого другого элемента у
            которого есть дочерние элементы), то будет пошаговое снижение на заданную величину у каждого
            последующего
            уровня/элемента. Если у любого родителя объявлен размер шрифта, то процент отталкивается от него, если
            нет -
            берется дефолтное браузерное значение:</p>
        <pre>
                .example30 {
                    font-size: 24px;
                }
                .example30 li {
                    font-size: 80%;
                }
            </pre>

        <ul class="example30">
            <li>First element
                <ul>
                    <li>Second element
                        <ul>
                            <li>Third element
                                <ul>
                                    <li>Fourth element
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <br>
        <p>Значение "em" увеличивает шрифт каждого последующего дочернего элемента в 2 раза:</p>
        <pre>
            .example31 {
                font-size: 2px;
            }
            .example30 li {
                font-size: 2em;
            }
        </pre>
        <ul class="example31">
            <li>First element
                <ul>
                    <li>Second element
                        <ul>
                            <li>Third element
                                <ul>
                                    <li>Fourth element
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <br>
        <p>Значение "rem" задает размер ОДИНАКОВЫЙ для всех элементов и расчет размера идет от БАЗОВОГО шрифта
            HTML!:</p>
        <ul class="example32">
            <li>First element
                <ul>
                    <li>Second element
                        <ul>
                            <li>Third element
                                <ul>
                                    <li>Fourth element
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <br>
        <p>Что абсолютные, что относительные величины можно применять как к тексту, так и к отступам и для
            определения
            положения элемента, НО для последних принято использовать только абсолютные величины!(px)</p>
        <p>"vw/vh" используется для создания оверлея под модальные окна:</p>
        <div class="overlay1">
            <div class="modal1">Модальное окно
                <button id="closebutton1" type="button">x</button>
            </div>
        </div>
        <pre>
            .modal1 {
                position: absolute;
                margin: 0;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background-color: blue;
                color: white;
                border: 1px solid black;
                width: 300px;
                height: 100px;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .overlay1 {
                background-color: rgba(0,0,0,0.5);
                color: white;
                width: 100vw;
                height: 100vh;
                box-sizing: border-box;
                position: fixed;
                top: 0;
                left: 0;
                visibility: hidden;
            }
            </pre>
        <button id="buttonexample1" type="button">Показать пример модального окна</button>
        <br>
        <p>Для того чтобы управлять уровнями элементов есть специальное свойство "z-index", присваивая ему значения
            вплоть до 9999 мы задаем уровня которые будут позиционироваться друг относительно друга при отображении
            на
            странице</p>
        <p>Если контент выходит за пределы блока в котором он расположен, то происходит переполнение элемента, дабы
            исправить эту ситуацию используют либо min/max и height/width либо "overflow-x/y" "overflow:
            auto/scroll/hidden;":</p>
        <blockquote class="example33">
                <pre>
                    Do not go gentle into that good night,
                    Old age should burn and rave at close of day;
                    Rage, rage against the dying of the light.

                    Though wise men at their end know dark is right,
                    Because their words had forked no lightning they
                    Do not go gentle into that good night.

                    Good men, the last wave by, crying how bright
                    Their frail deeds might have danced in a green bay,
                    Rage, rage against the dying of the light.

                    Wild men who caught and sang the sun in flight,
                    And learn, too late, they grieved it on its way,
                    Do not go gentle into that good night.

                    Grave men, near death, who see with blinding sight
                    Blind eyes could blaze like meteors and be gay,
                    Rage, rage against the dying of the light.

                    And you, my father, there on that sad height,
                    Curse, bless, me now with your fierce tears, I pray.
                    Do not go gentle into that good night.
                    Rage, rage against the dying of the light.
                </pre>
            <address>D. Thomas</address>
        </blockquote>
    </section>


    <h3 id="floatelemclear">Плавающие элементы и очистка потока</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/1kZ9FTp2IiE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
-->
    <section class="sec8">
        <p>Чтобы добавить обтекание текста слева или справа используют "float: left/right":</p>
        <pre>
                .example34 {
                     float: right;
                }
            </pre>
        <img class="picdth"
             src="https://upload.wikimedia.org/wikipedia/commons/7/79/Portrait_of_Revd._Thomas_Thomas%2C_D.D_%284672349%29.jpg"
             width="400" alt="D. Thomas">
        <blockquote class="example34">
            Do not go gentle into that good night,
            Old age should burn and rave at close of day;
            Rage, rage against the dying of the light.

            Though wise men at their end know dark is right,
            Because their words had forked no lightning they
            Do not go gentle into that good night.

            Good men, the last wave by, crying how bright
            Their frail deeds might have danced in a green bay,
            Rage, rage against the dying of the light.

            Wild men who caught and sang the sun in flight,
            And learn, too late, they grieved it on its way,
            Do not go gentle into that good night.

            Grave men, near death, who see with blinding sight
            Blind eyes could blaze like meteors and be gay,
            Rage, rage against the dying of the light.

            And you, my father, there on that sad height,
            Curse, bless, me now with your fierce tears, I pray.
            Do not go gentle into that good night.
            Rage, rage against the dying of the light.
            <address>D. Thomas</address>
        </blockquote>
        <p>"float" вырывает элемент из нормального потока документа, т.е. остальные элементы перестают его видеть,
            так же теряется наследственная связь:</p>
        <div class="iteme wrapper">
            <div class="iteme iteml">1</div>
            <div class="iteme itemr">2</div>
            <div class="iteme itemn">3</div>
        </div>
        <p>Для предотвращения схлопывания родительского элемента используется "overflow: auto;", добавление пустого
            элемента со свойством "clear: both;" или Clearfix- создание псевдоэлемента .class:after { content: '';
            display: block; clear: both; }</p>
        <p>Если задать свойство "float" строчному элементу, то он начинает вести себя как блочный!</p>
        <hr>
    </section>

    <h3 id="fnttxtstl">Шрифты и текст</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/TAB8pVUKiI4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Безопасные шрифты – это набор шрифтов, устанавливаемый вместе с операционной системой. Чтобы сайт в любой
            операционной системе открывался одинаково, принято в CSS-свойстве font-family задавать несколько
            названий
            шрифтов, перечисленных через запятую.</p>
        <p>Применить нужный шрифт можно при помощи "font-family: шрифт"</p>
        <p>"font-size: ЧИСЛОpx" задает размер текста.</p>
        <p>"font-weihgt: ЧИСЛО" задает толщину шрифта.</p>
        <p>"font-style: СТИЛЬ" задает стиль текста</p>
        <p>"color: ЦВЕТ" задает цвет тексту.</p>
        <p>"text-decoration: underline/overline/line-through/none" задает различные варианты подчеркиваний
            текста.</p>
        <p>"letter-spacing: px" и "word-spacing: px" задают расстояние между символами и словами.</p>
        <p>"line-height: px" позволяет задать межстрочный интервал.</p>
        <p>"text-transform: uppercase/lowercase/capitalize/none" позволяет вывести текст в верхний/нижний регистр
            или
            вывести каждый первый символ предложения в верхний регистр.</p>
        <p>Шрифты делятся на шрифты с засечками "serif" и без засечек "sans-serif"</p>
        <p>"text-indent: px" задает красную строку.</p>
        <p>Подключить шрифты можно с сайта <a class="goglink" href="https://fonts.google.com/" target="_blank">fonts.google.com</a>
        </p>
        <p>"text-align: left/center/right/justify" позволяет выравнять текст по левому краю, по центру или по
            правому
            краю. Justify позволяет выравнять текст по левому и по правому краю растягивая текст в середине.</p>
        <p>Для того чтобы подключить шрифт локально, его нужно скачать, сохранить в папку с проектом, с помощью
            директивы "@font-face { "ШРИФТ"; src: url("путь до файла.ttf") format("truetype"); font-weight: 500;
            font-style: normal; }"</p>
    </section>

    <h3 id="bordshad">Границы и тени</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/dAHu16pgBrg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Значения "border-widht: px" "border-style: solid/.../" "border-color: ЦВЕТ" задают рамку определенного
            стиля
            определенного цвета, коротко это записывается как в следующем примере: "border: 1px solid red;", если
            нужно
            указать только одну сторону границы то используют "border-top/right/bottom/left: ...; или
            "border-сторона(right z.B.)-параметр(color z.B.): ...;"</p>
        <p>Значение "outline: ..." задает обводку элементам, имеет те же параметры, но в отличии от "border" нельзя
            задать свойства каждой отдельной стороне:</p>
        <pre>
            #outlineexample:focus {
                outline: 2px solid green;
            }
    </pre>
        <button id="outlineexample" type="button">для показа примера "outline" нужно сфокусировать табом</button>
        <p class="shadowexample">Для того чтобы выделить текст с помощью тени существует свойство "text-shadow:
            горизонт_значение_px вертикальное_значение_px степень_размытости_px цвет". Так же через запятую можно
            добавить новую тень и количество таковых ничем не ограничено:</p>
        <pre>
            .shadowexample {
                text-shadow: 4px 4px 5px crimson, -4px -4px 5px cyan;
            }
            </pre>
        <p>Для элементов же применяется "box-shadow: ...;", параметры принимает точно такие же как и в "text-shadow:
            ...;", но присутствует дополнительное значение "inset" которое создает эффект вдавленности:</p>
        <pre>
    .boxshadow {
        width: 100px;
        height: 100px;
        background-color: gray;
        margin: 20px;
        box-shadow: inset 4px 4px 5px green, 4px 4px 5px yellow;
    }
            </pre>
        <div class="boxshadow"></div>
    </section>

    <h3 id="bordradlistscol">Скругление углов, списки и цвета</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/zaJh6CymejM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Чтобы скруглить углы элементов использует "border-radius:верхний_левый_угол_px/% верхний_правый_угол_px/%
            нижний_правый_угол_px/% нижний_левый_угол_px/%;" или коротко "border-radius: ...px/%;" или
            "border-radius:
            ...px/% ...px/%;", так же можно задавать значение скругления отдельно по горизонтали и отдельно по
            вертикали: "border-radius: ...px/...px;" для определенного угла "border-top-left-radius: ...px/%":</p>
        <pre>
            .borderradiusexample {
                width: 100px;
                height: 100px;
                background-color: gray;
                margin: 20px;
                border-radius: 50% 40px 30px 20%;
            }
            </pre>
        <div class="borderradiusexample"></div>
        <pre>
            .borderradiusexample1 {
                width: 100px;
                height: 100px;
                background-color: gray;
                margin: 20px;
                border-radius: 20px/40px;
            }
            </pre>
        <div class="borderradiusexample1"></div>
        <p>Чтобы определить маркер списка используют "list-style-type: disc/circle/square/decimal...":</p>
        <pre>
            .lielem1 {
                list-style: disc;
            }
            .lielem2 {
                list-style-type: circle;
            }
            .lielem3 {
                list-style-type: square;
            }
            .lielem4 {
                list-style-type: decimal;
            }
            .lielem5 {
                list-style-type: upper-alpha;
            }
            .lielem6 {
                list-style-type: lower-alpha;
            }
            .lielem7 {
                list-style-type: upper-roman;
            }
            .lielem8 {
                list-style-type: lower-roman;
            }
            .lielem9 {
                list-style-type: decimal-leading-zero;
            }
            .lielem10 {
                list-style-type: none;
            }
            </pre>
        <ul>
            <li class="lielem1">lielem1</li>
            <li class="lielem2">lielem2</li>
            <li class="lielem3">lielem3</li>
            <li class="lielem4">lielem4</li>
            <li class="lielem5">lielem5</li>
            <li class="lielem6">lielem6</li>
            <li class="lielem7">lielem7</li>
            <li class="lielem8">lielem8</li>
            <li class="lielem9">lielem9</li>
            <li class="lielem10">lielem10</li>
        </ul>
        <p>Положение маркера относительно списка мы можем задать с помощью "list-style-position: outside(значение по
            умолчанию)/inside;"</p>
        <p>Если нужно задать в качестве маркера некую иконку, то используют "list-style-image: url(http://...);":
        <p>Если нужно тексту задать цвет, то используют "color: COLOR-NAME/#HEX/rgba(..., ..., ..., ...)/hsla(...,
            ...%,
            ...%, ...);"</p>
    </section>

    <h3 id="dispvisvendpref">Отображение элементов и вендорные префиксы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/pyBjcMRLMoQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Чтобы скрыть элемент со страницы, используют "display: none;" и "visibility: hidden;", при этом первый
            вариант полностью убирает элемент со страницы(из основного потока документа), а во втором элемент
            остается
            на месте, его может видеть поисковик, но не видит юзверь.</p>
        <p>Второй подход скрытия элемента это использование прозрачности: "opacity: 0;" или "color: transparent"</p>
        <p>Вендерные префексы это приставка к CSS свойству, которая обеспечивает его поддержку в браузерах, где это
            свойство пока не добавлено на постоянной основе:</p>
        <pre>
            .exapmleprefix {
                -webkit-opacity: 0.5;  (-webkit- Safari/Chrome)
                -moz-opacity: 0.5;     (-moz- Firefox)
                -ms-opacity: 0.5;      (-ms- IE/Edge)
                -o-opacity: 0.5;       (-o- Opera)
                opacity: 0,5;
            }
        </pre>
        <p>Проверить насколько хорошо поддерживается свойство можно на сайте<a href="https://caniuse.com/"
                                                                               target="_blank">Can I use</a></p>
        <p>При помощи плагина "Gulp" настроив его на нужный браузер префиксы можно задавать автоматически.</p>
    </section>

    <h3 id="Background">Фон</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/5k-x7FUnDuE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Чтобы задать фон цветом или изображением используют "background-color: ...;" либо "background-image:
            url(http://...);"</p>
        <p>Размерами изображений выбранных в качестве фона можно управлять с помощью "background-size: ...", оно
            принимает как точное значение в пикселях или %(так же комбинации пикселей и процентов), так и
            слова-значения
            например "contain/cover". Так же если не требуется повторения изображения используют "background-repeat:
            no-repeat;", если же наоборот нужно применить повторение, но по одной из осей, то применяют
            "background-repeat: repeat-x/y;"</p>
        <p>Чтобы управлять позицией фона используют "background-position: .../...;" в ней нужно задавать две позиции
            right/left/center, а так же top/bottom/center, либо же использовать точные значения в пикселях или
            процентах.</p>
        <p>Чтобы зафиксировать фоновое изображение в определенном месте ЭКРАНА, используют "background-attachment:
            fixed;"</p>
        <p>Чтобы не городить огород из всех этих значений их можно поместить в "background" в определенном порядке,
            а
            именно 1) "color", "background-image", "background-position", "background-repeat" и
            "background-attachment":</p>
        <pre>
            .backgroundsiteexample {
                gainsboro
                url(http://...)
                50% 50% no-repeat fixed;
            }
        </pre>
        <p>Так же в "background" можно добавлять хоть сколько разных фоновых фотографий через запятую, и их
            наложение
            друг на друга будет зависеть от порядка добавления в CSS коде.</p>
    </section>

    <h3 id="gradients">Градиенты</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/8mzap9y6ECE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Градиент- переход одного цвета в другой. Чтобы задать градиент, применяют "background-image:
            linear-gradient(...deg, цвет, цвет, .......);"(либо просто "background"), так же направление градиента
            можно
            указать с помощью значения "to top/bottom right/left":</p>
        <pre>
            .gradientexample {
                width: 500px;
                height: 500px;
                background-image: linear-gradient(45deg,red,aqua);
            }
        </pre>
        <div class="gradientexample"></div>
        <br>
        <p>Опорные точки это дополнительные значения задаваемые сразу после текста - "background-image:
            linear-gradient(...deg, цвет ...%, цвет ...%, ...%, .....)</p>
        <pre>
            .gradientexample1 {
                width: 500px;
                height: 500px;
                background-image: repeating-linear-gradient(45deg, yellow 25px,black 25px, black 50px,yellow 50px, yellow 75px, black 75px);
            }
        </pre>
        <div class="gradientexample1"></div>
        <br>
        <p>Для задания радиального градиента используют "background-image/background: radial-gradient(ellipse/circle
            closest/farthest-side/corner, цвет px/%, цвет px/%);":</p>
        <pre>
            .gradientexample2 {
                width: 500px;
                height: 300px;
                background-image: repeating-radial-gradient(ellipse, aqua 20px, red 80px);
            }
        </pre>
        <div class="gradientexample2"></div>
    </section>

    <h3 id="filters">Фильтры</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/k-qqZ7rcy-E" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Фильтр это свойство которое добавляет визуальные эффекты на изображение, добавляется с помощью "filter:
            свойство;":</p>
        <img class="imagefilter" src="https://i.ytimg.com/vi/2SYCJK-vXrY/maxresdefault.jpg" alt="пикча"><br>
        <button id="blurbutton" type="button">filter: blur(2px);</button>
        <br>
        <button id="shadowbutton" type="button">filter: drop-shadow(5px 6px 4px rgba(0, 0, 0, 0.5));</button>
        <br>
        <button id="grayscalebutton" type="button">filter: grayscale(100%);</button>
        <br>
        <button id="brightnessbutton" type="button">filter: brightness(50%);</button>
        <br>
        <button id="contrastbutton" type="button">filter: contrast(150%);</button>
        <br>
        <button id="rotatebutton" type="button">filter: hue-rotate(180deg);</button>
        <br>
        <button id="invertbutton" type="button">filter: invert(100%);</button>
        <br>
        <button id="saturatebutton" type="button">filter: saturate(300%);</button>
        <br>
        <button id="sepiabutton" type="button">filter: sepia(100%);</button>
        <br>
        <button id="opacitybutton" type="button">filter: opacity(50%);</button>
        <br>
    </section>

    <h3 id="transform">Транcформации</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/vbdw3iHzkFo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Все свойства трансформации задаются с помощью свойства "transform: ..." и имеют следующие значения:</p>

        <button class="rotate">transform: rotate(180deg);</button>
        <button class="scale">transform: scale(x, y);</button>
        <button class="translate">transform: translate(...px/%, ...px/%);</button>
        <button class="skew">transform: skew(...deg, ...deg);</button>
        <p>Дефолтная опорная точка находится по центру элемента, чтобы управлять опорной точкой, используют
            "transform-origin: right/left bottom/top" или "transform-origin: ...px ...px"</p>
        <button class="rotateorigin">transform: rotate(180deg);<br>transorm-origin: right bottom;</button>
    </section>

    <h3 Id="transition">Плавные переходы</h3>
    <!-- <iframe width="560" height="315" src="https://www.youtube.com/embed/hwWIm6DSSoE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>управлением переходов управляют "transition-duration: ...s/ms, ...s/ms;"(длительность перехода для
            выбранных
            свойств), "transition-property: all/свойства"(какое свойство будет осуществлять плавный переход),
            "transition-delay: ...s/ms, ...s/ms;" (с какой задержкой будет осуществляться переход),
            "transition-timing-function: ease/ease-in/ease-out/ease-in-out/linear/step-start/step-end/steps(10,
            start)/steps(10, end)/cubic-bezier(0.1, -0.3, 0.2, 0)". Чтобы записать все эти значения в одну строку,
            используют "transition: свойство длительность тип_анимации задержка":</p>
        <pre>
            .transitionexample {
                color: red;
                border: 2px solid black;
                width: 200px;
                height: 200px;
                Background-color: aqua;
                margin: 50px;
                transition-duration: 500ms, 2s, 500ms;
                transition-property: transform, background-color, color;
                transition-delay: 0ms, 500ms, 500ms;
                transition-timing-function: linear;
                display: flex;
                justify-content: center;
                align-items: center;
            }
            .transitionexample:hover {
                background-color: red;
                transform: scale(1.2);
                color: aqua;
            }
        </pre>
        <div class="transitionexample">transitionexample</div>
    </section>

    <h3 Id="animations">Анимации</h3>

    <section>
        <p>Анимацию обьявляют следующим образом: "animation-name: имя анимации;" "animation-duration: ...s/ms;"
            "animation-timing-function: ease/ease-in/ease-out/ease-in-out/linear/step-start/step-end/steps(10,
            start)/steps(10, end)/cubic-bezier(0.1, -0.3, 0.2, 0);" "animation-iteration-count: число/infinite;" и
            "animation-direction: normal/reverse/alternate/alternate-reverse;"</p>
        <p>Все описание анимации можно скомпоновать в: "animation: name duration timing-function delay
            iteration-count
            direction fill-mode"</p>
        <p>Далее описываются шаги анимации: @keyframes имяАнимации { from {свойства} шаг_два(25%){}
            шаг_три(50%){свойства} ... to{свойства} }</p>
        <pre>
            .animationexample {
                color: red;
                border: 2px solid black;
                width: 200px;
                height: 200px;
                Background-color: aqua;
                margin: 50px;
                display: flex;
                justify-content: center;
                align-items: center;
                animation-name: myAnimation;
                animation-duration: 2s;
                animation-timing-function: linear;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
            }
            .animationexample:hover {
                animation-play-state: paused;
            }
            @keyframes myAnimation {
                from {
                    background-color: aqua;
                    color: red;
                }
                50% {
                    background-color: red;
                    color: aqua;
                    transform: scale(1.2);
                }
                to {
                    background-color: yellow;
                    color: darkslateblue;
                }
            }
    </pre>
        <div class="animationexample">animationexample</div>
    </section>

    <h3 Id="tablcurs">Таблицы и курсор</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/Y5MwssNWetI" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Таблице можно задать следующие параметры:</p>
        <ul>
            <li>border: ...;</li>
            <li>width/height: ...px;</li>
            <li>border-collapse: collapse/separate;</li>
            <li>caption-side: top(default)/bottom;</li>
            <li>text-align: left/center/right;</li>
            <li>vertical-align: baseline/bottom/middle/sub/super/text-bottom/text-top/top;</li>
            <li>empty-cells: show/hide;</li>
        </ul>
        <p>Чтобы управлять стилизацией курсора используют команду "cursor: ...;", команда имеет множество видов
            курсоров.</p>
        <br>
        <table class="table1">
            <caption>Team members price-list</caption>
            <thead>
            <tr>
                <th>Position</th>
                <th class="dis1" onclick="(function (){console.log('!!!')})()">Price</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>Front-end</td>
                <td>1000$</td>
                <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                    et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
                    aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                    cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
                    culpa qui officia deserunt mollit anim id est laborum."
                </td>
            </tr>
            <tr>
                <td>Full-stack</td>
                <td>1500$</td>
                <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                    et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
                    aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                    cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
                    culpa qui officia deserunt mollit anim id est laborum."
                </td>
            </tr>
            <tr>
                <td>QA</td>
                <td>700$</td>
                <td>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
                    et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
                    aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
                    cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
                    culpa qui officia deserunt mollit anim id est laborum."
                </td>
            </tr>
            </tbody>
        </table>
    </section>

    <h3 Id="texteffectsmulticolumnstext">Текстовые эффекты и многоколоночный текст</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/6sc-gmz_MYQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <div class="example35">CSS is Awesooooooooome!</div>
        <button id="overflowexample">overflow: hidden;<br>text-overflow: ellipsis;<br>white-space: nowrap;</button>
        <button id="wordwrapexample">word-wrap: break-word;<br>word-break: break-all;</button>
        <button id="writingmodeexample">writing-mode: vertical-lr;</button>
        <p>Чтобы разбить текст на колонки используют "column-count: ...;", Чтобы визуально разделить колонки используют
            "column-rule: ...px solid/(ect) color", чтобы задать ширину колонки используют "column-width: ...px", чтобы
            увеличить расстояние между колонками используют "column-gap: ...px"</p>
        <div class="textcontainer">
            <h2>Title 1</h2>
            <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et
                dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
                ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
                fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
                deserunt mollit anim id est laborum."</p>
            <h2>Title 2</h2>
            <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et
                dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
                ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
                fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
                deserunt mollit anim id est laborum."</p>
            <h2>Title 3</h2>
            <p>"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et
                dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip
                ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu
                fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia
                deserunt mollit anim id est laborum."</p>
        </div>
    </section>

    <h3 id="mediaqueries">Медиазапросы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/lv47xClJolw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Медиазапрос это директива или правило, которое позволяет применять различные свойства в зависимости от
            разрешения страницы, ориентации устройства, плотности пикселей и типа устройства:</p>
        <pre>
            @media screen/print/all/speech ...* {
                селектор {
                    свойство: значение;
                }
            }
        </pre>
        <p>*...(условие например min/max-width/height: ...px ) and (условие например not(color)/orientation: portrait),
            (запятая означает несколько выборов условий.), ("device-aspect-ratio: 16/9), (min-resolution: 2dppx),
            (min-resolution: 300dpi)</p>
        <p>Обычно @media используют для:</p>
        <ul>
            <li>Настройки количества колонок лэйаута</li>
            <li>Гибких параметров ширины</li>
            <li>Сжатия пустых пространств</li>
            <li>Настройки размеров шрифтов</li>
            <li>Изменения вида навигации</li>
            <li>Скрытия и отображения контента на разных устройствах</li>
            <li>Использования разных изображений</li>
        </ul>
    </section>

    <h3 id="placeholderscrollbarsprites">Стилизация плейсхолдера и скролла, CSS-спрайты</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/_eO1urQ71Lw" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Для того, чтобы стилизировать плейсхолдер, в CSS используют следующую конструкцию:</p>
        <pre>
            .placeholderexample {
                font-size: 24px;
                padding: 5px 10px;
                color: red;
            }
            .placeholderexample::placeholder {
                color: aqua;
                opacity: 1;
            }
            .placeholderexample::-ms-input-placeholder {
                color: aqua;
            }
            .placeholderexample:-ms-input-placeholder {
                color: aqua;
            }
        </pre>
        <input aria-label="please enter your name" class="placeholderexample" type="text" placeholder="please enter your name">
        <p>Для того чтобы стилизировать скроллбар используют следующую конструкцию:</p>
        <pre>
            .scrollbarexample {
                width: 300px;
                height: 100px;
                overflow: auto;
            }
            .scrollbarexample::-webkit-scrollbar {
                width: 15px;
                background: #101124;
            }
            .scrollbarexample::-webkit-scrollbar-track {
                border: 5px solid rgba(255,255,255,0.25);
                box-shadow: inset 0 0 2.5px 2px rgba(0,0,0,0.5);
            }
            .scrollbarexample::-webkit-scrollbar-thumb {
                background: linear-gradient(45deg, #00ffa1, #00ffff);
                border-radius: 15px;
            }
        </pre>
        <p class="scrollbarexample">"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor
            incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco
            laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit
            esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa
            qui officia deserunt mollit anim id est laborum."</p>
        <p>Стилизация элементов взаимодействия с помощью спрайт картинок основывается на изменении позиции отображаемой
            области картинки:</p>
        <img src="JSImages/button2.jpg" width="450" height="250" alt="button">
        <pre>
            #spriteexample {
                background-image: url("button2.jpg");
                background-position: -198px -112px;
                width: 157px;
                height: 60px;
                border: none;
                background-color: transparent;
                cursor: pointer;
                outline: blue;
            }
            #spriteexample:active {
                background-position: -198px -188px;
            }
        </pre>
        <button id="spriteexample"></button>
    </section>

    <h2>CSS Flexbox</h2>

    <h3 id="basedefinitions">Основные понятия</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/9MxBkY2_WNA" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Flex Container это элемент которому задано значение "display: flex|inline-flex":</p>
        <div class="flexcontainerexample">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <div class="flexitem item7">7</div>
            <div class="flexitem item8">8</div>
        </div>
        <button id="displayflexexample">display: flex;</button>
        <button id="normalise">display: inline;</button>
    </section>

    <h3 id="flexdirection">Направление осей</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/OQ6GyMD5E-s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <div class="flexcontainerexample2">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <div class="flexitem item7">7</div>
            <div class="flexitem item8">8</div>
        </div>
        <p>За расположение главной оси отвечает свойство "flex-direction", оно имеет следующие свойства:</p>
        <button id="rowexample">flex-direction: row;(по умолчанию)</button>
        <br>
        <button id="rowreverseexample">flex-direction: row-reverse;</button>
        <br>
        <button id="columnexample">flex-direction: column;</button>
        <br>
        <button id="columnreverseexample">flex-direction: column-reverse;</button>
    </section>

    <h3 id="flexwrapgap">Перенос элементов и отступы</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/zvkE0MY1cxE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Для того чтобы разрешить перенос элементов на другой ряд, если в текущем им недостаточно места, применяют
            "flex-wrap: nowrap(по умолчанию)/wrap/wrap-reverse;":</p>
        <pre>
            .flexcontainerexample3 {
                border: 10px solid #7f00ff;
                width: 500px;
                display: flex;
            }
            .flexcontainerexample3 .flexitem {
                width: 44%;
                margin: 5px;
            }
    </pre>
        <div class="flexcontainerexample3">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <div class="flexitem item7">7</div>
            <div class="flexitem item8">8</div>
        </div>
        <button id="flexnowrapexample">flex-wrap: nowrap;</button>
        <br>
        <button id="flexwrapexample">flex-wrap: wrap;</button>
        <br>
        <button id="flexwrapreverseexample">flex-wrap: wrap-reverse;</button>
        <br>
        <p>Свойство "gap" определяет расстояние между элементами внутри флекс контейнера.</p>
    </section>

    <h3 id="alignmentjustifycontent">Выравнивание вдоль главной оси</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/FKDfECxwC54" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <button id="resetbutton">reset</button>
        <br>
        <div class="flexcontainerexample4">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <!--        <div class="flexitem item7">7</div>-->
            <!--        <div class="flexitem item8">8</div>-->
        </div>
        <p>Для того чтобы одновременно изменить расположение главной оси и перенести флекс элементы на новый ряд в
            случае отсутствия места в текущем ряду используют "flex-flow: column/column-reverse wrap;":
            <button id="flexflowexample">flex-flow: column wrap;</button>
        </p>
        <p>Чтобы перемещать флекс элементы вдоль главной оси используют "justify-content" со следующими значениями: </p>
        <ul>
            <li>
                <button id="flexstartexample">justify-content: flex-start; (default)</button>
            </li>
            <li>
                <button id="flexendexample">justify-content: flex-end;</button>
            </li>
            <li>
                <button id="centerexample">justify-content: center;</button>
            </li>
            <li>
                <button id="spacebetweenexample">justify-content: space-between;</button>
            </li>
            <li>
                <button id="spacearoundexample">justify-content: space-around;</button>
            </li>
            <li>
                <button id="spaceevenlyexample">justify-content: space-evenly;</button>
            </li>
        </ul>
    </section>

    <h3 id="alignmentalignitems">Выравнивание вдоль поперечной оси</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/_9idibPDs1s" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <button id="resetfontsize">reset font-size</button>
        <div class="flexcontainerexample5">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <!--<div class="flexitem item7">7</div>-->
            <!--<div class="flexitem item8">8</div>-->
        </div>
        <p>Для того чтобы задать выравнивание элементов вдоль дополнительной оси, используют свойство "align-items"
            которое имеет следующие свойства:</p>
        <ul>
            <li>
                <button id="stretchexample">align-items: stretch; (default)</button>
            </li>
            <li>
                <button id="flexstartexample2">align-items: flex-start;</button>
            </li>
            <li>
                <button id="flexendexample2">align-items: flex-end;</button>
            </li>
            <li>
                <button id="centerexample2">align-items: center;</button>
            </li>
            <li>
                <button id="baselineexample">align-items: baseline; (+font-size)</button>
            </li>
        </ul>
    </section>

    <h3 id="aligncontent">Многострочное выравнивание</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/sDkL7o0LXF0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <button id="onwrapbutton">flex-wrap: wrap;</button>
        <button id="offwrapbutton">flex-wrap: nowrap;</button>
        <br>
        <button id="oncolumn">flex-direction: column;</button>
        <button id="offcolumn">flex-direction: row;</button>
        <br>
        <button id="autowidth">width: auto;</button>
        <button id="pxwidth">width: 100px;</button>

        <div class="flexcontainerexample6">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">2</div>
            <div class="flexitem item3">3</div>
            <div class="flexitem item4">4</div>
            <div class="flexitem item5">5</div>
            <div class="flexitem item6">6</div>
            <div class="flexitem item7">7</div>
            <div class="flexitem item8">8</div>
        </div>
        <p>Для выравнивания многострочного контента используют "align-content", оно срабатывает только если к контейнеру
            применено свойство "flex-wrap: wrap;"</p>
        <p>"align-content" имеет следующие значения:</p>
        <ul>
            <li>
                <button id="acstretchexample">align-content: stretch; (default)</button>
            </li>
            <li>
                <button id="acflexstartexample">align-content: flex-start;</button>
            </li>
            <li>
                <button id="acflexendexample">align-content: flex-end;</button>
            </li>
            <li>
                <button id="accenterexample">align-content: center;</button>
            </li>
            <li>
                <button id="acspacebetweenexample">align-content: space-between;</button>
            </li>
            <li>
                <button id="acspacearoundexample">align-content: space-around;</button>
            </li>
            <li>
                <button id="acspaceevenlyexample">align-content: space-evenly;</button>
            </li>

        </ul>
    </section>

    <h3 id="alignself">Индивидуальное выравнивание элементов</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/WeFMfoK9R2o" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>"align-self" предназначено для выравнивания ОПРЕДЕЛЕННОМУ ЭЛЕМЕНТУ и имеет следующие значения:</p>
        <div class="flexcontainerexample7">
            <div class="flexitem item1">1
                <div class="fontsizefc">stretch</div>
            </div>
            <div class="flexitem item2">2
                <div class="fontsizefc">flex-start</div>
            </div>
            <div class="flexitem item3">3
                <div class="fontsizefc">center</div>
            </div>
            <div class="flexitem item4">4
                <div class="fontsizefc">flex-end</div>
            </div>
            <div class="flexitem item5">5
                <div class="fontsizefc">baseline</div>
            </div>
            <div class="flexitem item6">6
                <div class="fontsizefc">baseline</div>
            </div>
            <!--        <div class="flexitem item7">7</div>-->
            <!--        <div class="flexitem item8">8</div>-->
        </div>
    </section>

    <h3 id="flexboxsizing">Размеры элементов</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/rDdUWDaJzQ8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Чтобы задать пропорцию по которой элементы будут занимать свободный объем используют "flex-grow: 1/2/3/...;".
            Чем больше число, тем на такую пропорцию элемент будет забирать на себя больше свободного пространства.</p>
        <p>Для того, чтобы определить сколько свободного пространства элемент может отдать, применяют свойство
            "flex-shrink: 1(default)/2/3...;". Чем больше число, тем больше пространства флекс элемент будет отдавать в
            пропорции.</p>
        <p>"flex-basis: ...px/%" задает жесткие размеры.</p>
        <p>Все три этих значения объединяются во "flex: grow shrink basis;"</p>
        <input aria-label="css values" type="number" id="firstitem" placeholder="flex-grow: ...; (.item1)">
        <input aria-label="css values" type="number" id="seconditem" placeholder="flex-grow: ...; (.item2)">
        <input aria-label="css values" type="number" id="thirditem" placeholder="flex-grow: ...; (.item3)">
        <button id="acceptbutton">accept</button>
        <br>
        <input aria-label="css values" type="number" id="fsfirstitem" placeholder="flex-shrink: ...; (.item1)">
        <input aria-label="css values" type="number" id="fsseconditem" placeholder="flex-shrink: ...; (.item2)">
        <input aria-label="css values" type="number" id="fsthirditem" placeholder="flex-shrink: ...; (.item3)">
        <button id="acceptbuttonfs">accept</button>
        <br>
        <input aria-label="css values" type="text" id="flexfirstitem" placeholder="flex: ...; (.item1)">
        <input aria-label="css values" type="text" id="flexseconditem" placeholder="flex: ...; (.item2)">
        <input aria-label="css values" type="text" id="flexthirditem" placeholder="flex: ...; (.item3)">
        <button id="acceptbuttonflex">accept</button>
        <div class="flexcontainerexample8">
            <div class="flexitem item1">1
                <div class="cssshow1"></div>
            </div>
            <div class="flexitem item2">2
                <div class="cssshow2"></div>
            </div>
            <div class="flexitem item3">3
                <div class="cssshow3"></div>
            </div>
            <!--<div class="flexitem item4">4</div>-->
            <!--<div class="flexitem item5">5</div>-->
            <!--<div class="flexitem item6">6</div>-->
            <!--<div class="flexitem item7">7</div>-->
            <!--<div class="flexitem item8">8</div>-->
        </div>
    </section>

    <h3 id="order">Определение порядка элементов</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/o_ozA-YMttU" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>За задание порядка флекс элемента отвечает "order: число;". "order" может быть так же отрицательным.</p>
        <div class="flexcontainerexample9">
            <div class="flexitem item1">1<input aria-label="number input order1" type="number" id="order1"></div>
            <div class="flexitem item2">2<input aria-label="number input order2" type="number" id="order2"></div>
            <div class="flexitem item3">3<input aria-label="number input order3" type="number" id="order3"></div>
            <div class="flexitem item4">4<input aria-label="number input order4" type="number" id="order4"></div>
            <div class="flexitem item5">5<input aria-label="number input order5" type="number" id="order5"></div>
            <div class="flexitem item6">6<input aria-label="number input order6" type="number" id="order6"></div>
            <div class="flexitem item7">7<input aria-label="number input order7" type="number" id="order7"></div>
            <div class="flexitem item8">8<input aria-label="number input order8" type="number" id="order8"></div>
        </div>
        <button id="orderaccept">accept</button>
    </section>

    <h3 id="nestingflexbasisflexwrap">Вложенность. Обёртка элементов с размерами</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/ar1F5IwBeSc" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Любой флекс элемент можно превратить во флекс контейнер и это никак не поменяет его взаимодействие с
            родительским контейнером:</p>
        <div class="flexcontainerexample11">
            <div class="flexitem item1">1</div>
            <div class="flexitem item2">
                <div class="flexitem inneritem1">1</div>
                <div class="flexitem inneritem2">2</div>
            </div>
            <div class="flexitem item3">3</div>
            <!--        <div class="flexitem item4">4</div>-->
            <!--        <div class="flexitem item5">5</div>-->
            <!--        <div class="flexitem item6">6</div>-->
            <!--        <div class="flexitem item7">7</div>-->
            <!--        <div class="flexitem item8">8</div>-->
        </div>
        <p>Использование "flex-basis" удобно тем, что при переворачивании основной линии(row/column) не нужно
            переопределять размер с ширины на высоту и наоборот:</p>

        <button id="cont10row">flex-direction: row</button>
        <button id="cont10col">flex-direction: column</button>
        <br>
        <input aria-label="range input" type="range" id="rangeinputx" min="230" max="970" step="2" oninput="fun1()"><br>
        <div class="box1">
            <div class="flexcontainerexample10">
                <div class="flexitem item1">1</div>
                <div class="flexitem item2">2</div>
                <div class="flexitem item3">3
                    <div>flex-grow: 5;</div>
                </div>
                <div class="flexitem item4">4</div>
                <div class="flexitem item5">5</div>
                <div class="flexitem item6">6</div>
                <div class="flexitem item7">7</div>
                <div class="flexitem item8">8</div>
            </div>
            <input aria-label="range input" type="range" id="rangeinputy" min="110" max="740" step="2" oninput="fun2()">
        </div>
    </section>

    <h3 id="practicalexamples">Практические примеры использования Flexbox</h3>
    <!--<iframe width="560" height="315" src="https://www.youtube.com/embed/GGiHxIOmPaE" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
    -->
    <section>
        <p>Трехколоночный макет пк и мобильная версия:</p>
        <div class="flexcontainerexample12">
            <div class="flexitem item1">Header</div>
            <div class="mainbox">
                <div class="flexitem item2">Aside</div>
                <div class="flexitem item3">Main</div>
                <div class="flexitem item4">Aside</div>
            </div>
            <div class="flexitem item5">Footer</div>
        </div>
        <p>Модальное окно:</p>
        <div class="flexcontainerexample13">
            <div class="mwcontainer">
                <div class="flexitem item1">Modal window</div>
                <button id="closemw">x</button>
            </div>
        </div>
        <button id="modalwindow">Модальное окно</button>
        <p>Медиа объект:</p>
        <div class="flex-container">
            <img src="https://placekitten.com/100/100" alt="image">
            <div class="content">
                <p>
                    Lorem ipsum dolor sit amet consectetur adipisicing elit. Eveniet minus quam, ipsam tempora modi
                    maxime fuga quod aperiam impedit hic quo consequuntur, esse odit repellat, fugiat magnam sint
                    accusantium dicta?
                </p>
            </div>
        </div>
        <p>Сайдбар навигации</p>
        <div class="flexcontainerexample14">
            <div class="flexitem item1">
                <nav>
                    <div class="flexitem item2">Home</div>
                    <div class="flexitem item3">Posts</div>
                    <div class="flexitem item4">About</div>
                </nav>
                <nav>
                    <div class="flexitem item5">Settings</div>
                    <div class="flexitem item6">Login</div>
                </nav>
            </div>
        </div>
        <hr>
    </section>

    <h2>Основы JavaScript</h2>

    <h3 id="intro">Введениe</h3>

    <section>
        <p>Практически все сущности в JavaScript - это объекты.</p>
        <p>Объект - это набор свойств "имя(ключ): значение". К объектам относятся массивы и функции, числа и строки же -
            ведут себя как объекты, при этом являются примитивными значениями.</p>

        <p>Базовые методы объекта console:</p>

        <ul>
            <li>console.log() - отображает заданный аргумент в консоль</li>
            <li>console.dir() - отображает все свойства объекта в консоль</li>
            <li>console.table() - отображает все свойства объекта в табличном виде в консоль</li>
        </ul>

        <p>Любое выражение всегда возвращает значение.</p>

        <p>Выражения с побочными действиями - это выражение, которое не только возвращает значение, но и выполняет
            другие действия.</p>

        <p>Переменные дают возможность повторного доступа к значениям.</p>

        <p>Имена переменных:
        <p>

        <ul>
            <li>PascalCase используется для Типов и Классов.</li>
            <li>DB_PASSWORD - значения известны до запуска приложения и не меняются.</li>
            <li>camelCase - все остальные переменные.</li>
        </ul>

        <p>"let a" - объявление переменной, "const c = 10" - объявление и присваивание, "a = true" - только
            присваивание.</p>
        <p>В случае let переприсваивание значений возможно, в случае с const - нет.</p>

        <p>Тип переменной определяется типом присвоенного значения.</p>

        <p>Типы: примитивные типы и ссылочный тип</p>

        <p>Примитивные типы:</p>

        <ul>
            <li>string(строка)</li>
            <li>boolean(логический)</li>
            <li>number(число)</li>
            <li>null</li>
            <li>undefined</li>
            <li>symbol(символ)</li>
        </ul>

        <p>Ссылочный тип - object(объект)</p>

        <p>В случае присваивания переменной объекта, переменная хранит только ссылку на объект, но не сам объект, в
            случае же присваивания примитивных данных, она хранит именно примитивные данные.</p>

        <p>Динамическая типизация - одной и той же переменной можно присвоить значения разных типов. JavaScript -
            динамически типизируемый язык.</p>
        <p>const позволяет предотвратить возможные проблемы связанные с динамической типизацией! Рекомендуется
            использовать const везде, где это возможно.</p>
    </section>

    <h3 id="objects">Объекты</h3>

    <section>
        <p>Объект - набор свойств "имя: значение", так же так обозначают тип значений/переменных.</p>
        <p>Порядок свойств в объекте не имеет значения.</p>
        <p>Доступ к значению получается следующим образом: object.name, объявление новой пары имя:значение или изменение
            значения в уже существующей паре, так же делается через точечную запись: cobject.name2 = 'value';
            object.name2 = 'newValue'</p>
        <p>Оператор удаления - "delete": delete object.name -> данное имя и его значение будет удалено. </p>
        <p>Помимо точечной записи можно использовать синтаксис скобочной записи:</p>
        <pre>
            iobject['someName'] = value ||
            const propertyName = 'someName';
            object[propertyName] = value;
            object = {someName: value}
        </pre>
        <p>Вложенные свойства это вложенный объект:</p>
        <pre>
            object = {
               someName: {
                  someIneredName: someIneredValue
               }
            }

            object.someName.someIneredValue (чтобы получить значение вложенного объекта)
        </pre>

        <p>В случае если заданы какие-то переменные и их значения нужно присвоить одноименным ключам в объекте, можно
            использовать сокращенную запись:</p>
        <pre>
            const name_1 = value_1;
            const name_2 = value_2;
            const object = {
               name_1,       // (вместо name_1: name_1)
               name_2        // (вместо name_2: name_2)
            }

        </pre>
    </section>

    <h3 id="globalObjects">Глобальные объекты:</h3>

    <section>
        <ul>
            <li>Window(веб браузеры)</li>
            <li>global(Node.js)</li>
            <li>globalThis(унифицированный глобальный объект)</li>
        </ul>
    </section>

    <h3 id="methods">Методы</h3>

    <section>
        <p>Метод это свойство объекта, значение которого - функция. Метод вызывается при помощи двух скобок:
            someMethod();</p>
        <p>JSON (JavaSctipt Object Notation) формат обмена данными, между компьютерами в интернете.</p>
        <p>Пример JSON: '{"userId": 1, "id": 1, "title": "Test title", "status": {"completed": false }}'</p>
        <p>Чтобы конвертировать JSON в объект используют метод JSON.parse():</p>
        <pre>
            JSON.parse(someJSON);

            {
               userId: 1,
               id: 1,
               title: 'Test title',
               status: {
                  completed: false
                 }
            }
        </pre>
        <p>Если требуется трансформировать объект в JSON, то используют JSON.stringify()</p>
    </section>

    <h3 id="mutationInJS">Мутация в JavaScript</h3>

    <section>
        <p>Изменение свойств объекта называют мутацией объекта.</p>
        <p>Если одной переменной присвоен объект, и второй переменной присвоить ссылку объекта из первой переменной и
            мутировать его, то вызывая объект через первую переменную будет показано измененное значение(мутирование
            объекта через копию):</p>
        <pre>
            const person = {
               name: 'Bob',
               age: 25
            }

            const person2 = person;

            person2.age = 26;
            person2.isAdult = true;

            console.log(person.age); // --> 26
            console.log(person.isAdult); // --> true
        </pre>
        <p>Чтобы избежать описанной сверху ситуации используют Object.assign({}, object). Не работает для вложенных
            объектов!!!</p>
        <pre>
            const person2 = Object.assign({}, person);
            person2.age = 26;

            console.log(person2.age); // --> 26
            console.log(person.age); // --> 25
        </pre>
        <p>Второй вариант создания нового объекта, а не копирование ссылки - использование спред оператора(Так же не
            работает для вложенных объектов!!!):</p>
        <pre>
            const person2 = {...person};
            person2.name = 'Alice';

            console.log(person2.name); // --> Alice
            console.log(person.name); // --> Bob
        </pre>
        <p>Третий вариант создания нового объекта с полным избежанием мутаций(ссылки на вложенные объекты не
            сохраняются) - комбинация JSON.stringify() и JSON.parse():</p>
        <pre>
            const person2 = JSON.parse(JSON.stringify(person));
            person2.name = 'Alice';

            console.log(person2.name); // --> Alice
            console.log(person.name); // --> Bob
        </pre>
    </section>

    <h3 id="functions">Функции</h3>

    <section>
        <p>Функция это блок кода который можно выполнять многократно. Функция является объектом и как у любого объекта у
            функции есть свойства.</p>
        <p>Функция может быть:</p>
        <ul>
            <li>именнованой</li>
            <li>анонимной</li>
            <li>присвоенна переменной</li>
            <li>аргументом при вызове другой функции(CallBack функция)</li>
            <li>значением свойства(метода) объекта</li>
        </ul>
        <p>Функции содержат:</p>
        <ul>
            <li>Ключевое слово function</li>
            <li>имя функции</li>
            <li>параметры в скобках ()</li>
            <li>тело функции в фигурных скобках {}</li>
            <li>ключевое слово return, для возвращения результата</li>
        </ul>
        <p>Return прерывает выполнение кода, даже если есть еще невыполненные строчки кода</p>
        <p>Вызов функции совершается именем функции со скобками, внутрь скобок параметрам можно задать аргументы если
            эти параметры были заданы при объявлении функции</p>
        <p>Функции объявленные ключевым словом function могут быть вызваны до объявления, а которые обявлены следующим
            методом: "const functionName = function() {}" - могут быть вызваны только после объявления</p>
        <pre>
            function someFunction(param1, param2) {
               let param3;
               param3 = param1 + param2;
               return param3;
            }

            console.log(someFunction(10, 3)); // --> 13;
        </pre>
    </section>

    <h3 id="linkedValues">Передача значения по ссылке</h3>

    <section>
        <p>Внутри функций не рекомендуется мутировать внешний объект, рекомендуется делать копию объекта и мутировать
            уже его:</p>
        <pre>
            const personOne = {
               name: 'Bob',
               age: 21
            }
            function increasePersonAge(person) {
               const updatedPerson = {...person};
               updatedPerson.age += 1;
               return updatedPerson;
            }
            const updatedPersonOne = increasePersonAge(personOne);
            console.log(personOne.age); // --> 21
            console.log(updatedPersonOne.age); // --> 22
        </pre>
    </section>


    <h3 id="callbackFunction">CallBack функции</h3>

    <section>
        <p>Колбэк функции это функции вызванные внутри другой функции.</p>
        <pre>
            function someFunction () {
              // действия...
            }

            function functionWithCallBack(callbackFunction) {
              callbackFunction();
            }
            functionWithCallBack(someFunction);
        </pre>
    </section>

    <h3 id="functionRules">Правила работы с функциями:</h3>

    <section>
        <ol>
            <li>Называйте функции исходя из выполняемых задач</li>
            <li>Одна функция должна выполнять одну задачу</li>
            <li>Не рекомендуется изменять внешние относительно функции переменные</li>
        </ol>
    </section>

    <h3 id="scope">Область видимости</h3>

    <section>
        <p>Область видимости определяет границы действия переменной. Разделяется на глобальную область видимости и
            локальные области видимости.</p>
        <p>Переменные с одинаковым именем в локальной области видимости и глобальной - это разные переменные! Если такая
            переменная объявлена в локальной области видимости, то глобальная будет проигнорирована, если же нет, то
            переменная будет взята из глобальной области видимости</p>

        <pre>
            let a;
            let b;

            const myFn = () => {
               let b;
               a = true;
               b = 10;
               console.log(b); // --> 10
            }

            myFn();

            console.log(a); // --> true
            console.log(b); // --> undefined
        </pre>
    </section>

    <h3 id="сhainOfScopes">Цепочка областей видимости</h3>

    <section>
        <p>В случае, если есть несколько вложенных областей видимости, и если были вызваны некоторые переменные, то
            поиск их аргументов происходит "снизу вверх", т.е. сначала аргумент будет искаться в текущей области
            видимости, потом в верхней, и тд</p>
    </section>

    <h3 id="variableLifeCycle">Жизненный цикл переменных</h3>

    <section>
        <p>Жизненный цикл переменной ограничен областью видимости, где она была объявлена:</p>
        <pre>
            let a;
            let b;

            const someFunction = () => {
               let b;
               a = true;
               b = 10;
               console.log(a); // --> true
               console.log(b); // --> 10
            }

            someFunction();

            console.log(a); // --> true
            console.log(b); // --> undefined
        </pre>
        <p>Тк b была объявлена локально, то присвоенная 10 была применена только к ней, ибо обращение к глобальной b не
            произошло</p>
    </section>

    <h3 id="typeOfScopes">Типы областей видимости</h3>

    <section>
        <ul>
            <li>Глобальная область видимости</li>
            <li>Область видимости функции</li>
            <li>Область видимости блока[*]</li>
        </ul>
        <p>[*] Переменные объявленные с помощью let или const внутри блока имеют область видимости, ограниченную
            этим блоком. Блок это код внутри фигурных скобок(if/for ect.).</p>

        <p>Если присвоить не объявленной переменной некий аргумент, то при ее вызове она будет автоматически объявлена в
            глобальной области видимости, (даже если она вызывается в локальной области видимости), присвоение значений
            не объявленным переменным - bad practice</p>
        <p>Правила работы с переменными:</p>
        <ol>
            <li>Все переменные нужно объявлять перед их использованием</li>
            <li>Стараться использовать const везде, где это возможно</li>
            <li>Внутри функций не изменять переменные с внешних областей видимости</li>
        </ol>
    </section>

    <h3 id="strictMode">Строгий режим / Strict mode</h3>

    <section>
        <p>Строчка 'use strict' в самом начале JavaScript файла запрещает использование необъявленных переменных во всем
            файле, либо же можно написать ее первой строчкой в какой-то локальной области видимости, чтобы включить этот
            режим только в нем.</p>
    </section>

    <h3 id="operators">Операторы</h3>

    <section>
        <ul>
            <li>Арифметические
                <ul>
                    <li>+</li>
                    <li>-</li>
                    <li>*</li>
                    <li>/</li>
                </ul>
            </li>
            <li>сравнения
                <ul>
                    <li>===</li>
                    <li>!==</li>
                    <li><=</li>
                    <li>>=</li>
                </ul>
            </li>
            <li>логические
                <ul>
                    <li>!</li>
                    <li>&&</li>
                    <li>||</li>
                </ul>
            </li>
            <li>присваивания =</li>
        </ul>
        <p>Текстовые операторы:</p>
        <ul>
            <li>typeof(проверка типа объекта)</li>
            <li>instanceof(проверка принадлежности объекта к тому или иному классу)</li>
            <li>new</li>
            <li>delete</li>
        </ul>
        <p>Оператор - это встроенная функция.</p>
        <p>Операнды - то, к чему применяется оператор. Например: 5 * 2 - оператор умножения с левым и правым операндами.
            Другое название: "аргумент оператора".</p>
        <p>Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-"
            меняет знак числа на противоположный: x = -x; x++; +x; delete obj.x; typeof x; new Object();</p>
        <p>Бинарным называется оператор, который применяется к двум операндам. Тот же минус существует и в бинарной
            форме: y - x; y = x; y + x; y === x; y && x; y += x; </p>
    </section>

    <h3 id="operatorNotationFormats">Форматы записи операторов</h3>

    <section>
        <p>Инфиксная запись(оператор находится между операндами):</p>
        <ul>
            <li>a = true</li>
            <li>a + b</li>
            <li>a += 5</li>
            <li>a || b</li>
            <li>a > b</li>
        </ul>

        <p>Префиксная запись(оператор находится перед операндом):</p>
        <ul>
            <li>++a</li>
            <li>delete obj.a</li>
            <li>typeof a</li>
        </ul>

        <p>Постфиксная запись(оператор находится после операнда):</p>
        <ul>
            <li>a++</li>
            <li>someFunction()</li>
        </ul>
    </section>

    <h3 id="operatorPrecedence">Приоритетность операторов</h3>

    <section>
        <p>Математические операторы имеют такую же приоритетность как в алгебре.</p>
    </section>

    <h3 id="logicalOperators">Логические операторы</h3>

    <section>
        <ul>
            <li>! - префиксный оператор отрицания. Тип - boolean.</li>
            <li>&& - инфиксный бинарный оператор "и". Возвращает значение одного из операндов.</li>
            <li>|| - инфиксный бинарный оператор "или". Возвращает значение одного из операндов.</li>
            <li></li>
        </ul>
    </section>

    <h3 id="falseValues">Ложные значения</h3>

    <section>
        <p>Ложными значениями являются те значения, которые при приведении к логическому типу(типу Boolean()) дают
            false:</p>
        <ul>
            <li>false</li>
            <li>0</li>
            <li>''</li>
            <li>undefined</li>
            <li>null</li>
        </ul>
        <p>Истинными значениями являются те значения, которые при приведении к логическому типу(типу Boolean()) дают
            true:</p>
        <ul>
            <li>true</li>
            <li>1</li>
            <li>' '</li>
            <li>'someText'</li>
        </ul>
    </section>

    <h3 id="operatorTypeOf">Оператор typeof</h3>

    <section>
    <pre>
        typeof 10 === 'number'; // --> true
        typeof 'someText' === 'string'; // --> true
        typeof undefined; // --> 'undefined'
    </pre>
    </section>

    <h3 id="negationOperator">Префиксный унарный оператор "!"(не/отрицания)</h3>

    <section>
        <p>Оператор "!" чаще всего используется в условных инструкциях.</p>
        <ul>
            <li>!10 // --> false</li>
            <li>!0 // --> true</li>
            <li>!'someText' // --> false</li>
            <li>!'' // --> true</li>
            <li>!true // --> false</li>
            <li>!undefined // --> true</li>
        </ul>
    </section>

    <h3 id="negationOfNegation">Отрицание отрицания "!!"</h3>

    <section>
        <p>Оператор "!!" позволяет проверить ложность значения:</p>
        <ul>
            <li>!!10 // --> true</li>
            <li>!!0 // --> false</li>
            <li>!!'someText' // --> true</li>
            <li>!!'' // --> false</li>
            <li>!!true // --> true</li>
            <li>!!undefined // --> false</li>
            <li>!!{} // --> true</li>
        </ul>
    </section>

    <h3 id="andOr">Операторы короткого замыкания "и" и "или"</h3>

    <section>
        <p>Операторы "&&" и "||" являются операторами короткого замыкания.</p>

        <p>Оператор "&&":</p>
        <pre>
            expression1 && expression2
        </pre>
        <p>Если expression1 ложно, то expression2 игнорируется и возвращается результат expression1.</p>
        <p>Если expression1 истинно, то проверяется expression2 и возвращается только его результат.</p>

        <p>Оператор "||":</p>
        <pre>
            expression1 || expression2
        </pre>
        <p>Если expression1 истинно, то expression2 игнорируется и возвращается результат expression1.</p>
        <p>Если expression1 ложно, то проверяется expression2 и возвращается только его результат.</p>

        <p>С помощью оператора "&&" можно вызывать функции по условию:</p>
        <pre>
            let a = 10;

            a && console.log('выполнено'); // --> выполнено/undefined

            let c;

            c && console.log('выполнено'); // --> undefined
        </pre>
    </section>

    <h3 id="chainOfAndOr">Цепочки операторов "&&" и "||"</h3>

    <section>
        <p>Если используется оператор &&, то ищется первое отрицательное значение и возвращается его значение.</p>
        <p>Если же используется оператор ||, то ищется уже первое истинное значение и так же возвращается его
            значение.</p>
    </section>

    <h3 id="spreadOperator">Оператор разделения объекта на свойства "..." (spread)</h3>

    <section>
        <pre>
            const button = {
               width: 200,
               text: 'buy'
            }

            const redButton = {
               ...button,
               color: 'red'
            }

            console.log(redButton) // --> {width: 200, text: 'buy', color: 'red'}
        </pre>
        <p>Если свойство присутствует и в разделяемом объекте и в дополняемом объекте, то для замены этого свойства
            оператор spread с разворачиваемым объектом надо писать первыми.</p>
    </section>

    <h3 id="stringСoncatenation">Конкатенация строк</h3>

    <section>
        <pre>
            'hello ' + 'world'; // --> 'hello world'

            const hello = 'hello';
            const world = 'world';

            const greeting = hello + ' ' + world;

            либо

            const greeting = `${hello} ${world}`; (использование шаблонной строки)

            greeting // --> 'hello world'
        </pre>
    </section>

    <h3 id="functionExpressions">Функциональные выражения. Объявленная функция VS функциональное выражение.</h3>

    <section>
        <p>Функциональные выражения ВСЕГДА анонимные и их нельзя использовать автономно. Так же как и объявленная
            функция, функциональное выражение может быть присвоено переменной и так же использовано как аргумент в
            вызове другой функции(быть callback функцией).</p>
    </section>

    <h3 id="arrowFunction">Стрелочные функции</h3>

    <section>
        <p>Стрелочная функция это выражение и она ВСЕГДА анонимная и чтобы ей дать имя ее нужно присвоить
            переменной.</p>
        <pre>
            const someFunctionName = (a, b) => {
                let c;
                c = a + b;
                return c;
            }

            someFunctionName(5,10); // --> 15
        </pre>

        <p>Сокращение в стрелочных функциях:</p>
        <ul>
            <li>Если только один параметр, то скобки можно опустить:
                <pre>
                a => {
                   // тело функции
                }
            </pre>
            </li>
            <li>Фигурные скобки можно опустить, если тело функции состоит из одного выражения. В этом случае стрелочная
                функция неявно возвращает результат выражения:
                <pre>
                (a, b) => a + b;
            </pre>
            </li>
        </ul>
    </section>

    <h3 id="defaultValues">Значения параметров функций по умолчанию</h3>

    <section>
        <pre>
            const multByFactor = (value, multiplier = 2) => {
                return value * multiplier;
            }

            multByFactor(5); // --> 10
            multByFactor(10, 3); // --> 30
        </pre>

        <pre>
            const newPost = (post, addedAt = Date()) => ({
                ...post,
                addedAt,
            })

            const firstPost = {
                id: 1,
                author: 'Dmitry'
            }

            console.log(newPost(firstPost));
        </pre>
    </section>

    <h3 id="tryCatch">Обработка ошибок в JavaScript</h3>

    <section>
        <pre>
            try {
                // Выполнение блока кода
            } catch (error) {
                // этот блок кода выполняется в случае
                возникновения ошибок в блоке try
            }
        </pre>

        <pre>
            const functionWithError = () => {
                throw new Error('some error')
            }

            try {
                functionWithError();
            } catch (error) {
                console.error(error);
                console.log(error.message);
            }

            console.log('continue...');
        </pre>
    </section>

    <h3 id="instructions">Инструкции</h3>

    <section>
        <p>Выражение всегда возвращает значение.</p>
        <p>Инструкция всегда выполняет действие. Инструкция зашеврается ";" которая стоит вконце инструкции. Исключение:
            точка с запятой не требуется после блока инструкций.</p>
        <p>Точку с запятой можно опускать в JavaScript(но лучше их использовать)</p>

        <pre>
            let a;

            const b = 5;

            if (a > b) {
                console.log('a is larger');
            } // (точка с запятой не требуется)

            for (let i = 0; i++; i < 5) {
                console.log(i);
            } // (точка с запятой не требуется)
        </pre>
    </section>

    <h3 id="statementExpressions">Выражения-инструкции</h3>

    <section>
        <p>Выражение может быть инструкцией:</p>
        <pre>
            'abc';
            a = a + 3;
            c = a + b;
            d = 'good ' + 'evening';
            someFunction(c, d);
            console.log('hey');
        </pre>
        <p>Если выражение написано на отдельной строке, то это выражение - инструкция.</p>
        <p>Инструкция не может быть трансформирована в выражение.</p>
        <p>Как отличить выражение от инструкции? Выражения могут быть использованы как аргументы в вызовах функций, в
            отличие от инструкций.</p>

        <pre>
            let someFn = (a) => {
                console.log(a);
            }

            const b = true;
            let c = 10;

            someFn(2 + 3) // --> 5
            someFn(b) // --> true
            someFn(c = c + 1) // --> 11
            someFn(c = c + 1;) // --> Uncaught SyntaxError
            someFn(let d) // --> Uncaught SyntaxError
        </pre>
    </section>

    <h3 id="arrays">Массивы</h3>

    <section>
        <p>Массив это объект с цифровыми именами свойств.</p>
        <p>Формат записи массивов:</p>
        <pre>
            const someArray = [1, 2, 3];
            console.log(someArray); // --> [1, 2, 3]

            const someArray2 = new Array(1, 2, 3); // создание нового экземпляра класса Array
            console.log(someArray2); // --> [1, 2, 3]
        </pre>
        <p>Структура массивов</p>
        <img src="images/arrayStructure.png" alt="arrayStructure" width="644">
    </section>

    <h3 id="comparisonOperatorForArraysAndObjects">Оператор сравнения для массивов и объектов</h3>

    <section>
        <p>Тк массивы это объекты, то переменные которым присвоены одинаковые массивы при сравнении не будут равны:</p>
        <pre>
            const someArray = [1, 2, 3];
            const someArray2 = [1, 2, 3];

            console.log(someArray === someArray2); // --> false
        </pre>
        <p>В случае же если присвоить переменной переменную, которой был присвоен массив, то в таком случае обе эти
            переменные будут равны тк хранят одну и ту же ссылку на массив памяти.</p>
        <pre>
            const someArray = [1, 2, 3];
            const someArray3 = someArray;

            console.log(someArray3 === someArray); //--> true
        </pre>
    </section>

    <h3 id="arrayVSobject">Массив против объекта</h3>

    <section>
        <img src="images/arrayVSobject.png" alt="arrayVSobject" width="644">
        <p>Отличием между массивом и объектом является прототип(__proto__). Прототип определяет применяемые методы для
            объекта/массива.</p>
    </section>


    <h3 id="readingValueOfArray">Чтение значения массива</h3>

    <section>
        <p>ТК у массивов индексы номерные(и если у объектов они тоже номерные), то вызывать их элементы точечной записью
            НЕЛЬЗЯ. В таком случае используются квадратные скобки:</p>
        <pre>
            const someArray = [1, true, 'a'];

            console.log(someArray); // --> [1, true, 'a']
            console.log(someArray[0]); // --> 1
            console.log(someArray[1]); // --> true
            console.log(someArray.length); // --> 3
            console.log(someArray['length']); // --> 3

            someArray.length = 7; // --> [1, true, 'a', empty × 4]
        </pre>
        <p>Длину массива можно менять в ручную, в таком случае появятся пустые элементы либо удалятся существующие, в
            зависимости от заданной длины массива, но делать это не рекомендуется:</p>
        <pre>
        someArray.length = 7; // --> [1, true, 'a', empty × 4]
        someArray.length = 2; // --> [1, true]
        </pre>
        <p>С помощью квадратных скобок так же можно менять элементы массива либо добавлять новый:</p>
        <pre>
            const someArray = [1, 2, 3, 4];
            someArray[2] = 'abc';

            console.log(someArray); // --> [1, 2, 'abc', 4]

            someArray[4] = true;

            console.log(someArray); // --> [1, 2, 'abc', 4, true]
            console.log(someArray.length); // --> 5
        </pre>
    </section>

    <h3 id="arrayMethods">Методы массивов</h3>

    <section>
        <p>Функции высшего порядка в массивах(функции/методы прототипов):</p>
        <ul>
            <li>push(someItem) - добавляет элемент в конец массива</li>
            <li>pop() - удаляет элемент с конца массива, возвращает удаленный элемент</li>
            <li>unshift(someItem) - добавляет элемент в начало массива</li>
            <li>shift() - удаляет элемент в начале массива, возвращает удаленный элемент</li>
            <li>forEach(item => {}) - перебирает элементы массива и выполняет с ними какие-то действия</li>
            <li>filter(item => {})</li>
            <li>map(item => {})</li>
            <li>...остальное ищи в __proto__</li>
        </ul>

        <p>Методы push(), pop(), unshift(), shift() - относятся к калечащим методом, они мутируют изначальный
            массив!!!</p>

        <p>push(someItem)</p>
        <pre>
            const someArray = [1, 2, 3];

            someArray.push(4);
            console.log(someArray); // --> [1, 2, 3, 4]
        </pre>

        <p>pop()</p>
        <pre>
            const someArray = [1, 2, 3];

            someArray.pop();
            console.log(someArray); // --> [1, 2]

            const removedElement = someArray.pop();
            console.log(someArray); // --> [1]
            console.log(removedElement); // --> 2
        </pre>

        <p>unshift(someItem)</p>
        <pre>
            const someArray = [1, 2, 3];

            someArray.unshift(true);
            console.log(someArray); // --> [true, 1, 2, 3]
        </pre>

        <p>shift()</p>
        <pre>
            const someArray = [1, 2, 3];

            someArray.shift();
            console.log(someArray); // --> [2, 3]

            const removedElement = someArray.shift();
            console.log(someArray); // --> [3]
            console.log(removedElement); // --> 2
        </pre>

        <p>Методы forEach(), filter(), map() - относятся к некалечащим, forEach проходит цикл по каждому элементу
            массива
            выполняя инструкцию и
            возвращает undefined, map так же проходит по каждому элементу массива, но уже возвращает новый массив,
            filter
            проходится по массиву и возвращает те элементы, которые удовлетворяют заданным условиям определенных if
            оператором.</p>
        <p>forEach(item => {})</p>
        <pre>
            const someArray = [1, 2, 3];

            someArray.forEach(elem => console.log(elem * 2)); // --> 2/ 4/ 6
            console.log(someArray); // --> [1, 2, 3]
        </pre>

        <p>map(item => {})</p>
        <pre>
            const someArray = [1, 2, 3];
            const newArray = someArray.map(el => el * 3);

            console.log(someArray); --> [1, 2, 3]
            console.log(newArray); --> [3, 6, 9]
        </pre>
    </section>

    <h3 id="objectDestructuring">Деструктуризация объектов</h3>

    <section>
        <p>При деструктуризации объектов в качестве переменной объявляются ключи из объекта, заключенные в фигурные
            скобки,
            далее данной конструкции присваивается исходный объект. В ходе данной операции мы получаем переменные,
            значениями
            которых являются значения одноименных ключей из объекта</p>
        <pre>
            const userProfile = {
                name: 'Dmitry',
                commentsQty: 23,
                hasSignedAgreement: false
            }

            const { name, commentsQty } = userProfile;
            const { hasSignedAgreement } = userProfile;

            console.log(name); // --> Dmitry
            console.log(commentsQty); // --> 23
            console.log(hasSignedAgreement); // --> false
        </pre>
    </section>

    <h3 id="arrayDestructuring">Деструктуризация массивов</h3>

    <section>
        <p>Деструктуризация массивов похожа на деструктуризацию объектов, но имя переменной теперь задается в
            деструтурирующих скобках самостоятельно и в строгой последовательности</p>
        <pre>
            const fruits = ['pineapple', 'apple', 'banana'];
            const [ , fruitTwo, fruitThree] = fruits;

            console.log(fruitTwo); // --> apple
            console.log(fruitThree); // --> banana
        </pre>
    </section>

    <h3 id="functionDestructuring">Деструктуризация в функциях</h3>

    <section>
        <p>В функциях деструктурируется блок параметров, далее при вызове функции, которой в качестве аргумента будет
            дан
            объект, благодаря деструктурированному блоку параметров разложенный на отдельные параметры</p>
        <pre>
            const userProfile = {
                name: 'Dmitry',
                commentsQty: 23,
                hasSignedAgreement: false
            }

            const userInfo = ({ name, commentsQty }) => {
                if (!commentsQty) {
                    return `User ${name} has no comments`
                }

                return `User ${name} has ${commentsQty} comments`
            }

            console.log(userInfo(userProfile)); // --> User Dmitry has 23 comments
        </pre>
    </section>

    <h3 id="ifElseConstruction">Условные конструкции</h3>

    <section>
        <ul>
            <li>if() {}</li>
            <li>if() {} else {}</li>
            <li>switch</li>
            <li>тернарный оператор (условие ? выражение1 : выражение2)</li>
        </ul>
    </section>

    <h3 id="ifOperator">Инструкция if() {}</h3>

    <section>
        <pre>
            if (Условие) {
                // Блок кода, выполняемый однократно, если Условие истинно
            }

            let value = 10;

            if (value > 5) {
                value += 20;
            }

            console.log(value); // --> 30

            const somePerson = {
                age: 21
            }

            if (!somePerson.name) {
                console.log('имя не указано')
            }
        </pre>
    </section>

    <h3 id="ifElse">Инструкция if() {} else {}</h3>

    <section>
        <pre>
            if (Условие) {
                // Блок кода, выполняемый однократно, если Условие истинно
            } else {
                // Блок кода, выполняемый однократно, если Условие ложно
            }

            let value = 10;

            if (value < 5) {
                value += 20;
            } else {
                value -= 20;
            }

            console.log(value); // --> -10
        </pre>
    </section>

    <h3 id="ifElseElseIf">Инструкция if() {} else if() {} else {}</h3>

    <section>
        <pre>
            if (Условие 1) {
                // Блок кода, выполняемый однократно, если Условие 1 истинно
            } else if (Условие 2) {
                // Блок кода, выполняемый однократно, если Условие 2 истинно
            } else {
                // Блок кода, выполняемый однократно, если предыдущие условия ложны
            }

            const age = 25;

            if (age >= 18) {
                console.log('is adult');
            } else if (age >= 12) {
                console.log('is teenager');
            } else {
                console.log('is child')
            }

            // аналог "if() {} else if() {} else {}":

            const age = 25;

            if (age >= 18) {
                console.log('is adult');
            }

            if (age >= 12 && age < 18) {
                console.log('is teenager');
            }

            if (age >= 12) {
                console.log('is adult');
            }
        </pre>
    </section>

    <h3 id="ifUsage">Использование условного оператора if в функциях</h3>

    <section>
        <pre>
            const sumPositiveNumbers = (a, b) => {
                if (typeof a !== 'number' || typeof b !== 'number') {
                    return 'One of the arguments is not a number';
                }

                if (a <= 0 || b <= 0) {
                    return 'Numbers are not positive';
                }

                return a + b;
            }

            console.log(sumPositiveNumbers ('a', true)); // --> One of the arguments is not a number
            console.log(sumPositiveNumbers (-10, 5)); // --> Numbers are not positive
            console.log(sumPositiveNumbers (3, 8)); // --> 11
        </pre>
    </section>

    <h3 id="switchInstruction">Инструкция switch</h3>

    <section>
        <p>синтаксис switch:</p>
        <pre>
            switch(Выражение) {
                case A:
                // Действия если Выражение === A
                break
                case B:
                // Действия если Выражение === B
                break
                default:
                // Действия по умолчанию
            }
        </pre>
        <p>Пример:</p>
        <pre>
            const month = 2;

            switch (month) {
                case 12:
                    console.log('Декабрь');
                break;
                case 1:
                    console.log('Январь');
                    break;
                case 2:
                    console.log('Февраль');
                    break;
                default:
                    console.log('Это не зимний месяц');
            } // --> Февраль
        </pre>
        <p>Если стоит задача выполнять разные действия исходя из значения переменной, то лучше всего использовать
            оператор
            switch.</p>
    </section>

    <h3 id="ternaryOperatorExpression">Тернарный оператор</h3>

    <section>
        <p>Конструкция с тернарным оператором - выражение</p>
        <p>Синтаксис - Условие ? expression_1 : expression_2, где Условие - любое выражение, expression_1 - выражение,
            результат
            которого возвращается, если условие правдиво, expression_2 - выражение, результат которого возвращается если
            условие ложно</p>
        <p>Рекомендованная форма записи:</p>
        <pre>
            Условие
                ? expression_1
                : expression_2
        </pre>
        <p>Пример:</p>
        <pre>
            const value = 11;

            value
                ? console.log('Условие истинно')
                : console.log('Условие ложно')

            //------------------------------------------------

            const value_1 = 11;
            const value_2 = 25;

            value_1 && value_2
                : someFunction_1(value_1, value_2)
                ? someFunction_2()

            //------------------------------------------------

            let value = 11;

            console.log(value >= 0 ? value : -value); // --> 11

            value = -5;

            const res = value >= 0 ? value : -value
            console.log(res); // --> 5
        </pre>
    </section>

    <h3 id="CallApplyBindDecorators">Методы call, apply, bind. Декораторы.</h3>

    <section>
        <div>
            <p>При вызове в функции this мы обращаемся к глобальному объекту window, через точку
                (this.someWindowParameter) мы можем обратиться к любому свойству существующему в объекте Window.</p>
            <pre>
                function someFunction() {
                    console.log(this)
                }
                someFunction() // Window{...}
            </pre>
            <p>В случае если мы хотим обратиться к свойству некоего объекта в данной функции, то нам к ней
                необходимо
                применить один из трех методов к этой функции, а именно:</p>
            <ul>
                <li>call(Object, arg1, arg2, argN, ...) - вызывает данную функцию привязывая контекст к свойствам
                    объекта, первым аргументом метода call передается нужный объект, последующими через запятую
                    аргументы функции к которой применяется метод call
                </li>
                <li>apply(Object, [arg1, arg2, argN, ...]) - вызывает данную функцию привязывая контекст к свойствам
                    объекта, первым аргументом метода apply передается нужный объект, вторым аргументом передается
                    массив, в котором через запятую расположены аргументы фунцкии
                </li>
                <li>bind(Object, arg1, arg2, argN, ...) - используется в случае если нам нужно вызвать функцию с
                    привязанным контекстом к конкретному объекту позже, работа с аргументами метода bind -
                    аналогична
                    методу call, для вызова функции с привязанным контекстом позже, результат отработки функции с
                    методом bind присваивается новой
                    переменной.
                </li>
            </ul>
            <pre>
                function helloWorldFunction(arg1,arg2) {
                    console.log(arg1 + arg2 + this.someValue)
                }

                const worldObject = {
                    someValue: "World"
                }

                helloWorldFunction.call(worldObject, "Hello", " "); // Hello World

                helloWorldFunction.apply(worldObject, ["Hello", " "]); // Hello World

                let someVariable = helloWorldFunction.bind(worldObject, "Hello", " ");
                someVariable(); //Hello World
            </pre>
            <p>Так же при работе с методом bind() в случае если у нас более одного аргумента в изначальной функции,
                то
                второй,
                третий и тд аргумент мы можем передавать уже при вызове новой функции:</p>
            <pre>
                let someAnotherVariable = helloWorldFunction.bind(worldObject, "Hello");
                someAnotherVariable(""); //HelloWorld
                someAnotherVariable(" "); //Hello World
            </pre>
            <p>Метод bind() можно использовать и без привязки к контексту определенного объекта:</p>
            <pre>
                function multiply(a, b) {
                   console.log(a * b)
                }

                let double = multiply.bind(null, 2);
                double(3); // 6
                double(5); // 10

                let triple = multiply.bind(null, 3);
                triple(3); // 9
                triple(5); // 15
            </pre>

            <p>Функция декоратор - специальная функция, которая в качестве аргумента принимает другую функцию и
                модифицирует ее поведение.</p>
            <pre>
                let printFuncResult = (x) => {
                    return x * 2;
                }

                const cacheDecorator = (func) => {
                    let cache = new Map();

                    return function (x) {
                        if (cache.has(x)) {
                            console.log("Value is from cache");
                            return cache.get(x)
                        }

                        let result = func(x);
                        cache.set(x, result);

                        return result;
                    }
                }

                printFuncResult = cacheDecorator(printFuncResult);
                printFuncResult(2); // 4
                printFuncResult(2); // 4 // Value is from cache
            </pre>
        </div>
    </section>

    <h3 id="cycles">Циклы</h3>

    <section>
        <p>Все циклы это инструкции.</p>
        <p>Для удобства перебора свойств объекта и элементов массива используют цикл.</p>
        <p>Типы циклов:</p>
        <ul>
            <li>for</li>
            <li>for ... in</li>
            <li>for ... of</li>
            <li>while</li>
            <li>do ... while</li>
        </ul>
    </section>

    <h3 id="cycleFor">Цикл for</h3>

    <section>
        <pre>
            for (начальная инструкция; условие; итерационное действие) {
                // блок кода выполняемый на каждой итерации
            }

            //-------------------------------------------------------

            for (let i = 0; i < 5; i++) {
                console.log(i);
            } // --> 0 1 2 3 4
        </pre>

        <p>Для перебора массивов циклы можно использовать, но не рекомендуется! Лучше всего использовать циклы высшего
            порядка массивов: forEach, map и reduce.</p>
        <pre>
            const someArray = ['first', 'second', 'third'];

            for (let i = 0; i < someArray.length; i++) {
                console.log('for: ' + someArray[i] + ' ' + [i]);
            } // --> for: first 0 second 1 third 2

            someArray.forEach((el, ind) => console.log('forEach: ' + el, ind)); // --> forEach: first 0 second 1 third 2
        </pre>
    </section>

    <h3 id="cycleWhile">Цикл while</h3>

    <section>
        <p>Если условие ложно то цикл while может ниразу не выполниться</p>
        <pre>
            while (условие) {
                // блок кода, выполняемый на каждой итерации
                пока условие правдиво
            }

            //---------------------------------------------

            let i = 0;

            while (i < 5) {
                console.log(i);
                i++;
            }
        </pre>
    </section>

    <h3 id="cycleDoWhile">Цикл do... while</h3>

    <section>
        <p>В отличии от цикла while цикл do ... while выполняется минимум один раз.</p>
        <pre>
            do {
                // блок кода, выполняемый на каждой итерации пока условие правдиво
            } while (условие)

            //----------------------------------------------------------------

            let i = 0;

            do {
                console.log(i);
                i++;
            } while (i < 5) // --> 0 1 2 3 4

            let i = 10;

            do {
                console.log(i);
                i++;
            } while (i < 5) // --> 10
        </pre>
    </section>

    <h3 id="cycleForKey">Цикл for key in object</h3>

    <section>
        <pre>
            for (key in Object) {
                // действия с каждым свойством объекта
                // Значение свойства - Object[key]
            }

            //---------------------------------------

            let someObject = {
                a: 10,
                b: true,
                c: 'abc'
            }

            for (key in someObject) {
                console.log(`${key}: ${someObject[key]}`);
            } // --> a: 10 b: true c: 'abc'
        </pre>
    </section>

    <h3 id="objectKeysValues">Методы keys и values для объектов(Object.keys и Object.values)</h3>

    <section>
        <p>С помощью Object.keys мы получаем массив из ключей объекта, а далее с помощью цикла forEach мы перебираем
            этот
            массив</p>
        <pre>
            let someObject = {
                a: 10,
                b: true,
                c: 'abc'
            }

            Object.keys(someObject).forEach(key => console.log(`${key}: ${someObject[key]}`));
            // --> a: 10 b: true c: 'abc'
        </pre>

        <p>С помощью Object.values мы получаем массив из значений объекта с помощью цикла forEach уже перебираем
            значения</p>
        <pre>
            let someObject = {
                a: 10,
                b: true,
                c: 'abc'
            }

            Object.values(someObject).forEach(value => console.log(value));
            // --> 10 true 'abc'
        </pre>
    </section>

    <h3 id="cycleForIn">Цикл for in для массивов</h3>

    <section>
        <pre>
            const someArray = [10, true, 'abc', null];

            for(const key in someArray) {
                console.log(`${key}: ${someArray[key]}`);
            } // --> 0: 10 1: true 2: abc 3: null
        </pre>
        <p>Это bad practice!</p>
    </section>

    <h3 id="cycleForOf">Цикл for of</h3>

    <section>
        <pre>
            for (Element of Iterable) {
                // Действия с определенным элементом
            }

            // for of для строк

            const someString = 'some string';

            for (const letter of someString) {
                console.log(letter);
            } // --> s o m e   s t r i n g

            // for of для массивов

            const someArray = [10, true, 'abc', null];

            for (const element of someArray) {
                console.log(element)
            } // --> 10 true abc null

            // for of НЕЛЬЗЯ использовать для объектов
        </pre>
        <p>Где Iterable это любое значение, которое можно перебирать</p>
    </section>

    <h3 id="modules">Модули</h3>

    <section>
        <p>Модули позволяют структурировать код и избегать дублирования блоков кода.</p>
        <p>Синтаксис:</p>
        <pre>
            // moduleOne.js

            const myName = () => {
                console.log('Dmitry');
            }

            export default myName;

            // moduleTwo.js

            import printMyName from './moduleOne.js'

            printMyName(); // --> Dmitry
        </pre>

        <p>Название экспортируемых переменных могут не совпадать если экспорт по умолчанию(export default)!</p>
        <p>Каждый модуль отдельная зона видимости переменных.</p>
    </section>

    <h3 id="someModulesExports">Несколько экспортов в модуле</h3>

    <section>
        <pre>
            // moduleOne.js

            const myName = () => {
                console.log('Dmitry');
            }

            const one = 1;
            const two = 'two';

            export {
                myName,
                one,
                two
            }

            // moduleTwo.js

            import {
                myName,
                one,
                two
            } from './moduleOne.js'

            console.log(myName);
            console.log(one);
            console.log(two);
        </pre>
        <p>Имена переменных при экспорте нескольких переменных ДОЛЖНЫ совпадать!</p>
        <p>Если нужно переименовать переменную, то при импорте рядом с переменной добавляют as и новое желаемое имя:</p>
        <pre>
            import {
                myName as printMyName,
                one,
                two
            } from './moduleOne.js'
        </pre>
    </section>

    <h3 id="moduleRules">Правила работы с модулями</h3>

    <section>
        <ol>
            <li>Модули должны быть одноцелевыми</li>
            <li>Располагайте все export инструкции внизу файла</li>
            <li>Располагайте все import инструкции сверху файла</li>
            <li>По возможности используйте export default</li>
        </ol>
    </section>

    <h3 id="classesAndPrototypes">Классы и прототипы</h3>

    <section>
        <p>Синтаксис классов появился в ES6 в 2015 году: "class ...", до этого классов не было вообще тк JS не является
            объектно ориентированным языком программирования.</p>
        <p>С помощью классов можно создавать прототипы(шаблоны) для объектов, и потом на основании этих прототипов
            создавать
            экземпляры объектов.</p>
        <p>Экземпляры могут иметь собственные свойства и методы, так же экземпляры наследуют свойства и методы
            прототипов</p>
        <p>Пример:</p>
        <pre>
            class Comment {
                constructor(text) {
                    this.text = text;
                    this.votesQty = 0;
                }

                upvote() {
                    this.votesQty += 1;
                }
            }

            const firstComment = new Comment('first comment');

            console.log(firstComment.votesQty); // --> 1
            firstComment.upvote();

            console.log(firstComment.votesQty); // --> 2
            firstComment.upvote();
        </pre>
    </section>

    <h3 id="callingInheritedMethods">Вызов унаследованных методов</h3>

    <section>
        <p>Метод "constructor()" вызывается только тогда когда необходимо создать новый экземпляр класса, метод
            "upvote()" и
            тд будет наследоваться каждым экземпляром этого класса.</p>
        <p>Оператор new вызывает функцию "constructor()", создавая новый экземпляр(в данном случае с именем
            "firstComment",
            класс Comment будет являться прототипом для данного экземпляра).</p>
    </section>

    <h3 id="prototypeChains">Цепочка прототипов</h3>

    <section>
        <p>Данный экземпляр будет наследовать все методы Object тк Comment является объектом и наследует все методы
            глобального класса Object.</p>
        <p>firstComment --> Comment --> Object</p>
    </section>

    <h3 id="inheritanceCheck">Проверка принадлежности</h3>

    <section>
        <p>Проверка принадлежности прототипу осуществляется при помощи оператора instanceof:</p>
        <pre>
            console.log(firstComment instanceof Comment); // --> true
            console.log(firstComment instanceof Object); // --> true
            console.log(firstComment instanceof Array); // --> false
        </pre>
    </section>

    <h3 id="objectCopyInheritanceCheck">Проверка принадлежности свойств экземпляру объекта</h3>

    <section>
        <p>Проверка принадлежности свойств экземпляру объекта осуществляется при помощи метода объекта
            "hasOwnProperty"</p>
        <pre>
            firstComment.hasOwnProperty('text'); // --> true
            firstComment.hasOwnProperty('votesQty'); // --> true
            firstComment.hasOwnProperty('upvote'); // --> false
            firstComment.hasOwnProperty('hasOwnProperty'); // --> false
        </pre>
    </section>

    <h3 id="creatingSomeCopies">Создание нескольких экземпляров</h3>

    <section>
        <pre>
            class Comment {
                constructor(text) {
                    this.text = text;
                    this.votesQty = 0;
                }

                upvote() {
                    this.votesQty += 1;
                }
            }

            const firstComment = new Comment('first comment');
            firstComment.upvote();

            const secondComment = new Comment('second comment');
            secondComment.upvote();

            const thirdComment = new Comment('third comment');
            thirdComment.upvote();
        </pre>
    </section>

    <h3 id="staticMethods">Статическе методы</h3>

    <section>
        <pre>
            class Comment {
                constructor(text) {
                    this.text = text;
                    this.votesQty = 0;
                }

                upvote() {
                    this.votesQty += 1;
                }

                static mergeComments(first, second) {
                    return `${first} ${second}`;
                }
            }

            Comment.mergeComments('First comment.', 'Second comment.'); // --> First comment. Second comment.
        </pre>
        <p>Статические методы доступны как свойства класса и не наследуются экземплярами класса!</p>
        <p>Object.keys, Object.values и Object.assign являются статическими методами. Эти методы не наследуются
            экземплярами
            Object, и доступны только для Object.</p>
    </section>

    <h3 id="classExtension">Расширение других классов</h3>

    <section>
        <pre>
            class NumbersArray extends Array {
                sum() {
                    return this.reduce((el, acc) => acc += el, 0)
                }
            }

            const myArray = new NumbersArray(2, 5, 7);

            console.log(myArray); // --> [2, 5, 7]
            myArray.sum(); // --> 14
        </pre>

        <p>В данном случае цепочка прототипов будет выглядеть так: myArray > NumbersArray > Array > Object</p>
    </section>

    <h3 id="prototypes">Что такое прототип</h3>

    <section>
        <p>Прототип - это JS объект, от которого другие объекты наследуют его свойства и методы. По умолчанию, у каждого
            объекта есть свой прототип и если у искомого объекта не хватает каких-либо свойств, то они ищутся в
            прототипе. В
            свою очередь, если и у ближайшего прототипа нет этих свойств, то они ищутся ниже в иерархии прототипов. По
            такому принципу происходит наследование прототипов в JS.</p>
        <pre>
        Comment.prototype === firstComment.__proto__; // --> true
        </pre>
    </section>

    <h3 id="stringAndNumberBehavior">Строки и числа ведут себя как объекты</h3>

    <section>
        <pre>
            const myName = 'Dmitry';
            console.log(myName); // --> Dmitry
            myName.toUpperCase(); // --> DMITRY

            const mySecondName = new String('Kiselman');
            mySecondName.toUpperCase(); // --> KISELMAN
        </pre>
        <p>Переменные myName и mySecondName имеют одинаковый набор методов!</p>
    </section>

    <h3 id="objectAndClassDecorators">Декораторы классов, объектов</h3>

    <section>
        <div>
            <p>Декоратор — это средство, которое позволяет обернуть одну функцию другой и расширить ее
                возможности.</p>
            <pre>
                //декораторы JS
                const myCar = {
                    fuel: '50%',
                    open: true,
                    freeSeats: 3,
                    isOpenAndFuel() {
                        return `${this.open} and ${this.fuel}`;
                    }
                }

                //функция декоратор
                function closeCar(car: typeof myCar) {
                    car.open = false;
                    console.log('close car');
                    return car;
                }

                function addFuel(car: typeof myCar){
                    car.fuel = '100%';
                    console.log('addFuel');
                    return car;
                }

                console.log(closeCar(addFuel(myCar)).isOpenAndFuel()); // первой срабатывает функция которая внутри: addFuel / close car / false and 100%

                //декораторы классов
                interface ICar {
                    fuel: string;
                    open: boolean;
                    freeSeats: number;
                    isOpenAndFuel: () => string;
                }

                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    freeSeats: number = 3;
                    isOpenAndFuel() {
                        return `${this.open} and ${this.fuel}`;
                    }
                }

                const newCar = new MyCar();
                console.log(closeCar(addFuel(newCar)));  // addFuel / close car / MyCar { fuel: '100%', open: false, freeSeats: 3 }
            </pre>
            <p>Декораторы функций — это такие же функции. Они принимают функцию в качестве аргумента и возвращают
                другую
                функцию, которая расширяет поведение функции-аргумента. Новая функция не изменяет функцию-аргумент,
                но
                использует ее в своем теле</p>
            <p>В функциональном программировании на JavaScript декораторы функций используются уже давно. Классы в
                JavaScript — на самом деле не классы.
                Синтаксис классов — это всего лишь синтаксический сахар для прототипов, который упрощает работу с
                ними.
                Напрашивается вывод, что классы — это просто функции.</p>
        </div>
    </section>

    <h3 id="promises">Промисы</h3>

    <section>
        <p>Промисы позволяют обрабатывать отложенные во времени события(промис - обещание предоставить результат
            позже).</p>
        <p>Промис может вернуть ошибку если результат предоставить невозможно.</p>
        <p>Состояние промиса:</p>
        <ul>
            <li>ожидание</li>
            <li>исполнен</li>
            <li>отклонен</li>
        </ul>
    </section>

    <h3 id="promiseCreationAndUsage">Создание и использование промисов</h3>

    <section>
        <pre>
            const somePromise = new Promise((resolve, reject) => {
                // Выполнение асинхронных действий

                /** Внутри этой функции нужно в результате вызвать одну из
                функций resolve или reject */
            });
        </pre>
        <p>Вновь созданный промис будет в состоянии ожидания (pending)</p>
        <p>Получение результата промиса:</p>
        <pre>
            somePromise
                .then(value => {
                    /** Действия в случае успешного исполнения промиса.
                    Значение value - это значение, переданное в вызове
                    функции resolve внутри промиса */
                })
                .catch(error => {
                    /** Действия в случае отклонение промиса.
                    Значение error - это значение, переданное в вызове
                    функции reject внутри промиса. */
                })
        </pre>
    </section>

    <h3 id="fetchApi">Получение данных с помощью fetch api</h3>

    <section>
        <pre>
        fetch('https://jsonplaceholder.typicode.com/todos')
           .then(response => {
               console.log(response);
               return response.json()
           }) // json возвращает еще один промис
           .then(json => console.log(json))
           .catch(error => console.error(error))
        </pre>
    </section>

    <h3 id="callingFetchInsidePromise">Вызов fetch внутри промиса</h3>

    <section>
        <pre>
            const getData = (url) =>
                new Promise((resolve, reject) =>
                    fetch(url)
                .then(response => response.json())
                .then(json => resolve(json))
            )

            getData('https://jsonplaceholder.typicode.com/todos')
                .then(data => console.log(data))
                .catch(error => console.log(error.message))
        </pre>
    </section>

    <h3 id="asyncAwait">Асинхронные функции(async/await)</h3>

    <section>
        <p>Асинхронная функция - это функция, которая вместо значения(строка/число/undefined), возвращает промис.</p>
        <p>async/await это специальный синтаксис для упрощения работы с промисами. Появился в ES6 в 2015 году.</p>
        <pre>
            async function asyncFunction() {
                // всегда возвращает промис
            }

            // альтернативный синтаксис -->

            const asyncFunction = async() => {
                // всегда возвращает промис
            }

            //---------------------------

            const asyncFunction = async() => {
                return 'Success!'
            }

            asyncFunction();

            asyncFunction()
                .then(value => console.log(value));

            const asyncFunction = async() => {
                throw new Error('There was an error!')
            }

            asyncFunction()
                .then(value => console.log(value))
                .catch(error => console.log(error.message));
        </pre>
    </section>

    <h3 id="awaitInAJAX">Использование await внутри асинхронных функций</h3>

    <section>
        <p>ключевое слово await можно использовать только в функциях с async</p>
        <pre>
            const asyncFunction = async() => {
                await < Promise >
            }

            asyncFunction();

            // пример:

            const timerPromise = () =>
                new Promise((resolve, reject) =>
                    setTimeout(() => resolve(), 2000));

            const asyncFunction = async() => {
                console.log('Timer starts');

                const startTime = performance.now();

                await timerPromise();

                const endTime = performance.now();

                console.log('Timer ended', endTime - startTime);
            }

            asyncFunction();
        </pre>
    </section>

    <h3 id="asyncAwaitUsage">Переход(миграция) с промисов на async/await</h3>

    <section>
        <pre>
            const getData = async(url) => {
                const res = await fetch(url);
                const json = await res.json();
                return json;
            }

            const url = 'https://jsonplaceholder.typicode.com/todos';

            try {
                const data = await getData(url);
                console.log(data);
            } catch(error) {
                console.log(error.message);
            }
        </pre>
    </section>

    <h3 id="keyPrinciplesInAsyncAwait">Ключевые принципы в async/await</h3>

    <section>
        <ol>
            <li>async/await - это синтаксическая надстройка над промисами</li>
            <li>await синтаксис возможен только внутри async функций</li>
            <li>async функция всегда возвращает Promise</li>
            <li>async функция ожидает результата инструкции await и не выполняет последующие инструкции(но не
                блокируется
                выполнение других частей приложения)
            </li>
        </ol>
    </section>

    <div>
        <h2>Общая теория JavaScript</h2>

        <button id="languageSwitcher">Eng/Rus</button>

        <h3 id="JSbasicsForEmployment0">
            <div class="engJSTheory">What are the possible ways to create objects in JavaScript</div>
            <div class="ruJSTheory">Способы создания объектов в JS</div>
        </h3>

        <section>
            <div>
                <ol>
                    <li>
                        <h4 class="engJSTheory">Object constructor:</h4>
                        <h4 class="ruJSTheory">Конструктор объекта:</h4>
                        <p class="engJSTheory">The simplest way to create an empty object is using the Object
                            constructor.
                            Currently this approach is not recommended.
                        </p>
                        <p class="ruJSTheory">Самый простой способ создать пустой объект — использовать конструктор
                            Object. В настоящее время
                            этот подход не рекомендуется.
                        </p>
                        <pre>
                        var object = new Object();
                    </pre>
                        <p class="engJSTheory">The Object() is a built-in constructor function so "new" keyword is
                            not
                            required. the above can
                            be written as:
                        </p>
                        <p class="ruJSTheory">Object() — это встроенная функция-конструктор, поэтому ключевое слово
                            «new» не требуется.
                            Вышеизложенное можно записать как:
                        </p>
                        <pre>
                        var object = Object();
                    </pre>
                    </li>
                    <li>
                        <h4 class="engJSTheory">Object's create method:</h4>
                        <h4 class="ruJSTheory">Метод создания объекта:</h4>
                        <p class="engJSTheory">The create method of Object creates a new object by passing the
                            prototype
                            object as a
                            parameter
                        </p>
                        <p class="ruJSTheory">Метод create объекта Object создает новый объект, передавая
                            объект-прототип
                            в качестве
                            параметра.
                        </p>
                        <pre>
                        var object = Object.create(null);
                    </pre>
                    </li>
                    <li>

                        <h4 class="engJSTheory">Object literal syntax:</h4>
                        <h4 class="ruJSTheory">Синтаксис литерала объекта:</h4>
                        <p class="engJSTheory">The object literal syntax (or object initializer), is a
                            comma-separated
                            set
                            of name-value pairs
                            wrapped in curly braces.
                        </p>
                        <p class="ruJSTheory">Синтаксис литерала объекта (или инициализатор объекта) представляет
                            собой
                            набор пар
                            имя-значение, разделенных запятыми, заключенных в фигурные скобки.
                        </p>
                        <pre>
                        var object = {
                            name: "Sudheer",
                            age: 34
                        };

                        Object literal property values can be of any data type, including array, function, and nested object.
                    </pre>
                    </li>
                    <li>
                        <h4 class="engJSTheory">Function constructor:</h4>
                        <h4 class="ruJSTheory">Конструктор функций:</h4>
                        <p class="engJSTheory">Create any function and apply the new operator to create object
                            instances</p>
                        <p class="ruJSTheory">Создайте любую функцию и примените "new" оператор для создания
                            экземпляров
                            объектов.
                        </p>
                        <pre>
                            function Person(name) {
                                this.name = name;
                                this.age = 21;
                            }
                            var object = new Person("Sudheer");
                        </pre>
                    </li>
                    <li>
                        <h4 class="engJSTheory">Function constructor with prototype:</h4>
                        <h4 class="ruJSTheory">Конструктор функции с прототипом:</h4>
                        <p class="engJSTheory">This is similar to function constructor, but it uses prototype for
                            their
                            properties and
                            methods,
                        </p>
                        <p class="ruJSTheory">Это похоже на конструктор функций, но он использует прототип для своих
                            свойств и методов.
                        </p>
                        <pre>
                            function Person() {}
                            Person.prototype.name = "Sudheer";
                            var object = new Person();
                        </pre>
                        <p class="engJSTheory">This is equivalent to an instance created with an object create
                            method
                            with
                            a function prototype
                            and then call that function with an instance and parameters as arguments.
                        </p>
                        <p class="ruJSTheory">Это эквивалентно экземпляру, созданному с помощью метода создания
                            объекта
                            с
                            прототипом функции,
                            а затем вызову этой функции с экземпляром и параметрами в качестве аргументов.
                        </p>
                        <pre>
                            function func() {}

                            new func(x, y, z);

                            //or:

                            // Create a new instance using function prototype.
                            var newInstance = Object.create(func.prototype)

                            // Call the function
                            var result = func.call(newInstance, x, y, z),

                            // If the result is a non-null object then use it otherwise just use the new instance.
                            console.log(result && typeof result === 'object' ? result : newInstance);
                    </pre>
                    </li>
                    <li>
                        <h4 class="engJSTheory">ES6 Class syntax:</h4>
                        <h4 class="ruJSTheory">Синтаксис Классов в ES6</h4>
                        <p class="engJSTheory">ES6 introduces class feature to create the objects</p>
                        <p class="ruJSTheory">ES6 представляет функцию класса для создания объектов</p>
                        <pre>
                            class Person {
                                constructor(name) {
                                    this.name = name;
                                }
                            }

                            var object = new Person("Sudheer");
                    </pre>
                    </li>
                    <li>
                        <h4>Singleton pattern(функция одноразового объявления):</h4>
                        <p class="engJSTheory">A Singleton is an object which can only be instantiated one time.
                            Repeated
                            calls to its
                            constructor return the same instance and this way one can ensure that they don't
                            accidentally
                            create multiple instances.
                        </p>
                        <p class="ruJSTheory">Синглтон — это объект, экземпляр которого может быть создан только
                            один
                            раз.
                            Повторные вызовы его конструктора возвращают один и тот же экземпляр, и таким образом
                            можно
                            гарантировать,
                            что они случайно не создадут несколько экземпляров.
                        </p>
                        <pre>
                            var object = new (function () {
                                this.name = "Sudheer";
                            })();
                    </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment1">
            <div class="engJSTheory">What is a prototype chain</div>
            <div class="ruJSTheory">Что такое цепочка прототипов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Prototype chaining is used to build new types of objects based on existing
                    ones.
                    It
                    is similar to
                    inheritance in a class based language.
                </p>
                <p class="ruJSTheory">Цепочка прототипов используется для создания новых объектов на основе
                    существующих.
                    Это похоже на
                    наследование в языках, основанных на классах.
                </p>
                <p class="engJSTheory">The prototype on object instance is available through
                    Object.getPrototypeOf(object)
                    or __proto__
                    property whereas prototype
                    on constructors function is available through Object.prototype.
                </p>
                <p class="ruJSTheory">Прототип экземпляра объекта доступен через свойство
                    Object.getPrototypeOf(object)
                    или __proto__,
                    тогда как функция прототипа в конструкторах доступна через Object.prototype.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment2">
            <div class="engJSTheory">What is the difference between Call, Apply and Bind</div>
            <div class="ruJSTheory">В чем разница между Call, Apply и Bind</div>
        </h3>

        <section>
            <div>

                <p class="engJSTheory">The difference between Call, Apply and Bind can be explained with below
                    examples,
                </p>
                <p class="ruJSTheory">Разницу между Call, Apply и Bind можно объяснить на примерах ниже:</p>
                <p class="engJSTheory">Call: The call() method invokes a function with a given this value and
                    arguments
                    provided one by
                    one
                </p>
                <p class="ruJSTheory">Call: метод call() вызывает функцию с заданным значением и аргументами,
                    предоставленными один за
                    другим.
                </p>
                <pre>
                    var employee1 = { firstName: "John", lastName: "Rodson" };
                    var employee2 = { firstName: "Jimmy", lastName: "Baily" };

                    function invite(greeting1, greeting2) {
                        console.log(
                            greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
                        );
                    }

                    invite.call(employee1, "Hello", "How are you?"); // Hello John Rodson, How are you?
                    invite.call(employee2, "Hello", "How are you?"); // Hello Jimmy Baily, How are you?
                </pre>
                <p class="engJSTheory">Apply: Invokes the function with a given this value and allows you to pass in
                    arguments as an
                    array
                </p>
                <p class="ruJSTheory">Apply: вызывает функцию с заданным значением и позволяет передавать аргументы
                    в
                    виде
                    массива.
                </p>
                <pre>
                    var employee1 = { firstName: "John", lastName: "Rodson" };
                    var employee2 = { firstName: "Jimmy", lastName: "Baily" };

                    function invite(greeting1, greeting2) {
                        console.log(
                            greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
                        );
                    }

                    invite.apply(employee1, ["Hello", "How are you?"]); // Hello John Rodson, How are you?
                    invite.apply(employee2, ["Hello", "How are you?"]); // Hello Jimmy Baily, How are you?
                </pre>
                <p class="engJSTheory">bind: returns a new function, allowing you to pass any number of
                    arguments</p>
                <p class="ruJSTheory">bind: возвращает новую функцию, позволяющую передавать любое количество
                    аргументов.
                </p>
                <pre>
                    var employee1 = { firstName: "John", lastName: "Rodson" };
                    var employee2 = { firstName: "Jimmy", lastName: "Baily" };

                    function invite(greeting1, greeting2) {
                        console.log(
                            greeting1 + " " + this.firstName + " " + this.lastName + ", " + greeting2
                        );
                    }

                    var inviteEmployee1 = invite.bind(employee1);
                    var inviteEmployee2 = invite.bind(employee2);
                    inviteEmployee1("Hello", "How are you?"); // Hello John Rodson, How are you?
                    inviteEmployee2("Hello", "How are you?"); // Hello Jimmy Baily, How are you?
            </pre>
                <p class="engJSTheory">Call and apply are pretty interchangeable. Both execute the current function
                    immediately.
                    You need to decide whether it’s easier to send in an array or a comma separated list of
                    arguments.
                    You can remember by treating Call is for comma (separated list) and Apply is for Array.
                </p>
                <p class="ruJSTheory">Call и apply довольно взаимозаменяемы. Оба немедленно выполняют текущую
                    функцию.
                    Вам нужно решить, что проще использовать в аргументах: массив или список аргументов, разделенных
                    запятыми.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment3">
            <div class="engJSTheory">What is JSON and its common operations</div>
            <div class="ruJSTheory">Что такое JSON и его общие операции</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JSON is a text-based data format following JavaScript object syntax, which
                    was popularized by Douglas Crockford. It is useful when you want to transmit data across
                    a network and it is basically just a text file with an extension of .json, and a MIME
                    type of application/json
                </p>
                <p class="ruJSTheory">JSON — это текстовый формат данных, соответствующий синтаксису объектов
                    JavaScript, популяризированный Дугласом Крокфордом. Это полезно, когда вы хотите передавать
                    данные по сети и по сути это просто текстовый файл с расширением .json
                    и MIME-типом application/json.</p>

                <p class="engJSTheory">Parsing: Converting a string to a native object</p>
                <p class="ruJSTheory">Парсинг: преобразование строки в собственный объект</p>
                <pre>
                JSON.parse(text);
            </pre>
                <p class="engJSTheory">Stringification: converting a native object to a string so it can be
                    transmitted
                    across the network
                </p>
                <p class="ruJSTheory">Стрингификация: преобразование собственного объекта в строку для его передачи
                    по
                    сети.
                </p>
                <pre>
                JSON.stringify(object);
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment4">
            <div class="engJSTheory">What is the purpose of the array slice method</div>
            <div class="ruJSTheory">Какова цель метода массивов "slice"</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The slice() method returns the selected elements in an array as a new array
                    object.
                    It selects the
                    elements starting at the given start argument, and ends at the given optional end argument
                    without
                    including the last element. If you omit the second argument then it selects till the end.
                </p>
                <p class="ruJSTheory">Метод slice() возвращает выбранные элементы массива как новый объект массива.
                    Он
                    выбирает элементы,
                    начинающиеся с данного начального аргумента, и заканчиваются данным необязательным конечным
                    аргументом,
                    не включая последний элемент. Если вы опустите второй аргумент, он будет выбирать до конца.
                </p>
                <pre>
                    let arrayIntegers = [1, 2, 3, 4, 5];
                    let arrayIntegers1 = arrayIntegers.slice(0, 2); // returns [1,2]
                    let arrayIntegers2 = arrayIntegers.slice(2, 3); // returns [3]
                    let arrayIntegers3 = arrayIntegers.slice(4); //returns [5]
            </pre>
                <p class="engJSTheory">Note: Slice method won't mutate the original array, but it returns the subset
                    as
                    a
                    new array.
                </p>
                <p class="ruJSTheory">Примечание. Метод Slice не изменяет исходный массив, но возвращает
                    подмножество
                    как
                    новый массив.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment5">
            <div class="engJSTheory">What is the purpose of the array splice method</div>
            <div class="ruJSTheory">Какова цель метода массивов "splice"</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The splice() method is used either adds/removes items to/from an array, and
                    then
                    returns the removed
                    item. The first argument specifies the array position for insertion or deletion whereas the
                    optional
                    second argument indicates the number of elements to be deleted. Each additional argument is
                    added to
                    the
                    array.
                </p>
                <p class="ruJSTheory">Метод splice() используется либо для добавления/удаления элементов в/из
                    массива, а
                    затем для возврата
                    удаленного элемента. Первый аргумент указывает позицию массива для вставки или удаления, тогда
                    как
                    необязательный второй аргумент указывает количество элементов, которые необходимо удалить.
                    Каждый
                    дополнительный аргумент добавляется в массив.
                </p>
                <pre>
                    let arrayIntegersOriginal1 = [1, 2, 3, 4, 5];
                    let arrayIntegersOriginal2 = [1, 2, 3, 4, 5];
                    let arrayIntegersOriginal3 = [1, 2, 3, 4, 5];

                    let arrayIntegers1 = arrayIntegersOriginal1.splice(0, 2); // returns [1, 2]; original array: [3, 4, 5]
                    let arrayIntegers2 = arrayIntegersOriginal2.splice(3); // returns [4, 5]; original array: [1, 2, 3]
                    let arrayIntegers3 = arrayIntegersOriginal3.splice(3, 1, "a", "b", "c"); //returns [4]; original array: [1, 2, 3, "a", "b", "c", 5]
            </pre>
                <p class="engJSTheory">Note: Splice method modifies the original array and returns the deleted
                    array.
                </p>
                <p class="ruJSTheory">Примечание: Метод Splice изменяет(мутирует) исходный массив и возвращает
                    удаленный
                    массив.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment6">
            <div class="engJSTheory">What is the difference between slice and splice</div>
            <div class="ruJSTheory">В чем разница между slice и splice</div>
        </h3>

        <section>
            <div>
                <table class="jsTheoryTable">
                    <caption>
                        <div class="engJSTheory">Some of the major difference in a tabular form</div>
                        <div class="ruJSTheory">Некоторые основные различия в табличной форме</div>
                    </caption>
                    <thead>
                    <tr>
                        <td>Slice</td>
                        <td>Splice</td>
                    </tr>
                    </thead>
                    <tr>
                        <td>
                            <div class="engJSTheory">Doesn't modify the original array(immutable)</div>
                            <div class="ruJSTheory">Не изменяет исходный массив (иммутабельный)</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Modifies the original array(mutable)</div>
                            <div class="ruJSTheory">Изменяет исходный массив (мутаьельный)</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Returns the subset of original array</div>
                            <div class="ruJSTheory">Возвращает подмножество исходного массива</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Returns the deleted elements as array</div>
                            <div class="ruJSTheory">Возвращает удаленные элементы в виде массива</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Used to pick the elements from array</div>
                            <div class="ruJSTheory">Используется для выбора элементов из массива</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Used to insert or delete elements to/from array</div>
                            <div class="ruJSTheory">Используется для вставки или удаления элементов в/из массива.
                            </div>
                        </td>
                    </tr>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment7">
            <div class="engJSTheory">How do you compare Object and Map</div>
            <div class="ruJSTheory">Сходства и различия Object и Map</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Objects are similar to Maps in that both let you set keys to values, retrieve
                    those
                    values, delete
                    keys, and detect whether something is stored at a key. Due to this reason, Objects have been
                    used as
                    Maps historically. But there are important differences that make using a Map preferable in
                    certain
                    cases.
                </p>
                <p class="ruJSTheory">Objects похожи на Map в том, что оба позволяют устанавливать ключи в значения,
                    извлекать эти
                    значения, удалять ключи и определять, хранится ли что-то по ключу. По этой причине объекты
                    исторически
                    использовались в качестве Map. Но есть важные различия, которые делают использование Map
                    предпочтительнее в определенных случаях.
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">The keys of an Object are Strings and Symbols, whereas they can be
                            any
                            value for a Map,
                            including functions, objects, and any primitive.
                        </div>
                        <div class="ruJSTheory">Ключами объекта являются строки и символы, тогда как для Map они
                            могут
                            быть
                            любым значением,
                            включая функции, объекты и любые примитивы.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">The keys in Map are ordered while keys added to Object are not.
                            Thus,
                            when
                            iterating over it, a
                            Map object returns keys in order of insertion.
                        </div>
                        <div class="ruJSTheory">Ключи в Map упорядочены, а ключи, добавленные в Object, — нет. Таким
                            образом, при переборе
                            объект Map возвращает ключи в порядке вставки.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">You can get the size of a Map easily with the size property, while
                            the
                            number of properties in
                            an Object must be determined manually.
                        </div>
                        <div class="ruJSTheory">Вы можете легко получить размер Map с помощью свойства size, тогда
                            как
                            количество свойств в
                            объекте необходимо определять вручную.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">A Map is an iterable and can thus be directly iterated, whereas
                            iterating
                            over an Object
                            requires obtaining its keys in some fashion and iterating over them.
                        </div>
                        <div class="ruJSTheory">Map является итерируемой, и поэтому ее можно перебирать напрямую,
                            тогда
                            как
                            итерация по объекту
                            требует каким-то образом получить его ключи и перебрать их.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">An Object has a prototype, so there are default keys in the map
                            that
                            could
                            collide with your
                            keys if you're not careful.
                            As of ES5 this can be bypassed by using map = Object.create(null), but this is seldom
                            done.
                        </div>
                        <div class="ruJSTheory">У объекта есть прототип, поэтому у Map есть ключи по умолчанию,
                            которые
                            могут столкнуться с
                            вашими ключами, если вы не будете осторожны.
                            Начиная с ES5, это можно обойти, используя map = Object.create(null), но это делается
                            редко.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">A Map may perform better in scenarios involving frequent addition
                            and
                            removal of key pairs.
                        </div>
                        <div class="ruJSTheory">Map может работать лучше в сценариях, связанных с частым добавлением
                            и
                            удалением пар ключей.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment8">
            <div class="engJSTheory">What is the difference between == and === operators</div>
            <div class="ruJSTheory">В чем разница между операторами == и ===</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript provides both strict(===, !==) and type-converting(==, !=)
                    equality
                    comparison. The strict
                    operators take type of variable in consideration, while non-strict operators make type
                    correction/conversion based upon values of variables. The strict operators follow the below
                    conditions
                    for different types,
                </p>
                <p class="ruJSTheory">
                    JavaScript обеспечивает как строгое (===, !==), так и преобразование типов (==, !=) сравнение на
                    равенство. Строгие операторы учитывают тип переменной, тогда как нестрогие операторы выполняют
                    коррекцию/преобразование типа на основе значений переменных. Строгие операторы следуют
                    приведенным
                    ниже
                    условиям для разных типов:
                </p>
                <ol>
                    <li>
                        <div class="engJSTheory">Two strings are strictly equal when they have the same sequence of
                            characters, same length, and
                            same characters in corresponding positions.
                        </div>
                        <div class="ruJSTheory">Две строки строго равны, если они имеют одинаковую
                            последовательность
                            символов, одинаковую
                            длину и одинаковые символы в соответствующих позициях.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Two numbers are strictly equal when they are numerically equal.
                            i.e,
                            Having
                            the same number
                            value. There are two special cases in this,
                        </div>
                        <div class="ruJSTheory">Два числа строго равны, если они численно равны. т. е. имеющие
                            одинаковое
                            числовое значение.
                            Здесь есть два особых случая:
                        </div>
                        <ul>
                            <li>
                                <div class="engJSTheory">NaN is not equal to anything, including NaN.</div>
                                <div class="ruJSTheory">NaN не равен ничему, включая NaN</div>
                            </li>
                            <li>
                                <div class="engJSTheory">Positive and negative zeros are equal to one another.</div>
                                <div class="ruJSTheory">Положительные и отрицательные нули равны друг другу.</div>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <div class="engJSTheory">Two Boolean operands are strictly equal if both are true or both
                            are
                            false.
                        </div>
                        <div class="ruJSTheory">Два логических операнда строго равны, если оба истинны или оба
                            ложны.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Two objects are strictly equal if they refer to the same Object.
                        </div>
                        <div class="ruJSTheory">Два объекта строго равны, если они ссылаются на один и тот же
                            объект.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Null and Undefined types are not equal with ===, but equal with ==.
                            i.e,
                            null===undefined -->
                            false but null==undefined --> true
                        </div>
                        <div class="ruJSTheory">Типы Null и Undefine не равны ===, но равны ==. т.е. null ===
                            undefined
                            -->
                            false, но null ==
                            undefined --> true
                        </div>
                    </li>
                </ol>
                <pre>
                    0 == false   // true
                    0 === false  // false
                    1 == "1"     // true
                    1 === "1"    // false
                    null == undefined // true
                    null === undefined // false
                    '0' == false // true
                    '0' === false // false
                    []==[] or []===[] //false, refer different objects in memory
                    {}=={} or {}==={} //false, refer different objects in memory
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment9">
            <div class="engJSTheory">What are lambda or arrow functions</div>
            <div class="ruJSTheory">Что такое лямбда или стрелочные функции?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An arrow function is a shorter syntax for a function expression and does not
                    have
                    its own this,
                    arguments, super, or new.target. These functions are best suited for non-method functions, and
                    they
                    cannot be used as constructors.
                </p>
                <p class="ruJSTheory">Стрелочная функция представляет собой более короткий синтаксис функционального
                    выражения и не имеет
                    собственных аргументов this, super или new.target. Эти функции лучше всего подходят для функций,
                    не
                    являющихся методами, и их нельзя использовать в качестве конструкторов.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment10">
            <div class="engJSTheory">What is a first class function</div>
            <div class="ruJSTheory">Что такое функция первого класса</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In Javascript, functions are first class objects. First-class functions means
                    when
                    functions in that
                    language are treated like any other variable.
                </p>
                <p class="ruJSTheory">В Javascript функции являются объектами первого класса. Функции первого класса
                    означают, что функции на
                    этом языке рассматриваются как любая другая переменная.
                </p>

                <p class="engJSTheory">For example, in such a language, a function can be passed as an argument to
                    other
                    functions, can be
                    returned by another function and can be assigned as a value to a variable. In the below
                    example, handler functions assigned to a listener
                </p>
                <p class="ruJSTheory">Например, в таком языке функция может передаваться в качестве аргумента другим
                    функциям, может быть
                    возвращена другой функцией и может быть присвоена как значение переменной. В приведенном ниже
                    примере
                    функции-обработчики, назначенные прослушивателю:
                </p>

                <pre>
                const handler = () => console.log("This is a click handler function");
                document.addEventListener("click", handler);
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment11">
            <div class="engJSTheory">What is a first order function</div>
            <div class="ruJSTheory">Что такое функция первого порядка</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A first-order function is a function that doesn’t accept another function as
                    an
                    argument and doesn’t
                    return a function as its return value.
                </p>
                <p class="ruJSTheory">Функция первого порядка — это функция, которая не принимает другую функцию в
                    качестве аргумента и не
                    возвращает функцию в качестве возвращаемого значения.
                </p>

                <pre>
                const firstOrder = () => console.log("I am a first order function!");
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment12">
            <div class="engJSTheory">What is a higher order function</div>
            <div class="ruJSTheory">Что такое функция высшего порядка</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A higher-order function is a function that accepts another function as an
                    argument
                    or returns a
                    function as a return value or both.
                </p>
                <p class="ruJSTheory">Функция высшего порядка — это функция, которая принимает другую функцию в
                    качестве
                    аргумента или
                    возвращает функцию в качестве возвращаемого значения, или и то, и другое.
                </p>

                <pre>
                    const firstOrderFunc = () => console.log("Hello, I am a First order function");
                    const higherOrder = (ReturnFirstOrderFunc) => ReturnFirstOrderFunc();
                    higherOrder(firstOrderFunc);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment13">
            <div class="engJSTheory">What is a unary function</div>
            <div class="ruJSTheory">Что такое унарная функция</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A unary function (i.e. monadic) is a function that accepts exactly one
                    argument.
                    It
                    stands for a single argument accepted by a function.
                </p>
                <p class="ruJSTheory">Унарная функция (т.е. монадическая) — это функция, которая принимает ровно
                    один
                    аргумент. Он обозначает один аргумент, принимаемый функцией.
                </p>

                <pre>
                    const unaryFunction = (a) => console.log(a + 10); // Add 10 to the given argument and display the value
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment14">
            <div class="engJSTheory">What is the currying function</div>
            <div class="ruJSTheory">Что такое функция каррирования</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">
                    Currying is the process of taking a function with multiple arguments and turning it into a
                    sequence
                    of
                    functions each with only a single argument. Currying is named after a mathematician Haskell
                    Curry.
                    By
                    applying currying, an n-ary function turns into a unary function.
                </p>
                <p class="ruJSTheory">
                    Каррирование — это процесс преобразования функции с несколькими аргументами в последовательность
                    функций, каждая из которых имеет только один аргумент. Карринг назван в честь математика
                    Хаскелла
                    Карри.
                    Применяя каррирование, n-арная функция превращается в унарную функцию.
                </p>

                <pre>
                    //example

                    const multiArgFunction = (a, b, c) => a + b + c;
                    console.log(multiArgFunction(1, 2, 3)); // 6

                    const curryUnaryFunction = (a) => (b) => (c) => a + b + c;
                    curryUnaryFunction(1); // returns a function: b => c =>  1 + b + c
                    curryUnaryFunction(1)(2); // returns a function: c => 3 + c
                    curryUnaryFunction(1)(2)(3); // returns the number 6

                    //example

                    function sum(a, b, c) {
                        return a + b + c;
                    }

                    function curry(fn) {
                        return function curried(...args) {
                            if (args.length >= fn.length) {
                                return fn.apply(this, args);
                            }
                            return function (...newArgs) {
                                return curried.apply(this, args.concat(newArgs));
                            };
                        };
                    }

                    const curriedSum = curry(sum);

                    console.log(curriedSum(2, 3, 4));
                    console.log(curriedSum(2)(3)(4));
                </pre>

                <p class="engJSTheory">Curried functions are great to improve code reusability and functional
                    composition.
                </p>
                <p class="ruJSTheory">Каррированные функции отлично подходят для улучшения повторного использования
                    кода
                    и
                    функциональной композиции.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment15">
            <div class="engJSTheory">What is a pure function</div>
            <div class="ruJSTheory">Что такое чистая функция</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A Pure function is a function where the return value is only determined by
                    its
                    arguments without any
                    side effects. i.e, If you call a function with the same arguments 'n' number of times and 'n'
                    number
                    of
                    places in the application then it will always return the same value.
                </p>
                <p class="ruJSTheory">Чистая функция — это функция, возвращаемое значение которой определяется
                    только ее
                    аргументами без
                    каких-либо побочных эффектов. т. е. если вы вызываете функцию с одинаковыми аргументами «n»
                    количество
                    раз и «n» количество мест в приложении, она всегда будет возвращать одно и то же значение.
                </p>

                <pre>
                    //Impure
                    let numberArray = [];
                    const impureAddNumber = (number) => numberArray.push(number);

                    //Pure
                    const pureAddNumber = (number) => (argNumberArray) => argNumberArray.concat([number]);

                    //Display the results
                    console.log(impureAddNumber(6)); // returns 1
                    console.log(numberArray); // returns [6]
                    console.log(pureAddNumber(7)(numberArray)); // returns [6, 7]
                    console.log(numberArray); // returns [6]
                </pre>

                <p class="engJSTheory">As per the above code snippets, the Push function is impure itself by
                    altering
                    the
                    array and returning
                    a push number index independent of the parameter value, whereas Concat on the other hand takes
                    the
                    array
                    and concatenates it with the other array producing a whole new array without side effects. Also,
                    the
                    return value is a concatenation of the previous array.
                </p>
                <p class="ruJSTheory">Согласно приведенным выше фрагментам кода, функция Push сама по себе является
                    нечистой, изменяя массив
                    и возвращая индекс номера push, независимый от значения параметра, тогда как Concat, с другой
                    стороны,
                    берет массив и объединяет его с другим массивом, создавая совершенно новый массив. без побочных
                    эффектов. Кроме того, возвращаемое значение представляет собой объединение предыдущего массива.
                </p>

                <p class="engJSTheory">Remember that Pure functions are important as they simplify unit testing
                    without
                    any side effects and
                    no need for dependency injection. They also avoid tight coupling and make it harder to break
                    your
                    application by not having any side effects. These principles are coming together with the
                    Immutability
                    concept of ES6: giving preference to const over let usage.
                </p>
                <p class="ruJSTheory">Помните, что чистые функции важны, поскольку они упрощают модульное
                    тестирование
                    без
                    каких-либо
                    побочных эффектов и отсутствия необходимости внедрения зависимостей. Они также избегают жесткой
                    связи и
                    затрудняют выход из строя вашего приложения, не вызывая каких-либо побочных эффектов. Эти
                    принципы
                    сочетаются с концепцией неизменности ES6: предпочтение отдается использованию const, а не let.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment16">
            <div class="engJSTheory">What is the purpose of the let keyword</div>
            <div>Какова цель ключевого слова let</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The let statement declares a block scope local variable. Hence the variables
                    defined with let keyword
                    are limited in scope to the block, statement, or expression on which it is used. Whereas
                    variables
                    declared with the var keyword used to define a variable globally, or locally to an entire
                    function
                    regardless of block scope.
                </p>
                <p class="ruJSTheory">Оператор let объявляет локальную переменную области действия блока(области
                    видимости). Следовательно, переменные,
                    определенные с помощью ключевого слова let, ограничены в области действия блоком, оператором или
                    выражением, в котором они используются. В то время как переменные, объявленные с помощью
                    ключевого
                    слова
                    var, используются для определения переменной глобально или локально для всей функции независимо
                    от
                    области действия блока.
                </p>

                <pre>
                    let counter = 30;
                    if (counter === 30) {
                        let counter = 31;
                        console.log(counter); // 31
                    }
                    console.log(counter); // 30 (because the variable in if block won't exist here)
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment17">
            <div class="engJSTheory">What is the difference between let and var</div>
            <div class="ruJSTheory">В чем разница между let и var</div>
        </h3>

        <section>
            <div>
                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>var</td>
                        <td>let</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">It has been available from the beginning of JavaScript</div>
                            <div class="ruJSTheory">Он был доступен с самого начала JavaScript.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Introduced as part of ES6</div>
                            <div class="ruJSTheory">Представлен как часть ES6.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">It has function scope</div>
                            <div class="ruJSTheory">Имеет глобальную область видимости</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It has block scope</div>
                            <div class="ruJSTheory">Имеет область видимости ограниченную блоком</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Variables will be hoisted</div>
                            <div class="ruJSTheory">Переменные будут "подняты"</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Hoisted but not initialized</div>
                            <div class="ruJSTheory">Переменные "подняты", но не инициализированы</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
                <pre>
                    function userDetails(username) {
                        if (username) {
                            console.log(salary); // undefined due to hoisting
                            console.log(age); // ReferenceError: Cannot access 'age' before initialization
                            let age = 30;
                            var salary = 10000;
                        }
                        console.log(salary); //10000 (accessible due to function scope)
                        console.log(age); //error: age is not defined(due to block scope)
                    }
                    userDetails("John");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment18">
            <div class="engJSTheory">What is the reason to choose the name let as a keyword</div>
            <div class="ruJSTheory">По какой причине let выбрано в качестве ключевого слова в JS</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">let is a mathematical statement that was adopted by early programming
                    languages
                    like Scheme and Basic.
                    It has been borrowed from dozens of other languages that use let already as a traditional
                    keyword as
                    close to var as possible.
                </p>
                <p class="ruJSTheory">let — это математическое утверждение, которое было принято в ранних языках
                    программирования, таких как
                    Scheme и Basic. Оно было заимствовано из десятков других языков, в которых let уже используется
                    как
                    традиционное ключевое слово, максимально близкое к var.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment19">
            <div class="engJSTheory">How do you redeclare variables in a switch block without an error</div>
            <div class="ruJSTheory">Как переобъявить переменные в блоке переключателей (switch) без ошибки?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you try to redeclare variables in a switch block then it will cause errors
                    because there is only one
                    block. For example, the below code block throws a syntax error as below,
                </p>
                <p class="ruJSTheory">Если вы попытаетесь переопределить переменные в блоке switch, это приведет к
                    ошибкам, поскольку
                    существует только один блок. Например, приведенный ниже блок кода выдает синтаксическую ошибку,
                    как
                    показано ниже:
                </p>

                <pre>
                    let counter = 1;
                    switch (x) {
                        case 0:
                            let name;
                            break;

                        case 1:
                            let name; // SyntaxError for redeclaration.
                            break;
                    }
            </pre>

                <p class="engJSTheory">To avoid this error, you can create a nested block inside a case clause and
                    create
                    a new block scoped
                    lexical environment.
                </p>
                <p class="ruJSTheory">Чтобы избежать этой ошибки, вы можете создать вложенный блок внутри
                    предложения
                    case
                    и создать новую
                    лексическую среду с областью действия блока.
                </p>

                <pre>
                    let counter = 1;
                    switch (x) {
                        case 0: {
                            let name;
                            break;
                        }
                        case 1: {
                            let name; // No SyntaxError for redeclaration.
                            break;
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment20">
            <div class="engJSTheory">What is the Temporal Dead Zone</div>
            <div class="ruJSTheory">Что такое временная мертвая зона</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Temporal Dead Zone is a behavior in JavaScript that occurs when declaring
                    a
                    variable with the let
                    and const keywords, but not with var. In ECMAScript 6, accessing a let or const variable before
                    its
                    declaration (within its scope) causes a ReferenceError. The time span when that happens, between
                    the
                    creation of a variable’s binding and its declaration, is called the temporal dead zone.
                </p>
                <p class="ruJSTheory">Временная мертвая зона — это поведение в JavaScript, которое возникает при
                    объявлении переменной с
                    ключевыми словами let и const, но не с var. В ECMAScript 6 доступ к переменной let или const до
                    ее
                    объявления (в пределах ее области действия) вызывает ошибку ReferenceError. Промежуток времени,
                    когда
                    это происходит, между созданием привязки переменной и ее объявлением, называется временной
                    мертвой
                    зоной.
                </p>
                <pre>
                    function someMethod() {
                        console.log(counter1); // undefined
                        console.log(counter2); // ReferenceError
                        var counter1 = 1;
                        let counter2 = 2;
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment21">
            <div class="engJSTheory">What is an IIFE (Immediately Invoked Function Expression)</div>
            <div class="ruJSTheory">Что такое IIFE (выражение функции с немедленным вызовом)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">IIFE (Immediately Invoked Function Expression) is a JavaScript function that
                    runs
                    as soon as it is
                    defined. The signature of it would be as below,
                </p>
                <p class="ruJSTheory">IIFE (выражение немедленно вызываемой функции) — это функция JavaScript,
                    которая
                    запускается сразу
                    после ее определения. Сигнатура будет такой, как показано ниже:
                </p>

                <pre>
                    (function () {
                        // logic here
                    })();
            </pre>

                <p class="engJSTheory">The primary reason to use an IIFE is to obtain data privacy because any
                    variables
                    declared within the
                    IIFE cannot be accessed by the outside world. i.e, If you try to access variables from the IIFE
                    then
                    it
                    throws an error as below,
                </p>
                <p class="ruJSTheory">Основная причина использования IIFE — обеспечение конфиденциальности данных,
                    поскольку любые
                    переменные, объявленные в IIFE, не могут быть доступны внешнему миру. т. е. если вы попытаетесь
                    получить
                    доступ к переменным из IIFE, то выдается ошибка, как показано ниже:
                </p>

                <pre>
                    (function () {
                        var message = "IIFE";
                        console.log(message);
                    })();
                    console.log(message); //Error: message is not defined
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment22">
            <div class="engJSTheory">How do you decode or encode a URL in JavaScript?</div>
            <div class="ruJSTheory">Как декодировать или кодировать URL-адрес в JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">encodeURI() function is used to encode an URL. This function requires a URL
                    string
                    as a parameter and
                    return that encoded string. decodeURI() function is used to decode an URL. This function
                    requires an
                    encoded URL string as parameter and return that decoded string.
                </p>
                <p class="ruJSTheory">Функция encodeURI() используется для кодирования URL-адреса. Эта функция
                    требует
                    строку URL-адреса в
                    качестве параметра и возвращает эту закодированную строку. Функция decodeURI() используется для
                    декодирования URL-адреса. Эта функция требует в качестве параметра закодированную строку
                    URL-адреса
                    и
                    возвращает эту декодированную строку.
                </p>

                <p class="engJSTheory">Note: If you want to encode characters such as / ? : @ & = + $ # then you
                    need to
                    use
                    encodeURIComponent().
                </p>
                <p class="ruJSTheory">Примечание: Если вы хотите закодировать такие символы, как / ? : @ & = + $ #
                    тогда
                    вам нужно
                    использовать encodeURIComponent().
                </p>

                <pre>
                    let uri = "employeeDetails?name=john&occupation=manager";
                    let encoded_uri = encodeURI(uri);
                    let decoded_uri = decodeURI(encoded_uri);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment23">
            <div class="engJSTheory">What is memoization</div>
            <div class="ruJSTheory">Что такое мемоизация</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Memoization is a functional programming technique which attempts to increase
                    a
                    function’s performance
                    by caching its previously computed results. Each time a memoized function is called, its
                    parameters
                    are
                    used to index the cache. If the data is present, then it can be returned, without executing the
                    entire
                    function. Otherwise the function is executed and then the result is added to the cache.
                </p>
                <p class="ruJSTheory">Мемоизация — это метод функционального программирования, который пытается
                    повысить
                    производительность
                    функции за счет кэширования ранее вычисленных результатов. Каждый раз, когда вызывается
                    мемоизированная
                    функция, ее параметры используются для индексации кеша. Если данные присутствуют, то их можно
                    вернуть,
                    не выполняя всю функцию. В противном случае функция выполняется, а затем результат добавляется в
                    кеш.
                </p>

                <pre>
                    const memoizAddition = () => {
                        let cache = {};
                        return (value) => {
                            if (value in cache) {
                                console.log("Fetching from cache");
                                return cache[value]; // Here, cache.value cannot be used as property name starts with the number which is not a valid JavaScript  identifier.
                                // Hence, can only be accessed using the square bracket notation.
                            } else {
                                console.log("Calculating result");
                                let result = value + 20;
                                cache[value] = result;
                                return result;
                            }
                        };
                    };
                    // returned function from memoizAddition
                    const addition = memoizAddition();
                    console.log(addition(20)); //output: 40 calculated
                    console.log(addition(20)); //output: 40 cached
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment24">
            <div class="engJSTheory">What is Hoisting</div>
            <div class="ruJSTheory">Что такое подъем</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Hoisting is a JavaScript mechanism where variables, function declarations and
                    classes are moved to the
                    top of their scope before code execution. Remember that JavaScript only hoists declarations, not
                    initialisation.
                </p>
                <p class="ruJSTheory">Подъем — это механизм JavaScript, в котором переменные, объявления функций и
                    классы
                    перемещаются в
                    верхнюю часть области видимости перед выполнением кода. Помните, что JavaScript поддерживает
                    только
                    объявления, а не инициализацию.
                </p>

                <pre>
                    console.log(message); //output : undefined
                    var message = "The variable Has been hoisted";
                </pre>

                <p class="engJSTheory">The above code looks like as below to the interpreter:</p>
                <p class="ruJSTheory">Приведенный выше код выглядит для интерпретатора следующим образом:</p>

                <pre>
                    //УСЛОВНЫЙ КОД для предыдущего примера

                    var message;
                    console.log(message);
                    message = "The variable Has been hoisted";
                </pre>

                <p class="engJSTheory">In the same fashion, function declarations are hoisted too</p>
                <p class="ruJSTheory">Таким же образом поднимаются и объявления функций.</p>

                <pre>
                    message("Good morning"); //Good morning

                    function message(name) {
                        console.log(name);
                    }
                </pre>

                <p class="engJSTheory">This hoisting makes functions to be safely used in code before they are
                    declared.
                </p>
                <p class="ruJSTheory">Такое поднятие позволяет безопасно использовать функции в коде до их
                    объявления.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment25">
            <div class="engJSTheory">What are classes in ES6</div>
            <div class="ruJSTheory">Что такое классы в ES6</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In ES6, Javascript classes are primarily syntactic sugar over JavaScript’s
                    existing
                    prototype-based
                    inheritance. For example, the prototype based inheritance written in function expression as
                    below,
                </p>
                <p class="ruJSTheory">В ES6 классы Javascript представляют собой в первую очередь синтаксический
                    сахар
                    над
                    существующим в JavaScript наследованием на основе прототипов. Например, наследование на основе
                    прототипа, записанное в функциональном выражении, как показано ниже:
                </p>

                <pre>
                    function Bike(model, color) {
                        this.model = model;
                        this.color = color;
                    }

                    Bike.prototype.getDetails = function () {
                        return this.model + " bike has" + this.color + " color";
                    };
            </pre>

                <p class="engJSTheory">Whereas ES6 classes can be defined as an alternative</p>
                <p class="ruJSTheory">Классы ES6 могут быть определены как альтернатива</p>

                <pre>
                    class Bike {
                        constructor(color, model) {
                            this.color = color;
                            this.model = model;
                        }

                        getDetails() {
                            return this.model + " bike has" + this.color + " color";
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment26">
            <div class="engJSTheory">What are closures</div>
            <div class="ruJSTheory">Что такое замыкания</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A closure is the combination of a function and the lexical environment within
                    which
                    that function was
                    declared. i.e, It is an inner function that has access to the outer or enclosing function’s
                    variables.
                    The closure has three scope chains:
                </p>
                <p class="ruJSTheory">Замыкание — это комбинация функции и лексического окружения, в котором эта
                    функция
                    была объявлена. т.е.
                    это внутренняя функция, которая имеет доступ к переменным внешней или охватывающей функции.
                    Замыкание
                    имеет три цепи охвата:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Own scope where variables defined between its curly brackets</div>
                        <div class="ruJSTheory">Собственная область видимости, где переменные определены между
                            фигурными
                            скобками.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Outer function’s variables</div>
                        <div class="ruJSTheory">Переменные внешней функции</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Global variables</div>
                        <div class="ruJSTheory">Глобальные переменные</div>
                    </li>
                </ol>
                <pre>
                    function getCounter() {
                        let counter = 0;
                        return function() {
                            return counter++;
                        }
                    }
                    let count = getCounter();
                    console.log(count());  // 0
                    console.log(count());  // 1
                    console.log(count());  // 2
                </pre>
                <p>Тут мы храним ссылку на анонимную внутреннюю функцию, возвращённую функцией
                    getCounter(), в переменной count. Так как функция count() представляет собой замыкание, она
                    может
                    обращаться к переменной counter функции getCount() даже после того, как функция getCounter()
                    завершила
                    работу.</p>
                <p>Обратите внимание на то, что значение переменной counter не сбрасывается в 0 при каждом вызове
                    функции
                    count(). Может показаться, что оно должно сбрасываться в 0, как могло бы быть при вызове обычной
                    функции, но этого не происходит.</p>
                <p>Всё работает именно так из-за того, что при каждом вызове функции count() для неё создаётся новая
                    область
                    видимости, но существует лишь одна область видимости для функции getCounter(). Так как
                    переменная
                    counter объявлена в области видимости функции getCounter(), её значение между вызовами функции
                    count()
                    сохраняется, не сбрасываясь в 0.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment27">
            <div class="engJSTheory">What are modules</div>
            <div class="ruJSTheory">Что такое модули</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Modules refer to small units of independent, reusable code and also act as
                    the
                    foundation of many
                    JavaScript design patterns. Most of the JavaScript modules export an object literal, a function,
                    or
                    a
                    constructor
                </p>
                <p class="ruJSTheory">Модули относятся к небольшим единицам независимого, многократно используемого
                    кода,
                    а также служат
                    основой многих шаблонов проектирования JavaScript. Большинство модулей JavaScript экспортируют
                    литерал
                    объекта, функцию или конструктор.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment28">
            <div class="engJSTheory">Why do you need modules</div>
            <div class="ruJSTheory">Зачем нужны модули</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of benefits using modules in javascript ecosystem:</p>
                <p class="ruJSTheory">Ниже приведен список преимуществ использования модулей в экосистеме
                    JavaScript:</p>
                <ol>
                    <li>
                        <div class="engJSTheory">Maintainability</div>
                        <div class="ruJSTheory">Улучшает процесс доработки приложения</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Reusability</div>
                        <div class="ruJSTheory">Многоразовое использование</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Namespacing</div>
                        <div class="ruJSTheory">Пространство имен</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment29">
            <div class="engJSTheory">What is scope in javascript</div>
            <div class="ruJSTheory">Что такое область видимости в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Scope is the accessibility of variables, functions, and objects in some
                    particular
                    part of your code
                    during runtime. In other words, scope determines the visibility of variables and other resources
                    in
                    areas of your code.
                </p>
                <p class="ruJSTheory">Область видимости — это доступность переменных, функций и объектов в
                    определенной
                    части вашего кода во
                    время выполнения. Другими словами, область видимости определяет видимость переменных и других
                    ресурсов в
                    областях вашего кода.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment30">
            <div class="engJSTheory">What is a service worker</div>
            <div class="ruJSTheory">Что такое сервисный работник</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A Service worker is basically a script (JavaScript file) that runs in the
                    background, separate from a
                    web page and provides features that don't need a web page or user interaction. Some of the major
                    features of service workers are Rich offline experiences(offline first web application
                    development),
                    periodic background syncs, push notifications, intercept and handle network requests and
                    programmatically managing a cache of responses.
                </p>
                <p class="ruJSTheory">Сервис воркеры — это, по сути, скрипт (файл JavaScript), который выполняется в
                    фоновом режиме
                    отдельно от веб-страницы и предоставляет функции, не требующие веб-страницы или взаимодействия с
                    пользователем. Некоторые из основных функций сервис воркеров — это богатый автономный опыт
                    (сначала
                    разработка веб-приложений в автономном режиме), периодическая фоновая синхронизация,
                    push-уведомления,
                    перехват и обработка сетевых запросов, а также программное управление кешем ответов.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment31">
            <div class="engJSTheory">How do you manipulate DOM using a service worker</div>
            <div class="ruJSTheory">Как манипулировать DOM с помощью сервис-воркера</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Service worker can't access the DOM directly. But it can communicate with the
                    pages
                    it controls by
                    responding to messages sent via the postMessage interface, and those pages can manipulate the
                    DOM.
                </p>
                <p class="ruJSTheory">Сервис-воркер не может получить прямой доступ к DOM. Но он может
                    взаимодействовать
                    со страницами,
                    которые он контролирует, отвечая на сообщения, отправленные через интерфейс postMessage, и эти
                    страницы
                    могут манипулировать DOM.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment32">
            <div class="engJSTheory">How do you reuse information across service worker restarts</div>
            <div class="ruJSTheory">Как повторно использовать информацию при перезапуске Service Worker?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The problem with service worker is that it gets terminated when not in use,
                    and
                    restarted when it's
                    next needed, so you cannot rely on global state within a service worker's onfetch and onmessage
                    handlers. In this case, service workers will have access to IndexedDB API in order to persist
                    and
                    reuse
                    across restarts.
                </p>
                <p class="ruJSTheory">Проблема с сервис-воркером заключается в том, что он завершается, когда он не
                    используется, и
                    перезапускается, когда он в следующий раз понадобится, поэтому вы не можете полагаться на
                    глобальное
                    состояние в обработчиках onfetch и onmessage сервис-воркера. В этом случае сервисные работники
                    будут
                    иметь доступ к API IndexedDB для его сохранения и повторного использования при перезапусках.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment33">
            <div class="engJSTheory">What is IndexedDB</div>
            <div class="ruJSTheory">Что такое IndexedDB</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">IndexedDB is a low-level API for client-side storage of larger amounts of
                    structured data, including
                    files/blobs. This API uses indexes to enable high-performance searches of this data.
                </p>
                <p class="ruJSTheory">IndexedDB — это низкоуровневый API для хранения на стороне клиента больших
                    объемов
                    структурированных
                    данных, включая файлы и BLOB-объекты. Этот API использует индексы для обеспечения
                    высокопроизводительного поиска этих данных.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment34">
            <div class="engJSTheory">What is web storage</div>
            <div class="ruJSTheory">Что такое веб-хранилище(web storage)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Web storage is an API that provides a mechanism by which browsers can store
                    key/value pairs locally
                    within the user's browser, in a much more intuitive fashion than using cookies. The web storage
                    provides
                    two mechanisms for storing data on the client:
                </p>
                <p class="ruJSTheory">Веб-хранилище — это API, который предоставляет механизм, с помощью которого
                    браузеры
                    могут хранить пары
                    ключ/значение локально в браузере пользователя, гораздо более интуитивно понятным способом, чем
                    использование файлов cookie. Веб-хранилище предоставляет два механизма хранения данных на
                    клиенте:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Local storage: It stores data for current origin with no expiration
                            date.
                        </div>
                        <div class="ruJSTheory">Локальное хранилище: оно хранит данные текущего происхождения без
                            срока
                            действия.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Session storage: It stores data for one session and the data is
                            lost
                            when
                            the browser tab is closed.
                        </div>
                        <div class="ruJSTheory">Хранилище сеансов: оно хранит данные за один сеанс, и данные
                            теряются
                            при
                            закрытии вкладки браузера.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment35">
            <div class="engJSTheory">What is a post message</div>
            <div>Что такое post сообщение</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Post message is a method that enables cross-origin communication between
                    Window
                    objects.(i.e, between a
                    page and a pop-up that it spawned, or between a page and an iframe embedded within it).
                    Generally,
                    scripts on different pages are allowed to access each other if and only if the pages follow
                    same-origin
                    policy(i.e, pages share the same protocol, port number, and host).
                </p>
                <p class="ruJSTheory">Post сообщение — это метод, который обеспечивает связь между источниками между
                    объектами Window
                    (т. е. между страницей и всплывающим окном, которое она создала, или между страницей и
                    встроенным в
                    нее
                    iframe). Как правило, сценариям на разных страницах разрешен доступ друг к другу тогда и только
                    тогда,
                    когда страницы следуют политике одного и того же происхождения (т. е. страницы используют один и
                    тот
                    же
                    протокол, номер порта и хост).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment36">
            <div class="engJSTheory">What is a Cookie</div>
            <div class="ruJSTheory">Что такое Cookie</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A cookie is a piece of data that is stored on your computer to be accessed by
                    your
                    browser. Cookies are
                    saved as key/value pairs. For example, you can create a cookie named username as below:
                </p>
                <p class="ruJSTheory">Файл cookie — это часть данных, которая хранится на вашем компьютере и
                    доступна
                    вашему браузеру. Файлы
                    cookie сохраняются в виде пар ключ/значение. Например, вы можете создать файл cookie с именем
                    пользователя, как показано ниже:
                </p>

                <pre>
                document.cookie = "username=John";
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment37">
            <div class="engJSTheory">Why do you need a Cookie</div>
            <div class="ruJSTheory">Зачем вам нужен Cookie</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Cookies are used to remember information about the user profile(such as
                    username).
                    It basically
                    involves two steps:
                </p>
                <p class="ruJSTheory">Файлы cookie используются для запоминания информации о профиле пользователя
                    (например, имени
                    пользователя). В основном это включает в себя два шага:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">When a user visits a web page, the user profile can be stored in a
                            cookie.
                        </div>
                        <div class="ruJSTheory">Когда пользователь посещает веб-страницу, профиль пользователя может
                            быть
                            сохранен в файле
                            cookie.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Next time the user visits the page, the cookie remembers the user
                            profile.
                        </div>
                        <div class="ruJSTheory">Когда пользователь в следующий раз посетит страницу, файл cookie
                            запоминает
                            профиль
                            пользователя.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment38">
            <div class="engJSTheory">What are the options in a Cookie</div>
            <div class="ruJSTheory">Какие параметры есть в Cookie</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are few below options available for a cookie:</p>
                <p class="ruJSTheory">Для файлов cookie доступно несколько вариантов ниже:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">By default, the cookie is deleted when the browser is closed but
                            you
                            can
                            change this behavior
                            by setting expiry date (in UTC time).
                        </div>
                        <div class="ruJSTheory">По умолчанию файл cookie удаляется при закрытии браузера, но вы
                            можете
                            изменить это поведение,
                            установив дату истечения срока действия (по времени UTC).
                        </div>
                        <pre>
                        document.cookie = "username=John; expires=Sat, 8 Jun 2019 12:00:00 UTC";
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">By default, the cookie belongs to a current page. But you can tell
                            the
                            browser what path the
                            cookie belongs to using a path parameter.
                        </div>
                        <div class="ruJSTheory">По умолчанию файл cookie принадлежит текущей странице. Но вы можете
                            сообщить
                            браузеру, какому
                            пути принадлежит файл cookie, используя параметр пути.
                        </div>
                        <pre>
                        document.cookie = "username=John; path=/services";
                    </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment39">
            <div class="engJSTheory">How do you delete a cookie</div>
            <div class="ruJSTheory">Как удалить файл cookie</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can delete a cookie by setting the expiry date as a passed date. You
                    don't
                    need
                    to specify a cookie
                    value in this case. For example, you can delete a username cookie in the current page as below.
                </p>
                <p class="ruJSTheory">Вы можете удалить файл cookie, установив дату истечения срока его действия как
                    прошедшую дату. В этом
                    случае вам не нужно указывать значение cookie. Например, вы можете удалить файл cookie имени
                    пользователя на текущей странице, как показано ниже.
                </p>

                <pre>
                document.cookie = "username=; expires=Fri, 07 Jun 2019 00:00:00 UTC; path=/;";
            </pre>

                <p class="engJSTheory">Note: You should define the cookie path option to ensure that you delete the
                    right
                    cookie. Some
                    browsers doesn't allow to delete a cookie unless you specify a path parameter.
                </p>
                <p class="ruJSTheory">Примечание. Вам следует определить параметр пути к файлам cookie, чтобы
                    гарантировать удаление нужного
                    файла cookie. Некоторые браузеры не позволяют удалять файлы cookie, если вы не укажете параметр
                    пути.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment40">
            <div class="engJSTheory">What are the differences between cookie, local storage and session storage
            </div>
            <div class="ruJSTheory">В чем разница между файлами cookie, локальным хранилищем и хранилищем сеансов?
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are some of the differences between cookie, local storage and session
                    storage,
                </p>
                <p class="ruJSTheory">Ниже приведены некоторые различия между файлами cookie, локальным хранилищем и
                    хранилищем сеансов.
                </p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>
                            <div class="engJSTheory">Feature</div>
                            <div class="ruJSTheory">Особенность</div>
                        </td>
                        <td>Cookie</td>
                        <td>Local storage</td>
                        <td>Session storage</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Accessed on client or server side</div>
                            <div class="ruJSTheory">Доступ на стороне клиента или сервера</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Both server-side & client-side</div>
                            <div class="ruJSTheory">Как на стороне сервера, так и на стороне клиента</div>
                        </td>
                        <td>
                            <div class="engJSTheory">client-side only</div>
                            <div class="ruJSTheory">только на стороне клиента</div>
                        </td>
                        <td>
                            <div class="engJSTheory">client-side only</div>
                            <div class="ruJSTheory">только на стороне клиента</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Lifetime</div>
                            <div class="ruJSTheory">Продолжительность жизни</div>
                        </td>
                        <td>
                            <div class="engJSTheory">As configured using Expires option</div>
                            <div class="ruJSTheory">Как настроено с использованием параметра Expires</div>
                        </td>
                        <td>
                            <div class="engJSTheory">until deleted</div>
                            <div class="ruJSTheory">пока не будет удален</div>
                        </td>
                        <td>
                            <div class="engJSTheory">until tab is closed</div>
                            <div class="ruJSTheory">пока вкладка не закроется</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">SSL support</div>
                            <div class="ruJSTheory">Поддержка SSL</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Supported</div>
                            <div class="ruJSTheory">Поддерживается</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Not supported</div>
                            <div class="ruJSTheory">Не поддерживается</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Not supported</div>
                            <div class="ruJSTheory">Не поддерживается</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Maximum data size</div>
                            <div class="ruJSTheory">Максимальный размер данных</div>
                        </td>
                        <td>4 KB</td>
                        <td>5 MB</td>
                        <td>5 MB</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment41">
            <div class="engJSTheory">What is the main difference between localStorage and sessionStorage</div>
            <div class="ruJSTheory">В чем основная разница между localStorage и sessionStorage?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">LocalStorage is the same as SessionStorage but it persists the data even when
                    the
                    browser is closed and
                    reopened(i.e it has no expiration time) whereas in sessionStorage data gets cleared when the
                    page
                    session ends.
                </p>
                <p class="ruJSTheory">LocalStorage аналогичен SessionStorage, но он сохраняет данные, даже когда
                    браузер
                    закрывается и снова
                    открывается (т. е. у него нет срока действия), тогда как в sessionStorage данные очищаются после
                    завершения сеанса страницы.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment42">
            <div class="engJSTheory">How do you access web storage</div>
            <div class="ruJSTheory">Как получить доступ к веб-хранилищу</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Window object implements the WindowLocalStorage and WindowSessionStorage
                    objects which has
                    localStorage(window.localStorage) and sessionStorage(window.sessionStorage) properties
                    respectively.
                    These properties create an instance of the Storage object, through which data items can be set,
                    retrieved and removed for a specific domain and storage type (session or local). For example,
                    you
                    can
                    read and write on local storage objects as below
                </p>
                <p class="ruJSTheory">Объект Window реализует объекты WindowLocalStorage и WindowSessionStorage,
                    которые
                    имеют свойства
                    localStorage(window.localStorage) и sessionStorage(window.sessionStorage) соответственно. Эти
                    свойства
                    создают экземпляр объекта Storage, с помощью которого можно устанавливать, получать и удалять
                    элементы
                    данных для определенного домена и типа хранилища (сеансовое или локальное). Например, вы можете
                    читать и
                    записывать объекты локального хранилища, как показано ниже.
                </p>

                <pre>
                    localStorage.setItem("logo", document.getElementById("logo").value);
                    localStorage.getItem("logo");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment43">
            <div class="engJSTheory">What are the methods available on session storage</div>
            <div class="ruJSTheory">Какие методы доступны в хранилище сеансов?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The session storage provided methods for reading, writing and clearing the
                    session
                    data
                </p>
                <p class="ruJSTheory">Хранилище сеансов предоставляет методы для чтения, записи и очистки данных
                    сеанса.
                </p>

                <pre>
                    // Save data to sessionStorage
                    sessionStorage.setItem("key", "value");

                    // Get saved data from sessionStorage
                    let data = sessionStorage.getItem("key");

                    // Remove saved data from sessionStorage
                    sessionStorage.removeItem("key");

                    // Remove all saved data from sessionStorage
                    sessionStorage.clear();
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment44">
            <div class="engJSTheory">What is a storage event and its event handler</div>
            <div class="ruJSTheory">Что такое событие хранилища и его обработчик событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The StorageEvent is an event that fires when a storage area has been changed
                    in
                    the
                    context of another
                    document. Whereas onstorage property is an EventHandler for processing storage events. The
                    syntax
                    would
                    be as below:
                </p>
                <p class="ruJSTheory">StorageEvent — это событие, которое срабатывает, когда область хранения была
                    изменена в контексте
                    другого документа. Тогда как свойство onstorage — это EventHandler для обработки событий
                    хранилища.
                    Синтаксис будет таким, как показано ниже:
                </p>

                <pre>
                window.onstorage = functionRef;
            </pre>

                <p class="engJSTheory">Let's take the example usage of onstorage event handler which logs the
                    storage
                    key
                    and it's values
                </p>
                <p class="ruJSTheory">Давайте возьмем пример использования обработчика событий onstorage, который
                    регистрирует ключ хранилища
                    и его значения.
                </p>
                <pre>
                    window.onstorage = function (e) {
                        console.log(
                            "The " +
                            e.key +
                            " key has been changed from " +
                            e.oldValue +
                            " to " +
                            e.newValue +
                            "."
                        );
                    };
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment45">
            <div class="engJSTheory">Why do you need web storage</div>
            <div class="ruJSTheory">Зачем нужно веб-хранилище</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Web storage is more secure, and large amounts of data can be stored locally,
                    without affecting website
                    performance. Also, the information is never transferred to the server. Hence this is a more
                    recommended
                    approach than Cookies.
                </p>
                <p class="ruJSTheory">Веб-хранилище более безопасно, и большие объемы данных могут храниться
                    локально,
                    не
                    влияя на
                    производительность веб-сайта. Кроме того, информация никогда не передается на сервер.
                    Следовательно,
                    это
                    более рекомендуемый подход, чем использование файлов cookie.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment46">
            <div class="engJSTheory">How do you check web storage browser support</div>
            <div class="ruJSTheory">Как проверить поддержку веб-хранилища браузером</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You need to check browser support for localStorage and sessionStorage before
                    using
                    web storage:
                </p>
                <p class="ruJSTheory">Перед использованием веб-хранилища необходимо проверить поддержку браузером
                    localStorage и
                    sessionStorage.
                </p>

                <pre>
                    if (typeof Storage !== "undefined") {
                        // Code for localStorage/sessionStorage.
                    } else {
                        // Sorry! No Web Storage support..
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment47">
            <div class="engJSTheory">How do you check web workers browser support</div>
            <div class="ruJSTheory">Как проверить поддержку браузером веб-воркеров</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You need to check browser support for web workers before using it</p>
                <p class="ruJSTheory">Прежде чем использовать его, необходимо проверить поддержку веб-воркеров в
                    браузере.
                </p>

                <pre>
                    if (typeof Worker !== "undefined") {
                        // code for Web worker support.
                    } else {
                        // Sorry! No Web Worker support..
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment48">
            <div class="engJSTheory">Give an example of a web worker</div>
            <div class="ruJSTheory">Приведите пример веб-воркера</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You need to follow below steps to start using web workers for counting
                    example
                </p>
                <p class="ruJSTheory">Вам необходимо выполнить следующие шаги, чтобы начать использовать
                    веб-воркеров
                    для
                    примера подсчета.
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Create a Web Worker File: You need to write a script to increment
                            the
                            count
                            value. Let's name it as
                            counter.js
                        </div>
                        <div class="ruJSTheory">Создайте файл веб-воркера: вам необходимо написать сценарий для
                            увеличения
                            значения счетчика. Назовем
                            его counter.js.
                        </div>

                        <pre>
                            let i = 0;

                            function timedCount() {
                                i = i + 1;
                                postMessage(i);
                                setTimeout("timedCount()", 500);
                            }

                            timedCount();
                        </pre>

                        <div class="engJSTheory">Here postMessage() method is used to post a message back to the
                            HTML
                            page
                        </div>
                        <div class="ruJSTheory">Здесь метод postMessage() используется для отправки сообщения
                            обратно на
                            HTML-страницу.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Create a Web Worker Object: You can create a web worker object by
                            checking
                            for
                            browser support. Let's
                            name this file as web_worker_example.js
                        </div>
                        <div class="ruJSTheory">Создайте объект веб-воркера. Вы можете создать объект веб-рабочего,
                            проверив
                            поддержку браузера.
                            Назовем этот файл web_worker_example.js.
                        </div>

                        <pre>
                        if (typeof w == "undefined") {
                            w = new Worker("counter.js");
                        }
                    </pre>

                        <div class="engJSTheory">and we can receive messages from web worker</div>
                        <div class="ruJSTheory">и мы можем получать сообщения от веб-воркера</div>

                        <pre>
                        w.onmessage = function (event) {
                            document.getElementById("message").innerHTML = event.data;
                        };
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Terminate a Web Worker: Web workers will continue to listen for
                            messages
                            (even
                            after the external
                            script is finished) until it is terminated. You can use the terminate() method to
                            terminate
                            listening to
                            the messages.
                        </div>
                        <div class="ruJSTheory">Завершить веб-воркер: Веб-воркеры будут продолжать прослушивать
                            сообщения
                            (даже
                            после завершения
                            внешнего скрипта), пока он не будет завершен. Вы можете использовать метод terminate(),
                            чтобы
                            прекратить прослушивание сообщений.
                        </div>

                        <pre>
                            w.terminate();
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Reuse the Web Worker: If you set the worker variable to undefined
                            you
                            can
                            reuse
                            the code
                        </div>
                        <div class="ruJSTheory">Повторное использование веб-воркера: Если вы установите для рабочей
                            переменной
                            значение undefined, вы
                            сможете повторно использовать код.
                        </div>

                        <pre>
                        w = undefined;
                    </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment49">
            <div class="engJSTheory">What are the restrictions of web workers on DOM</div>
            <div class="ruJSTheory">Каковы ограничения веб-воркеров в DOM</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">WebWorkers don't have access to below javascript objects since they are
                    defined
                    in
                    an external files:
                </p>
                <p class="ruJSTheory">Веб-воркеры не имеют доступа к объектам JavaScript из списка ниже, поскольку
                    они
                    определены во внешних файлах:
                </p>

                <ol>
                    <li>Window object</li>
                    <li>Document object</li>
                    <li>
                        <div class="engJSTheory">Parent object</div>
                        <div class="ruJSTheory">Родительский объект</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment50">
            <div class="engJSTheory">What is a promise</div>
            <div class="ruJSTheory">Что такое promise</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A promise is an object that may produce a single value some time in the
                    future
                    with
                    either a resolved
                    value or a reason that it’s not resolved(for example, network error). It will be in one of the 3
                    possible states: fulfilled, rejected, or pending.
                </p>
                <p class="ruJSTheory">Промис — это объект, который может когда-нибудь в будущем создать одно
                    значение,
                    которое будет либо с
                    разрешенным
                    значением, либо с причиной, по которой оно не было разрешено (например, сетевая ошибка). Оно
                    будет
                    находиться в одном из трех возможных состояний: выполнено(fulfilled), отклонено(rejected) или
                    ожидается(pending).
                </p>

                <p class="engJSTheory">The syntax of Promise creation looks like below:</p>
                <p class="ruJSTheory">Синтаксис создания промиса выглядит следующим образом:</p>

                <pre>
                const promise = new Promise(function (resolve, reject) {
                    // promise description
                });
            </pre>

                <p class="engJSTheory">The usage of a promise would be as below:</p>
                <p class="ruJSTheory">Использование обещания будет выглядеть следующим образом:</p>

                <pre>
                    const promise = new Promise(
                            (resolve) => {
                                setTimeout(() => {
                                resolve("I'm a Promise!");
                            }, 5000);
                        },
                        (reject) => {}
                    );

                promise.then((value) => console.log(value));
            </pre>

                <p class="engJSTheory">The action flow of a promise will be as below:</p>
                <p class="ruJSTheory">Последовательность действий промиса будет такой, как показано ниже:</p>

                <img src="images/promises.png" alt="promises" width="644">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment51">
            <div class="engJSTheory">Why do you need a promise</div>
            <div class="ruJSTheory">Для чего нужен промис</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Promises are used to handle asynchronous operations. They provide an
                    alternative
                    approach for callbacks
                    by reducing the callback hell and writing the cleaner code.
                </p>
                <p class="ruJSTheory">Промисы используются для обработки асинхронных операций. Они предоставляют
                    альтернативный подход к
                    обратным вызовам, уменьшая "ад обратных вызовов" и написав более чистый код.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment52">
            <div class="engJSTheory">What are the three states of promise</div>
            <div class="ruJSTheory">Три состояния промиса</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Promises have three states:</p>
                <p class="ruJSTheory">Промисы имеют три состояния:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Pending: This is an initial state of the Promise before an
                            operation
                            begins
                        </div>
                        <div class="ruJSTheory">Pending(ожидание): это начальное состояние промиса перед началом
                            операции.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Fulfilled: This state indicates that the specified operation was
                            completed.
                        </div>
                        <div class="ruJSTheory">Fulfilled(выполнено): это состояние указывает, что указанная
                            операция
                            была
                            завершена.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Rejected: This state indicates that the operation did not complete.
                            In
                            this
                            case an error value will be thrown.
                        </div>
                        <div class="ruJSTheory">Rejected(отклонено): это состояние указывает на то, что операция не
                            завершена. В этом случае будет выдано значение ошибки.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment53">
            <div class="engJSTheory">What is a callback function</div>
            <div class="ruJSTheory">Что такое функция обратного вызова(callback функция)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A callback function is a function passed into another function as an
                    argument.
                    This
                    function is invoked
                    inside the outer function to complete an action. Let's take a simple example of how to use
                    callback
                    function:
                </p>
                <p class="ruJSTheory">Функция обратного вызова(callback функция) — это функция, передаваемая в
                    другую
                    функцию в качестве аргумента. Эта функция
                    вызывается внутри внешней функции для завершения действия. Давайте рассмотрим простой пример
                    использования функции обратного вызова:
                </p>

                <pre>
                function callbackFunction(name) {
                    console.log("Hello " + name);
                }

                function outerFunction(callback) {
                    let name = prompt("Please enter your name.");
                    callback(name);
                }

                outerFunction(callbackFunction);
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment54">
            <div class="engJSTheory">Why do we need callbacks</div>
            <div class="ruJSTheory">Почему нужны колбэк функции</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The callbacks are needed because javascript is an event driven language. That
                    means
                    instead of waiting
                    for a response javascript will keep executing while listening for other events. Let's take an
                    example
                    with the first function invoking an API call(simulated by setTimeout) and the next function
                    which
                    logs
                    the message:
                </p>
                <p class="ruJSTheory">Колбэк функции необходимы, потому что javascript — это язык, управляемый
                    событиями.
                    Это означает, что
                    вместо ожидания ответа JavaScript будет продолжать выполняться, прослушивая другие события.
                    Давайте
                    возьмем пример с первой функцией, вызывающей вызов API (моделируемый setTimeout), и следующей
                    функцией,
                    которая регистрирует сообщение:
                </p>

                <pre>
                    function firstFunction() {
                        // Simulate a code delay
                        setTimeout(function () {
                            console.log("First function called");
                        }, 1000);
                    }
                    function secondFunction() {
                        console.log("Second function called");
                    }
                    firstFunction();
                    secondFunction();

                    Output:
                    // Second function called
                    // First function called
                </pre>

                <p class="engJSTheory">As observed from the output, javascript didn't wait for the response of the
                    first
                    function and the
                    remaining code block got executed. So callbacks are used in a way to make sure that certain code
                    doesn’t
                    execute until the other code finishes execution.
                </p>
                <p class="ruJSTheory">Как видно из выходных данных, javascript не дождался ответа первой функции, и
                    оставшийся блок кода был
                    выполнен. Таким образом, обратные вызовы используются для того, чтобы гарантировать, что
                    определенный
                    код не будет выполняться, пока другой код не завершит выполнение.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment55">
            <div class="engJSTheory">What is a callback hell</div>
            <div class="ruJSTheory">Что такое "ад обратного вызова"</div>
        </h3>
        <section>
            <div>
                <p class="engJSTheory">Callback Hell is an anti-pattern with multiple nested callbacks which makes
                    code
                    hard to read and debug
                    when dealing with asynchronous logic. The callback hell looks like below:
                </p>
                <p class="ruJSTheory">Callback Hell — это анти-паттерн с несколькими вложенными обратными вызовами,
                    который затрудняет чтение и
                    отладку кода при работе с асинхронной логикой. Ад обратного вызова выглядит следующим образом:
                </p>

                <pre>
                    async1(function(){
                        async2(function(){
                            async3(function(){
                                async4(function(){
                                    ....
                                });
                            });
                        });
                    });
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment56">
            <div class="engJSTheory">What are server-sent events</div>
            <div class="ruJSTheory">Что такое события, отправляемые сервером</div>
        </h3>
        <section>
            <div>
                <p class="engJSTheory">Server-sent events (SSE) is a server push technology enabling a browser to
                    receive
                    automatic updates
                    from a server via HTTP connection without resorting to polling. These are a one way
                    communications
                    channel - events flow from server to client only. This has been used in Facebook/Twitter
                    updates,
                    stock
                    price updates, news feeds etc.
                </p>
                <p class="ruJSTheory">События, отправленные сервером (SSE) — это технология push-уведомлений
                    сервера,
                    позволяющая браузеру
                    получать автоматические обновления с сервера через HTTP-соединение, не прибегая к запросу. Это
                    односторонний канал связи — события передаются только от сервера к клиенту. Это использовалось в
                    обновлениях Facebook/Twitter, обновлениях цен на акции, новостных лентах и т. д.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment57">
            <div class="engJSTheory">How do you receive server-sent event notifications</div>
            <div class="ruJSTheory">Как вы получаете уведомления о событиях, отправленные сервером</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The EventSource object is used to receive server-sent event notifications.
                    For
                    example, you can receive
                    messages from server as below:
                </p>
                <p class="ruJSTheory">Объект EventSource используется для получения уведомлений о событиях,
                    отправленных
                    сервером. Например,
                    вы можете получать сообщения с сервера, как показано ниже:
                </p>

                <pre>
                    if (typeof EventSource !== "undefined") {
                        var source = new EventSource("sse_generator.js");
                        source.onmessage = function (event) {
                            document.getElementById("output").innerHTML += event.data + "< br>";
                        };
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment58">
            <div class="engJSTheory">How do you check browser support for server-sent events</div>
            <div class="ruJSTheory">Как проверить поддержку браузером событий, отправленных сервером?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can perform browser support for server-sent events before using it as
                    below:
                </p>
                <p class="ruJSTheory">Вы можете выполнить поддержку браузера для событий, отправленных сервером,
                    прежде
                    чем использовать его,
                    как показано ниже:
                </p>

                <pre>
                    if (typeof EventSource !== "undefined") {
                        // Server-sent events supported. Let's have some code here!
                    } else {
                        // No server-sent events supported
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment59">
            <div class="engJSTheory">What are the events available for server sent events</div>
            <div class="ruJSTheory">Какие события доступны для событий, отправленных сервером?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of events available for server sent events:</p>
                <p class="ruJSTheory">Ниже приведен список событий, доступных для событий, отправленных
                    сервером.</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>
                            <div class="engJSTheory">Event</div>
                            <div class="ruJSTheory">Событие</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Description</div>
                            <div class="ruJSTheory">Описание</div>
                        </td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>onopen</td>
                        <td>
                            <div class="engJSTheory">It is used when a connection to the server is opened</div>
                            <div class="ruJSTheory">Используется при открытии соединения с сервером.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>onmessage</td>
                        <td>
                            <div class="engJSTheory">This event is used when a message is received</div>
                            <div class="ruJSTheory">Это событие используется при получении сообщения</div>
                        </td>
                    </tr>
                    <tr>
                        <td>onerror</td>
                        <td>
                            <div class="engJSTheory">It happens when an error occurs</div>
                            <div class="ruJSTheory">Это происходит, когда возникает ошибка</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment60">
            <div class="engJSTheory">What are the main rules of promise</div>
            <div class="ruJSTheory">Каковы основные правила промисов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A promise must follow a specific set of rules:</p>
                <p class="ruJSTheory">Промис должен соответствовать определенному набору правил:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">A promise is an object that supplies a standard-compliant .then()
                            method
                        </div>
                        <div class="ruJSTheory">Промис — это объект, который предоставляет соответствующий стандарту
                            метод
                            .then().
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">A pending promise may transition into either fulfilled or rejected
                            state
                        </div>
                        <div class="ruJSTheory">Ожидающий(pending) промис может перейти в состояние
                            "выполнено"(fulfilled) или "отклонено"(rejected).
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">A fulfilled or rejected promise is settled and it must not
                            transition
                            into
                            any other state.
                        </div>
                        <div class="ruJSTheory">Выполненный или отклоненный промис является урегулированным и не
                            должен
                            переходить в какое-либо другое состояние.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Once a promise is settled, the value must not change.</div>
                        <div class="ruJSTheory">После того как промис выполнен, его значение не должно меняться.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment61">
            <div class="engJSTheory">What is callback in callback</div>
            <div class="ruJSTheory">Что такое обратный вызов в обратном вызове</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can nest one callback inside in another callback to execute the actions
                    sequentially one by one.
                    This is known as callbacks in callbacks.
                </p>
                <p class="ruJSTheory">Вы можете вложить один обратный вызов в другой обратный вызов, чтобы выполнять
                    действия последовательно
                    одно за другим. Это называется - обратные вызовы в обратных вызовах.
                </p>

                <pre>
                    loadScript("/script1.js", function (script) {
                        console.log("first script is loaded");

                        loadScript("/script2.js", function (script) {
                                console.log("second script is loaded");

                                loadScript("/script3.js", function (script) {
                                console.log("third script is loaded");
                                // after all scripts are loaded
                            });
                        });
                    });
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment62">
            <div class="engJSTheory">What is promise chaining</div>
            <div class="ruJSTheory">Что такое цепочка промисов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The process of executing a sequence of asynchronous tasks one after another
                    using
                    promises is known as
                    Promise chaining. Let's take an example of promise chaining for calculating the final result:
                </p>
                <p class="ruJSTheory">Процесс выполнения последовательности асинхронных задач одна за другой с
                    использованием промисов
                    известен как цепочка промисов. Давайте рассмотрим пример цепочки обещаний для расчета конечного
                    результата:
                </p>

                <pre>
                    new Promise(function (resolve, reject) {
                        setTimeout(() => resolve(1), 1000);
                    })
                    .then(function (result) {
                        console.log(result); // 1
                        return result * 2;
                    })
                    .then(function (result) {
                        console.log(result); // 2
                        return result * 3;
                    })
                    .then(function (result) {
                        console.log(result); // 6
                        return result * 4;
                    });
                </pre>

                <p class="engJSTheory">In the above handlers, the result is passed to the chain of .then() handlers
                    with
                    the below work
                    flow:
                </p>
                <p class="ruJSTheory">В приведенных выше обработчиках результат передается в цепочку обработчиков
                    .then()
                    с приведенным ниже
                    рабочим процессом:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">The initial promise resolves in 1 second.</div>
                        <div class="ruJSTheory">Первоначальный промис выполняется через 1 секунду</div>
                    </li>
                    <li>
                        <div class="engJSTheory">After that .then handler is called by logging the result(1) and
                            then
                            return
                            a promise with the value of result * 2.
                        </div>
                        <div class="ruJSTheory">После этого вызывается обработчик .then, регистрирующий результат
                            (1), а
                            затем возвращает промис со значением result * 2.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">After that the value passed to the next .then handler by logging
                            the
                            result(2) and return a promise with result * 3.
                        </div>
                        <div class="ruJSTheory">После этого значение передается следующему обработчику .then путем
                            регистрации результата (2) и возврата промиса с result * 3.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Finally the value passed to the last .then handler by logging the
                            result(6)
                            and return a promise with result * 4.
                        </div>
                        <div class="ruJSTheory">Наконец, значение передается последнему обработчику .then путем
                            регистрации
                            результата (6) и возврата промиса с result * 4.
                        </div>
                    </li>
                </ol>
            </div>
        </section>


        <h3 id="JSbasicsForEmployment63">
            <div class="engJSTheory">What is promise.all</div>
            <div class="ruJSTheory">Что такое promise.all</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Promise.all is a promise that takes an array of promises as an input (an
                    iterable),
                    and it gets
                    resolved when all the promises get resolved or any one of them gets rejected. For example, the
                    syntax of
                    promise.all method is below:
                </p>
                <p class="ruJSTheory">Promise.all — это промис, который принимает на вход массив промисов
                    (итерируемый
                    объект), и он
                    выполняется, когда все промисы решены или какой-либо из них отклонен. Например, синтаксис метода
                    Promise.all приведен ниже:
                </p>

                <pre>
                Promise.all([Promise1, Promise2, Promise3]) .then(result) => {   console.log(result) }) .catch(error => console.log(`Error in promises ${error}`))
            </pre>

                <p class="engJSTheory">Note: Remember that the order of the promises(output the result) is
                    maintained as
                    per input order.
                </p>
                <p class="ruJSTheory">Примечание: Помните, что порядок промисов (вывод результата) сохраняется в
                    соответствии с порядком
                    ввода.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment64">
            <div class="engJSTheory">What is the purpose of the race() method in promise</div>
            <div class="ruJSTheory">Какова цель метода race() в промисе</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Promise.race() method will return the promise instance which is firstly
                    resolved
                    or
                    rejected. Let's
                    take an example of race() method where promise2 is resolved first:
                </p>
                <p class="ruJSTheory">Метод Promise.race() вернет экземпляр промиса, который был первым разрешен или
                    отклонен. Давайте
                    возьмем пример метода race(), где сначала разрешается Promise2:
                </p>

                <pre>
                    var promise1 = new Promise(function (resolve, reject) {
                        setTimeout(resolve, 500, "one");
                    });
                    var promise2 = new Promise(function (resolve, reject) {
                        setTimeout(resolve, 100, "two");
                    });

                    Promise.race([promise1, promise2]).then(function (value) {
                        console.log(value); // "two" // Both promises will resolve, but promise2 is faster
                    });
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment65">
            <div class="engJSTheory">What is a strict mode in javascript</div>
            <div class="ruJSTheory">Что такое strict mode(строгий режим) в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Strict Mode is a new feature in ECMAScript 5 that allows you to place a
                    program,
                    or
                    a function, in a
                    “strict” operating context. This way it prevents certain actions from being taken and throws
                    more
                    exceptions. The literal expression "use strict"; instructs the browser to use the javascript
                    code in
                    the
                    Strict mode.
                </p>
                <p class="ruJSTheory">Строгий режим(strict mode) — это новая функция ECMAScript 5, которая позволяет
                    поместить программу или функцию в
                    «строгий» рабочий контекст. Таким образом, он предотвращает выполнение определенных действий и
                    генерирует больше исключений. Буквальное выражение "use strict"; указывает браузеру
                    использовать код JavaScript в строгом режиме.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment66">
            <div class="engJSTheory">Why do you need strict mode</div>
            <div class="ruJSTheory">Для чего нужен строгий режим(strict mode)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Strict mode is useful to write "secure" JavaScript by notifying "bad syntax"
                    into
                    real errors. For
                    example, it eliminates accidentally creating a global variable by throwing an error and also
                    throws
                    an
                    error for assignment to a non-writable property, a getter-only property, a non-existing
                    property, a
                    non-existing variable, or a non-existing object.
                </p>
                <p class="ruJSTheory">Строгий режим полезен для написания «безопасного» JavaScript кода, уведомляя
                    «плохой
                    синтаксис» о реальных
                    ошибках. Например, он исключает случайное создание глобальной переменной путем выдачи ошибки, а
                    также
                    выдает ошибку при присвоении свойству, не доступному для записи, свойству геттеру,
                    несуществующему
                    свойству, несуществующей переменной и несуществующему объекту.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment67">
            <div class="engJSTheory">How do you declare strict mode</div>
            <div class="ruJSTheory">Как объявить строгий режим</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The strict mode is declared by adding "use strict"; to the beginning of a
                    script
                    or
                    a function. If
                    declared at the beginning of a script, it has global scope.
                </p>
                <p class="ruJSTheory">Строгий режим объявляется добавлением «use strict»; в начало скрипта или
                    функции.
                    Если он объявлен в
                    начале скрипта, он имеет глобальную область действия.
                </p>

                <pre>
                "use strict";
                x = 3.14; // This will cause an error because x is not declared
            </pre>

                <p class="engJSTheory">and if you declare inside a function, it has local scope</p>
                <p class="ruJSTheory">и если вы объявляете строгий режим внутри функции, она имеет локальную область
                    видимости
                </p>

                <pre>
                    x = 3.14; // This will not cause an error.
                    myFunction();

                    function myFunction() {
                        "use strict";
                        y = 3.14; // This will cause an error
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment68">
            <div class="engJSTheory">What is the purpose of double exclamation</div>
            <div class="ruJSTheory">Какова цель двойного восклицательного знака (отрицание отрицания)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The double exclamation or negation(!!) ensures the resulting type is a
                    boolean.
                    If
                    it was falsey (e.g.
                    0, null, undefined, etc.), it will be false, otherwise, it will be true. For example, you can
                    test
                    IE
                    version using this expression as below,
                </p>
                <p class="ruJSTheory">Двойное восклицание или отрицание (!!) гарантирует, что результирующий тип
                    является
                    логическим. Если
                    оно было ложным (например, 0, null, undefined, и т. д.), оно будет ложным, в противном случае
                    оно
                    будет истинным. Например, вы можете проверить версию IE, используя это выражение, как показано
                    ниже:
                </p>

                <pre>
                    let isIE8 = false;
                    isIE8 = !!navigator.userAgent.match(/MSIE 8.0/);
                    console.log(isIE8); // returns true or false
            </pre>

                <p class="engJSTheory">If you don't use this expression then it returns the original value.</p>
                <p class="ruJSTheory">Если вы не используете это выражение, оно возвращает исходное значение.</p>

                <pre>
                console.log(navigator.userAgent.match(/MSIE 8.0/)); // returns either an Array or null
            </pre>

                <p class="engJSTheory">Note: The expression !! is not an operator, but it is just twice of !
                    operator</p>
                <p class="ruJSTheory">Примечание: выражение !! не является оператором, но это всего лишь двойной
                    оператор
                    "!"</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment69">
            <div class="engJSTheory">What is the purpose of the delete operator</div>
            <div class="ruJSTheory">Какова цель оператора delete</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The delete keyword is used to delete the property as well as its value.</p>
                <p class="ruJSTheory">Ключевое слово delete используется для удаления свойства объекта, а также его
                    значения.
                </p>

                <pre>
                    var user = { name: "John", age: 20 };
                    delete user.age;

                    console.log(user); // {name: "John"}
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment70">
            <div class="engJSTheory">What is typeof operator</div>
            <div class="ruJSTheory">Что такое оператор typeof</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the JavaScript typeof operator to find the type of a JavaScript
                    variable. It returns the
                    type of a variable or an expression.
                </p>
                <p class="ruJSTheory">Вы можете использовать оператор typeof JavaScript, чтобы найти тип переменной
                    JavaScript. Он возвращает
                    тип переменной или выражения.
                </p>

                <pre>
                    typeof "John Abraham"; // Returns "string"
                    typeof (1 + 2); // Returns "number"
                    typeof [1, 2, 3]; // Returns "object" because all arrays are also objects
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment71">
            <div class="engJSTheory">What is undefined property</div>
            <div class="ruJSTheory">Что такое свойство undefined</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The undefined property indicates that a variable has not been assigned a
                    value,
                    or
                    declared but not
                    initialized at all. The type of undefined value is undefined too.
                </p>
                <p class="ruJSTheory">Свойство undefined указывает, что переменной не присвоено значение или она
                    объявлена, но не
                    инициализирована вообще. Тип undefined значения также undefined.
                </p>

                <pre>
                var user; // Value is undefined, type is undefined
                console.log(typeof user); //undefined
            </pre>

                <p class="engJSTheory">Any variable can be emptied by setting the value to undefined.</p>
                <p class="ruJSTheory">Любую переменную можно очистить, установив ее значение undefined.</p>

                <pre>
                    user = undefined;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment72">
            <div class="engJSTheory">What is null value</div>
            <div class="ruJSTheory">Что такое null значение</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The value null represents the intentional absence of any object value. It is
                    one
                    of
                    JavaScript's
                    primitive values. The type of null value is object. You can empty the variable by setting the
                    value
                    to
                    null.
                </p>
                <p class="ruJSTheory">Значение null представляет намеренное отсутствие какого-либо значения объекта.
                    Это
                    одно из примитивных
                    значений JavaScript. Тип нулевого значения — объект. Вы можете очистить переменную, установив ее
                    значение равным нулю.
                </p>

                <pre>
                    var user = null;
                    console.log(typeof user); //object
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment73">
            <div class="engJSTheory">What is the difference between null and undefined</div>
            <div class="ruJSTheory">В чем разница между null и undefined</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the main differences between null and undefined:</p>
                <p class="ruJSTheory">Ниже приведены основные различия между нулевым и неопределенным:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Null</td>
                        <td>Undefined</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">It is an assignment value which indicates that variable points
                                to
                                no
                                object.
                            </div>
                            <div class="ruJSTheory">Это значение присваивания, которое указывает, что переменная не
                                указывает ни на один объект.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">It is not an assignment value where a variable has been
                                declared
                                but
                                has not yet been assigned a value.
                            </div>
                            <div class="ruJSTheory">Означает, что переменная объявлена, но не имеет значения.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Type of null is object</div>
                            <div class="ruJSTheory">Тип null — объект</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Type of undefined is undefined</div>
                            <div class="ruJSTheory">Тип undefined собственно сам undefined</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">The null value is a primitive value that represents the null,
                                empty, or
                                non-existent reference.
                            </div>
                            <div class="ruJSTheory">Значение null — это примитивное значение, которое представляет
                                нулевую,
                                пустую или несуществующую ссылку.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">The undefined value is a primitive value used when a variable
                                has
                                not
                                been assigned a value.
                            </div>
                            <div class="ruJSTheory">undefined значение — это примитивное значение, используемое,
                                когда
                                переменной не присвоено значение.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Indicates the absence of a value for a variable</div>
                            <div class="ruJSTheory">Указывает на отсутствие значения переменной</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Indicates absence of variable itself</div>
                            <div class="ruJSTheory">Указывает на отсутствие самой переменной</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Converted to zero (0) while performing primitive operations
                            </div>
                            <div class="ruJSTheory">Преобразуется в ноль (0) при выполнении примитивных операций.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">Converted to NaN while performing primitive operations</div>
                            <div class="ruJSTheory">Преобразуется в NaN при выполнении примитивных операций.</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment74">
            <div class="engJSTheory">What is eval</div>
            <div class="ruJSTheory">Что такое eval()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The eval() function evaluates JavaScript code represented as a string. The
                    string
                    can be a JavaScript
                    expression, variable, statement, or sequence of statements.
                </p>
                <p class="ruJSTheory">Функция eval() оценивает код JavaScript, представленный в виде строки. Строка
                    может
                    быть выражением
                    JavaScript, переменной, оператором или последовательностью операторов.
                </p>

                <pre>
                console.log(eval("1 + 2")); //  3
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment75">
            <div class="engJSTheory">What is the difference between window and document</div>
            <div class="ruJSTheory">В чем разница между window и document</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the main differences between window and document:</p>
                <p class="ruJSTheory">Ниже приведены основные различия между window и document:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Window</td>
                        <td>Document</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">It is the root level element in any web page</div>
                            <div class="ruJSTheory">Это элемент корневого уровня на любой веб-странице.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It is the direct child of the window object. This is also known
                                as
                                Document Object Model(DOM)
                            </div>
                            <div class="ruJSTheory">Это прямой дочерний объект объекта window. Это также известно
                                как
                                объектная модель документа (DOM).
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">By default window object is available implicitly in the page
                            </div>
                            <div class="ruJSTheory">По умолчанию объект window неявно доступен на странице.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">You can access it via window.document or document.</div>
                            <div class="ruJSTheory">Вы можете получить к нему доступ через window.document или
                                document.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">It has methods like alert(), confirm() and properties like
                                document,
                                location
                            </div>
                            <div class="ruJSTheory">Он имеет такие методы, как alert(), confirm() и такие свойства,
                                как
                                document, location.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">It provides methods like getElementById, getElementsByTagName,
                                createElement etc
                            </div>
                            <div class="ruJSTheory">Он предоставляет такие методы, как getElementById,
                                getElementsByTagName,
                                createElement и т. д.
                            </div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment76">
            <div class="engJSTheory">How do you access history in javascript</div>
            <div class="ruJSTheory">Как получить доступ к истории(history) в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The window.history object contains the browser's history. You can load
                    previous
                    and
                    next URLs in the
                    history using back() and next() methods.
                </p>
                <p class="ruJSTheory">Объект window.history содержит историю браузера. Вы можете загрузить
                    предыдущий и
                    следующий URL-адреса
                    в историю, используя методы back() и next().
                </p>

                <pre>
                    function goBack() {
                        window.history.back();
                    }
                    function goForward() {
                        window.history.forward();
                    }
                </pre>

                <p class="engJSTheory">Note: You can also access history without window prefix.</p>
                <p class="ruJSTheory">Примечание: Вы также можете получить доступ к истории без префикса window.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment77">
            <div class="engJSTheory">How do you detect caps lock key turned on or not</div>
            <div class="ruJSTheory">Как определить, включена клавиша Caps Lock или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The mouseEvent getModifierState() is used to return a boolean value that
                    indicates
                    whether the
                    specified modifier key is activated or not. The modifiers such as CapsLock, ScrollLock and
                    NumLock
                    are
                    activated when they are clicked, and deactivated when they are clicked again.
                </p>
                <p class="ruJSTheory">mouseEvent getModifierState() используется для возврата логического значения,
                    которое указывает,
                    активирована ли указанная клавиша-модификатор или нет. Модификаторы, такие как CapsLock,
                    ScrollLock
                    и
                    NumLock, активируются при нажатии на них и деактивируются при повторном нажатии.
                </p>

                <pre>
                    &lt;input type="password" onmousedown="enterInput(event)" /&gt;

                    &lt;p id="feedback"&gt;&lt;/p&gt;

                    &lt;script&gt;
                        function enterInput(e) {
                            var flag = e.getModifierState("CapsLock");
                            if (flag) {
                                document.getElementById("feedback").innerHTML = "CapsLock activated";
                            } else {
                                document.getElementById("feedback").innerHTML =
                                "CapsLock not activated";
                            }
                        }
                    &lt;/script&gt;
            </pre>
                <input aria-label="password input" type="password" onclick="enterInput(event)"/>

                <p id="feedback"></p>

                <script>
                    function enterInput(e) {
                        var flag = e.getModifierState("CapsLock");
                        if (flag) {
                            document.getElementById("feedback").innerHTML = "CapsLock activated";
                        } else {
                            document.getElementById("feedback").innerHTML =
                                "CapsLock not activated";
                        }
                    }
                </script>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment78">
            <div class="engJSTheory">What is isNaN</div>
            <div class="ruJSTheory">Что такое isNaN</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The isNaN() function is used to determine whether a value is an illegal
                    number
                    (Not-a-Number) or not.
                    i.e, This function returns true if the value equates to NaN. Otherwise it returns false.
                </p>
                <p class="ruJSTheory">Функция isNaN() используется для определения того, является ли значение
                    недопустимым
                    числом (не числом)
                    или нет. т. е. эта функция возвращает true, если значение равно NaN. В противном случае он
                    возвращает
                    false.
                </p>

                <pre>
                    isNaN("Hello"); //true
                    isNaN("100"); //false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment79">
            <div class="engJSTheory">What are the differences between undeclared and undefined variables</div>
            <div class="ruJSTheory">В чем разница между необъявленными и неопределенными переменными</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the major differences between undeclared(not defined) and undefined
                    variables:
                </p>
                <p class="ruJSTheory">Ниже приведены основные различия между необъявленными(not defined) и
                    неопределенными
                    переменными.
                </p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>undeclared</td>
                        <td>undefined</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">These variables do not exist in a program and are not declared
                            </div>
                            <div class="ruJSTheory">Эти переменные не существуют в программе и не объявлены.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">These variables declared in the program but have not assigned
                                any
                                value
                            </div>
                            <div class="ruJSTheory">Эти переменные объявлены в программе, но им не присвоено
                                никакого
                                значения.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">If you try to read the value of an undeclared variable, then a
                                runtime
                                error is encountered
                            </div>
                            <div class="ruJSTheory">Если вы попытаетесь прочитать значение необъявленной переменной,
                                то
                                возникнет runtime error
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">If you try to read the value of an undefined variable, an
                                undefined
                                value is returned.
                            </div>
                            <div class="ruJSTheory">Если вы попытаетесь прочитать значение неопределенной
                                переменной,
                                будет
                                возвращено значение undefined.
                            </div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment80">
            <div class="engJSTheory">What are global variables</div>
            <div class="ruJSTheory">Что такое глобальные переменные</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Global variables are those that are available throughout the length of the
                    code
                    without any scope.
                    That is, outside the block, function and module.
                </p>
                <p class="ruJSTheory">Глобальные переменные — это те, которые доступны по всему коду без какой-либо
                    области действия.
                    То есть вне блока, функции и модуля.
                </p>

                <pre>
                    // глобальные переменные car и year
                    let car = 'Audi';
                    let year = 2007;

                    function myFunc() {
                        // локальная переменная car
                        let car = 'Ford';
                        console.log(car); // "Ford"
                        console.log(year); // 2007
                    }
                    myFunc(); // "Audi"
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment81">
            <div class="engJSTheory">What are the problems with global variables</div>
            <div class="ruJSTheory">Какие проблемы с глобальными переменными</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The problem with global variables is the conflict of variable names of local
                    and
                    global scope. It is
                    also difficult to debug and test the code that relies on global variables.
                </p>
                <p class="ruJSTheory">Проблема с глобальными переменными заключается в конфликте имен переменных
                    локальной
                    и глобальной
                    области видимости. Также сложно отлаживать и тестировать код, использующий глобальные
                    переменные.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment82">
            <div class="engJSTheory">What is NaN property</div>
            <div class="ruJSTheory">Что такое свойство NaN</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The NaN property is a global property that represents "Not-a-Number" value.
                    i.e,
                    It
                    indicates that a
                    value is not a legal number. It is very rare to use NaN in a program but it can be used as
                    return
                    value
                    for few cases
                </p>
                <p class="ruJSTheory">Свойство NaN — это глобальное свойство, представляющее значение «Не число». т.
                    е.
                    указывает, что
                    значение не является допустимым числом. NaN используется в программе очень редко, но в некоторых
                    случаях
                    его можно использовать в качестве возвращаемого значения.
                </p>

                <pre>
                    Math.sqrt(-1);
                    parseInt("Hello");
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment83">
            <div class="engJSTheory">What is the purpose of isFinite function</div>
            <div class="ruJSTheory">Какова цель функции isFinite</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The isFinite() function is used to determine whether a number is a finite,
                    legal
                    number. It returns
                    false if the value is +infinity, -infinity, or NaN (Not-a-Number), otherwise it returns true.
                </p>
                <p class="ruJSTheory">Функция isFinite() используется для определения того, является ли число
                    конечным и
                    допустимым числом.
                    Он возвращает false, если значение равно +infinity, -infinity или NaN (не число), в противном
                    случае
                    возвращается true.
                </p>

                <pre>
                    isFinite(Infinity); // false
                    isFinite(NaN); // false
                    isFinite(-Infinity); // false

                    isFinite(100); // true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment84">
            <div class="engJSTheory">What is an event flow</div>
            <div class="ruJSTheory">Что такое поток событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Event flow is the order in which event is received on the web page. When you
                    click
                    an element that is
                    nested in various other elements, before your click actually reaches its destination, or target
                    element,
                    it must trigger the click event for each of its parent elements first, starting at the top with
                    the
                    global window object. There are two ways of event flow:
                </p>
                <p class="ruJSTheory">Поток событий — это порядок, в котором события принимаются на веб-странице.
                    Когда
                    вы
                    щелкаете элемент,
                    вложенный в различные другие элементы, прежде чем ваш щелчок действительно достигнет места
                    назначения
                    или целевого элемента, он должен сначала вызвать событие щелчка для каждого из своих
                    родительских
                    элементов, начиная сверху с объекта глобального окна. Существует два способа потока событий:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Top to Bottom(Event Capturing)</div>
                        <div class="ruJSTheory">Сверху вниз (перехват событий)</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Bottom to Top (Event Bubbling)</div>
                        <div class="ruJSTheory">Снизу вверх (всплытие событий)</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment85">
            <div class="engJSTheory">What is event bubbling</div>
            <div class="ruJSTheory">Что такое всплытие событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Event bubbling is a type of event propagation where the event first triggers
                    on
                    the
                    innermost target
                    element, and then successively triggers on the ancestors (parents) of the target element in the
                    same
                    nesting hierarchy till it reaches the outermost DOM element.
                </p>
                <p class="ruJSTheory">Всплытие событий — это тип распространения событий, при котором событие
                    сначала
                    инициируется на самом
                    внутреннем целевом элементе, а затем последовательно инициируется на предках (родителях)
                    целевого
                    элемента в той же иерархии вложенности, пока не достигнет самого внешнего элемента DOM.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment86">
            <div class="engJSTheory">What is event capturing</div>
            <div class="ruJSTheory">Что такое перехват событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Event capturing is a type of event propagation where the event is first
                    captured
                    by
                    the outermost
                    element, and then successively triggers on the descendants (children) of the target element in
                    the
                    same
                    nesting hierarchy till it reaches the innermost DOM element.
                </p>
                <p class="ruJSTheory">Перехват событий — это тип распространения событий, при котором событие
                    сначала
                    фиксируется самым
                    внешним элементом, а затем последовательно срабатывает на потомках (дочерних элементах) целевого
                    элемента в той же иерархии вложенности, пока не достигнет самого внутреннего элемента DOM.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment87">
            <div class="engJSTheory">How do you submit a form using JavaScript</div>
            <div class="ruJSTheory">Как отправить форму с помощью JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can submit a form using document.forms[0].submit(). All the form input's
                    information is submitted
                    using onsubmit event handler
                </p>
                <p class="ruJSTheory">Вы можете отправить форму, используя document.forms[0].submit(). Вся
                    информация
                    ввода формы
                    отправляется с использованием обработчика событий onsubmit.
                </p>

                <pre>
                    function submit() {
                        document.forms[0].submit();
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment88">
            <div class="engJSTheory">How do you find operating system details</div>
            <div class="ruJSTheory">Как найти сведения об операционной системе</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The window.navigator object contains information about the visitor's browser
                    OS
                    details. Some of the OS
                    properties are available under platform property:
                </p>
                <p class="ruJSTheory">Объект window.navigator содержит информацию о деталях ОС браузера посетителя.
                    Некоторые свойства ОС
                    доступны в разделе свойств платформы.
                </p>

                <pre>
                    console.log(navigator.platform);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment89">
            <div class="engJSTheory">What is the difference between document load and DOMContentLoaded events</div>
            <div class="ruJSTheory">В чем разница между загрузкой документа и событиями DOMContentLoaded</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The DOMContentLoaded event is fired when the initial HTML document has been
                    completely loaded and
                    parsed, without waiting for assets(stylesheets, images, and subframes) to finish loading.
                    Whereas
                    The
                    load event is fired when the whole page has loaded, including all dependent
                    resources(stylesheets,
                    images).
                </p>
                <p class="ruJSTheory">Событие DOMContentLoaded вызывается, когда исходный HTML-документ полностью
                    загружен
                    и проанализирован,
                    не дожидаясь завершения загрузки ресурсов (таблиц стилей, изображений и подкадров). Принимая во
                    внимание, что событие загрузки вызывается при загрузке всей страницы, включая все зависимые
                    ресурсы
                    (таблицы стилей, изображения).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment90">
            <div class="engJSTheory">What is the difference between native, host and user objects</div>
            <div class="ruJSTheory">В чем разница между собственными, хостовыми и пользовательскими объектами</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Native objects are objects that are part of the JavaScript language defined
                    by
                    the
                    ECMAScript
                    specification. For example, String, Math, RegExp, Object, Function etc core objects defined in
                    the
                    ECMAScript spec. Host objects are objects provided by the browser or runtime environment (Node).
                    For
                    example, window, XmlHttpRequest, DOM nodes etc are considered as host objects. User objects are
                    objects
                    defined in the javascript code. For example, User objects created for profile information.
                </p>
                <p class="ruJSTheory">Собственные объекты — это объекты, являющиеся частью языка JavaScript,
                    определенного
                    спецификацией
                    ECMAScript. Например, основные объекты String, Math, RegExp, Object, Function и т. д.,
                    определенные
                    в
                    спецификации ECMAScript. Хост-объекты — это объекты, предоставляемые браузером или средой
                    выполнения
                    (Node). Например, окно, XmlHttpRequest, узлы DOM и т. д. считаются объектами хоста.
                    Пользовательские
                    объекты — это объекты, определенные в коде JavaScript. Например, объекты «Пользователь»,
                    созданные
                    для
                    информации профиля.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment91">
            <div class="engJSTheory">What are the tools or techniques used for debugging JavaScript code</div>
            <div class="ruJSTheory">Какие инструменты или методы используются для отладки кода JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use below tools or techniques for debugging javascript</p>
                <p class="ruJSTheory">Вы можете использовать приведенные ниже инструменты или методы для отладки
                    JavaScript:
                </p>

                <ol>
                    <li>Chrome Devtools</li>
                    <li>
                        <div class="engJSTheory">debugger statement</div>
                        <div class="ruJSTheory">оператор debugger [1]</div>
                    </li>
                    <li>console.log()</li>
                </ol>

                <p class="engJSTheory">debugger example:</p>
                <p class="ruJSTheory">Пример debugger:</p>

                <img src="./images/debugger.png" alt="debugger" width="900">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment92">
            <div class="engJSTheory">What are the pros and cons of promises over callbacks</div>
            <div class="ruJSTheory">Каковы плюсы и минусы промисов перед обратными вызовами</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the table of pros and cons of promises over callbacks:</p>
                <p class="ruJSTheory">Ниже приведена таблица плюсов и минусов промисов перед обратными вызовами:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>+</td>
                        <td>-</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">It avoids callback hell which is unreadable</div>
                            <div class="ruJSTheory">Это позволяет избежать ада обратных вызовов, который
                                нечитабелен.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">It makes little complex code</div>
                            <div class="ruJSTheory">Это делает небольшой сложный код</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Easy to write sequential asynchronous code with .then()</div>
                            <div class="ruJSTheory">Легко писать последовательный асинхронный код с помощью .then()
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">You need to load a polyfill if ES6 is not supported</div>
                            <div class="ruJSTheory">Вам необходимо загрузить полифилл, если ES6 не поддерживается.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Easy to write parallel asynchronous code with Promise.all()
                            </div>
                            <div class="ruJSTheory">Легко писать параллельный асинхронный код с помощью
                                Promise.all()
                            </div>
                        </td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Solves some of the common problems of callbacks(call the
                                callback
                                too
                                late, too early, many times and swallow errors/exceptions)
                            </div>
                            <div class="ruJSTheory">Решает некоторые распространенные проблемы обратных вызовов
                                (вызов
                                колбэка слишком поздно, слишком рано, много раз и проглатывает ошибки/исключения).
                            </div>
                        </td>
                        <td>-</td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment93">
            <div class="engJSTheory">What is the difference between an attribute and a property</div>
            <div class="ruJSTheory">В чем разница между атрибутом и свойством</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Attributes are defined on the HTML markup whereas properties are defined on
                    the
                    DOM. For example, the
                    below HTML element has 2 attributes type and value:
                </p>
                <p class="ruJSTheory">Атрибуты определяются в разметке HTML, тогда как свойства определяются в DOM.
                    Например, приведенный
                    ниже элемент HTML имеет 2 атрибута типа и значения:
                </p>

                <pre>
                < input type="text" value="Name:" >
            </pre>

                <p class="engJSTheory">You can retrieve the attribute value as below:</p>
                <p class="ruJSTheory">Вы можете получить значение атрибута, как показано ниже:</p>

                <pre>
                    const input = document.querySelector("input");
                    console.log(input.getAttribute("value")); // Good morning
                    console.log(input.value); // Good morning
                </pre>

                <p class="engJSTheory">And after you change the value of the text field to "Good evening", it
                    becomes
                    like:
                </p>
                <p class="ruJSTheory">А после того, как вы измените значение текстового поля на «Good evening», это
                    станет
                    похоже на:
                </p>

                <pre>
                    console.log(input.getAttribute("value")); // Good evening
                    console.log(input.value); // Good evening
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment94">
            <div class="engJSTheory">What is same-origin policy</div>
            <div class="ruJSTheory">Что такое политика одного и того же происхождения</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The same-origin policy is a policy that prevents JavaScript from making
                    requests
                    across domain
                    boundaries. An origin is defined as a combination of URI scheme, hostname, and port number. If
                    you
                    enable this policy then it prevents a malicious script on one page from obtaining access to
                    sensitive
                    data on another web page using Document Object Model(DOM).
                </p>
                <p class="ruJSTheory">Политика одного и того же происхождения — это политика, которая запрещает
                    JavaScript
                    выполнять запросы
                    через границы домена. Источник определяется как комбинация схемы URI, имени хоста и номера
                    порта.
                    Если
                    вы включите эту политику, она не позволит вредоносному сценарию на одной странице получить
                    доступ к
                    конфиденциальным данным на другой веб-странице с помощью объектной модели документа (DOM).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment95">
            <div class="engJSTheory">What is the purpose of void(0)</div>
            <div class="ruJSTheory">Какова цель void(0)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Void(0) is used to prevent the page from refreshing. This will be helpful to
                    eliminate the unwanted
                    side-effect, because it will return the undefined primitive value. It is commonly used for HTML
                    documents that use href="JavaScript:Void(0);" within an < a > element. i.e, when you click a
                    link,
                    the
                    browser loads a new page or refreshes the same page. But this behavior will be prevented using
                    this
                    expression. For example, the below link notify the message without reloading the page.
                </p>
                <p class="ruJSTheory">Void(0) используется для предотвращения обновления страницы. Это поможет
                    устранить
                    нежелательный
                    побочный эффект, поскольку вернет неопределенное примитивное значение. Обычно он используется
                    для
                    HTML-документов, использующих href="JavaScript:Void(0);" внутри элемента < a >. т. е. когда вы
                    нажимаете
                    ссылку, браузер загружает новую страницу или обновляет ту же страницу. Но такое поведение будет
                    предотвращено с помощью этого выражения. Например, ссылка ниже уведомляет сообщение без
                    перезагрузки
                    страницы.
                </p>

                <pre>
                    &lt;a href="JavaScript:void(0);" onclick="alert('Well done!')"&gt;
                        Click Me!
                    &lt;/a&gt;
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment96">
            <div class="engJSTheory">Is JavaScript a compiled or interpreted language</div>
            <div class="ruJSTheory">JavaScript является компилируемым или интерпретируемым языком?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript is an interpreted language, not a compiled language. An
                    interpreter in
                    the browser reads
                    over the JavaScript code, interprets each line, and runs it. Nowadays modern browsers use a
                    technology
                    known as Just-In-Time (JIT) compilation, which compiles JavaScript to executable bytecode just
                    as it
                    is
                    about to run.
                </p>
                <p class="ruJSTheory">JavaScript — это интерпретируемый язык, а не компилируемый язык. Интерпретатор
                    в
                    браузере читает код
                    JavaScript, интерпретирует каждую строку и запускает его. В настоящее время современные браузеры
                    используют технологию, известную как компиляция Just-In-Time (JIT), которая компилирует
                    JavaScript в
                    исполняемый байт-код непосредственно перед его запуском.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment97">
            <div class="engJSTheory">Is JavaScript a case-sensitive language</div>
            <div class="ruJSTheory">Является ли JavaScript языком, чувствительным к регистру?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, JavaScript is a case sensitive language. The language keywords,
                    variables,
                    function & object
                    names, and any other identifiers must always be typed with a consistent capitalization of
                    letters.
                </p>
                <p class="ruJSTheory">Да, JavaScript — язык, чувствительный к регистру. Ключевые слова языка,
                    переменные,
                    имена функций и
                    объектов, а также любые другие идентификаторы всегда должны вводиться с использованием заглавных
                    букв.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment98">
            <div class="engJSTheory">Is there any relation between Java and JavaScript</div>
            <div class="ruJSTheory">Есть ли какая-либо связь между Java и JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, they are entirely two different programming languages and have nothing to
                    do
                    with each other. But
                    both of them are Object Oriented Programming languages and like many other languages, they
                    follow
                    similar syntax for basic features(if, else, for, switch, break, continue etc).
                </p>
                <p class="ruJSTheory">Нет, это совершенно два разных языка программирования и не имеют друг с другом
                    ничего общего. Но оба
                    они являются языками объектно-ориентированного программирования и, как и многие другие языки,
                    имеют
                    схожий синтаксис для основных функций (if, else, for, switch, break, continue и т. д.).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment99">
            <div class="engJSTheory">What are events</div>
            <div class="ruJSTheory">Что такое события</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Events are "things" that happen to HTML elements. When JavaScript is used in
                    HTML
                    pages, JavaScript can
                    react on these events. Some of the examples of HTML events are:
                </p>
                <p class="ruJSTheory">События — это «вещи», которые происходят с элементами HTML. Когда JavaScript
                    используется на страницах
                    HTML, JavaScript может реагировать на эти события. Вот некоторые примеры событий HTML:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Web page has finished loading</div>
                        <div class="ruJSTheory">Веб-страница завершила загрузку</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Input field was changed</div>
                        <div class="ruJSTheory">Поле ввода изменено</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Button was clicked</div>
                        <div class="ruJSTheory">Кнопка была нажата</div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's describe the behavior of click event for button element:</p>
                <p class="ruJSTheory">Опишем поведение события клика для элемента кнопки:</p>

                <pre>
                    &lt;!doctype html&gt;
                    &lt;html&gt;
                     &lt;head&gt;
                       &lt;script&gt;
                         function greeting() {
                             alert('Hello! Good morning');
                         }
                       &lt;/script&gt;
                     &lt;/head&gt;
                     &lt;body&gt;
                       &lt;button type="button" onclick="greeting()"&gt;Click me&lt;/button&gt;
                     &lt;/body&gt;
                    &lt;/html&gt;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment100">
            <div class="engJSTheory">Who created javascript</div>
            <div class="ruJSTheory">Кто создал JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript was created by Brendan Eich in 1995 during his time at Netscape
                    Communications. Initially it
                    was developed under the name Mocha, but later the language was officially called LiveScript when
                    it
                    first shipped in beta releases of Netscape.
                </p>
                <p class="ruJSTheory">JavaScript был создан Бренданом Эйхом в 1995 году, когда он работал в Netscape
                    Communications.
                    Первоначально он был разработан под названием Mocha, но позже язык получил официальное название
                    LiveScript, когда он впервые появился в бета-версиях Netscape.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment101">
            <div class="engJSTheory">What is the use of preventDefault method</div>
            <div class="ruJSTheory">Для чего используется метод preventDefault()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The preventDefault() method cancels the event if it is cancelable, meaning
                    that
                    the
                    default action or
                    behaviour that belongs to the event will not occur. For example, prevent form submission when
                    clicking
                    on submit button and prevent opening the page URL when clicking on hyperlink are some common use
                    cases.
                </p>
                <p class="ruJSTheory">Метод PreventDefault() отменяет событие, если оно может быть отменено. Это
                    означает,
                    что действие или
                    поведение по умолчанию, принадлежащее событию, не произойдет. Например, некоторые
                    распространенные
                    варианты использования — запретить отправку формы при нажатии кнопки отправки и запретить
                    открытие
                    URL-адреса страницы при нажатии на гиперссылку.
                </p>

                <pre>
                    document
                        .getElementById("link")
                        .addEventListener("click", function (event) {
                            event.preventDefault();
                        });
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment102">
            <div class="engJSTheory">What is the use of stopPropagation method</div>
            <div class="ruJSTheory">Для чего используется метод stopPropagation</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The stopPropagation method is used to stop the event from bubbling up the
                    event
                    chain. For example, the
                    below nested divs with stopPropagation method prevents default event propagation when clicking
                    on
                    nested
                    div(Div1)
                </p>
                <p class="ruJSTheory">Метод stopPropagation используется для предотвращения возникновения события в
                    цепочке событий.
                    Например, приведенные ниже вложенные элементы div с методом stopPropagation предотвращают
                    распространение событий по умолчанию при нажатии на вложенный элемент div (Div1).
                </p>

                <pre>
                    &lt;p&gt;Click DIV1 Element&lt;/p&gt;
                    &lt;div onclick="secondFunc()"&gt;DIV 2
                        &lt;div onclick="firstFunc(event)"&gt;DIV 1&lt;/div&gt;
                        &lt;div onclick="thirdFunc(event)"&gt;DIV 3(innered without stopPropagation)&lt;/div&gt;
                    &lt;/div&gt;

                    &lt;script&gt;
                        function firstFunc(event) {
                            alert("DIV 1");
                            event.stopPropagation();
                        }

                        function secondFunc() {
                            alert("DIV 2");
                        }
                        function thirdFunc(event){
                            alert('DIV 3')
                        }
                    &lt;/script&gt;
                </pre>
                <p>Click DIV1 Element</p>
                <div onclick="secondFunc()">DIV 2
                    <div onclick="firstFunc(event)">DIV 1</div>
                    <div onclick="thirdFunc(event)">DIV 3(innered without stopPropagation)</div>
                </div>

                <script>
                    function firstFunc(event) {
                        alert("DIV 1");
                        event.stopPropagation();
                    }

                    function secondFunc() {
                        alert("DIV 2");
                    }

                    function thirdFunc() {
                        alert('DIV 3')
                    }
                </script>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment103">
            <div class="engJSTheory">What are the steps involved in return false usage</div>
            <div class="ruJSTheory">Какие шаги выполняются при использовании return false выражения в обработчиках
                событий
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The return false statement in event handlers performs the below steps:</p>
                <p class="ruJSTheory">Оператор return false в обработчиках событий выполняет следующие шаги:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">First it stops the browser's default action or behaviour.</div>
                        <div class="ruJSTheory">Сначала он останавливает действие или поведение браузера по
                            умолчанию.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">It prevents the event from propagating the DOM</div>
                        <div class="ruJSTheory">Это предотвращает распространение события в DOM.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Stops callback execution and returns immediately when called.</div>
                        <div class="ruJSTheory">Останавливает выполнение обратного вызова и немедленно возвращает
                            результат
                            при вызове.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment104">
            <div class="engJSTheory">What is BOM (Browser Object Model)</div>
            <div class="ruJSTheory">Что такое BOM (объектная модель браузера)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Browser Object Model (BOM) allows JavaScript to "talk to" the browser. It
                    consists of the objects
                    navigator, history, screen, location and document which are children of the window. The Browser
                    Object
                    Model is not standardized and can change based on different browsers.
                </p>
                <p class="ruJSTheory">Объектная модель браузера (BOM) позволяет JavaScript «общаться» с браузером.
                    Он
                    состоит из объектов
                    navigator, history, screen, location и document, которые являются дочерними элементами window.
                    Объектная модель браузера не стандартизирована и может меняться в зависимости от браузера.
                </p>

                <img src="./images/bom.png" alt="bom" width="644">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment105">
            <div class="engJSTheory">What is the use of setTimeout</div>
            <div class="ruJSTheory">Для чего используется setTimeout</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The setTimeout() method is used to call a function or evaluate an expression
                    after
                    a specified number
                    of milliseconds. For example, let's log a message after 2 seconds using setTimeout method,
                </p>
                <p class="ruJSTheory">Метод setTimeout() используется для вызова функции или оценки выражения по
                    истечении
                    указанного
                    количества миллисекунд. Например, давайте зарегистрируем сообщение через 2 секунды, используя
                    метод
                    setTimeout:
                </p>

                <pre>
                setTimeout(function () {
                    console.log("Good morning");
                }, 2000);
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment106">
            <div class="engJSTheory">What is the use of setInterval</div>
            <div class="ruJSTheory">Для чего используется setInterval</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The setInterval() method is used to call a function or evaluate an expression
                    at
                    specified intervals
                    (in milliseconds). For example, let's log a message after 2 seconds using setInterval method:
                </p>
                <p class="ruJSTheory">Метод setInterval() используется для вызова функции или оценки выражения через
                    заданные интервалы
                    времени (в миллисекундах). Например, давайте зарегистрируем сообщение через 2 секунды, используя
                    метод
                    setInterval:
                </p>

                <pre>
                    setInterval(function () {
                        console.log("Good morning");
                    }, 2000);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment107">
            <div class="engJSTheory">Why is JavaScript treated as Single threaded</div>
            <div class="ruJSTheory">Почему JavaScript считается однопоточным</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript is a single-threaded language. Because the language specification
                    does
                    not allow the
                    programmer to write code so that the interpreter can run parts of it in parallel in multiple
                    threads
                    or
                    processes. Whereas languages like java, go, C++ can make multi-threaded and multi-process
                    programs.
                </p>
                <p class="ruJSTheory">JavaScript — это однопоточный язык. Потому что спецификация языка не позволяет
                    программисту писать код
                    так, чтобы интерпретатор мог запускать его части параллельно в нескольких потоках или процессах.
                    В
                    то
                    время как такие языки, как Java, Go, C++ позволяют создавать многопоточные и многопроцессные
                    программы.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment108">
            <div class="engJSTheory">What is an event delegation</div>
            <div class="ruJSTheory">Что такое делегирование события</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Event delegation is a technique for listening to events where you delegate a
                    parent
                    element as the
                    listener for all of the events that happen inside it.
                </p>
                <p class="ruJSTheory">Делегирование событий — это метод прослушивания событий, при котором вы
                    делегируете
                    родительский
                    элемент в качестве прослушивателя всех событий, происходящих внутри него.
                </p>

                <p class="engJSTheory">For example, if you wanted to detect field changes in inside a specific form,
                    you
                    can use event
                    delegation technique:
                </p>
                <p class="ruJSTheory">Например, если вы хотите обнаружить изменения полей внутри определенной формы,
                    вы
                    можете использовать
                    технику делегирования событий:
                </p>

                <pre>
                    var form = document.querySelector("#registration-form");

                    // Listen for changes to fields inside the form
                    form.addEventListener(
                        "input",
                        function (event) {
                            // Log the field that was changed
                            console.log(event.target);
                        },
                        false
                    );
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment109">
            <div class="engJSTheory">What is ECMAScript</div>
            <div class="ruJSTheory">Что такое ECMAScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">ECMAScript is the scripting language that forms the basis of JavaScript.
                    ECMAScript
                    standardized by the
                    ECMA International standards organization in the ECMA-262 and ECMA-402 specifications. The first
                    edition
                    of ECMAScript was released in 1997.
                </p>
                <p class="ruJSTheory">ECMAScript — это язык сценариев, лежащий в основе JavaScript. ECMAScript
                    стандартизирован международной
                    организацией по стандартизации ECMA в спецификациях ECMA-262 и ECMA-402. Первая редакция
                    ECMAScript
                    была
                    выпущена в 1997 году.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment110">
            <div class="engJSTheory">What is JSON</div>
            <div class="ruJSTheory">Что такое JSON</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JSON (JavaScript Object Notation) is a lightweight format that is used for
                    data
                    interchanging. It is
                    based on a subset of JavaScript language in the way objects are built in JavaScript.
                </p>
                <p class="ruJSTheory">JSON (нотация объектов JavaScript) — это облегченный формат, используемый для
                    обмена
                    данными. Он
                    основан на подмножестве языка JavaScript, который используется для построения объектов в
                    JavaScript.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment111">
            <div class="engJSTheory">What are the syntax rules of JSON</div>
            <div class="ruJSTheory">Каковы правила синтаксиса JSON?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of syntax rules of JSON</p>
                <p class="ruJSTheory">Ниже приведен список правил синтаксиса JSON.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The data is in name/value pairs</div>
                        <div class="ruJSTheory">Данные находятся в парах имя/значение.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">The data is separated by commas</div>
                        <div class="ruJSTheory">Данные разделяются запятыми</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Curly braces hold objects</div>
                        <div class="ruJSTheory">Фигурные скобки содержат объекты</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Square brackets hold arrays</div>
                        <div class="ruJSTheory">Квадратные скобки содержат массивы</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment112">
            <div class="engJSTheory">What is the purpose JSON.stringify()</div>
            <div class="ruJSTheory">Какова цель JSON.stringify()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">When sending data to a web server, the data has to be in a string format. You
                    can
                    achieve this by
                    converting JSON object into a string using stringify() method:
                </p>
                <p class="ruJSTheory">При отправке данных на веб-сервер данные должны быть в строковом формате. Вы
                    можете
                    добиться этого,
                    преобразовав объект JSON в строку с помощью метода stringify():
                </p>

                <pre>
                    let userJSON = { name: "John", age: 31 };
                    let userString = JSON.stringify(userJSON);
                    console.log(userString); //"{"name":"John","age":31}"
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment113">
            <div class="engJSTheory">How do you parse JSON string</div>
            <div class="ruJSTheory">Как вы анализируете(парсите) строку JSON?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">When receiving the data from a web server, the data is always in a string
                    format.
                    But you can convert
                    this string value to a javascript object using parse() method.
                </p>
                <p class="ruJSTheory">При получении данных с веб-сервера данные всегда имеют строковый формат. Но вы
                    можете преобразовать это
                    строковое значение в объект javascript, используя метод parse().
                </p>

                <pre>
                    let userString = '{"name":"John","age":31}';
                    let userJSON = JSON.parse(userString);
                    console.log(userJSON); // {name: "John", age: 31}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment114">
            <div class="engJSTheory">Why do you need JSON</div>
            <div class="ruJSTheory">Для чего нужен JSON</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">When exchanging data between a browser and a server, the data can only be
                    text.
                    Since JSON is text
                    only, it can easily be sent to and from a server, and used as a data format by any programming
                    language.
                </p>
                <p class="ruJSTheory">При обмене данными между браузером и сервером данные могут быть только
                    текстовыми.
                    Поскольку JSON — это
                    только текст, его можно легко отправлять на сервер и с него, а также использовать в качестве
                    формата
                    данных на любом языке программирования.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment115">
            <div class="engJSTheory">What are PWAs(Progressive web applications)</div>
            <div class="ruJSTheory">Что такое PWA(Progressive web applications/Прогрессивные веб-приложения)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Progressive web applications (PWAs) are a type of mobile app delivered
                    through
                    the
                    web, built using
                    common web technologies including HTML, CSS and JavaScript. These PWAs are deployed to servers,
                    accessible through URLs, and indexed by search engines.
                </p>
                <p class="ruJSTheory">Прогрессивные веб-приложения (PWA) — это тип мобильных приложений,
                    предоставляемых
                    через Интернет и
                    созданных с использованием распространенных веб-технологий, включая HTML, CSS и JavaScript. Эти
                    PWA
                    развертываются на серверах, доступны через URL-адреса и индексируются поисковыми системами.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment116">
            <div class="engJSTheory">What is the purpose of clearTimeout method</div>
            <div class="ruJSTheory">Какова цель метода clearTimeout?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The clearTimeout() function is used in javascript to clear the timeout which
                    has
                    been set by
                    setTimeout()function before that. i.e, The return value of setTimeout() function is stored in a
                    variable
                    and it’s passed into the clearTimeout() function to clear the timer.
                </p>
                <p class="ruJSTheory">Функция clearTimeout() используется в javascript для очистки таймаута,
                    установленного до этого функцией
                    setTimeout(). т. е. возвращаемое значение функции setTimeout() сохраняется в переменной и
                    передается
                    в
                    функцию clearTimeout() для очистки таймера.
                </p>

                <p class="engJSTheory">For example, the below setTimeout method is used to display the message after
                    3
                    seconds. This timeout
                    can be cleared by the clearTimeout() method.
                </p>
                <p class="ruJSTheory">Например, приведенный ниже метод setTimeout используется для отображения
                    сообщения
                    через 3 секунды.
                    Этот тайм-аут можно очистить с помощью метода clearTimeout().
                </p>

                <pre>
                    var msg;
                    function greeting() {
                        alert('Good morning');
                    }
                    function start() {
                        msg =setTimeout(greeting, 3000);
                    }

                    function stop() {
                        clearTimeout(msg);
                    }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment117">
            <div class="engJSTheory">What is the purpose of clearInterval method</div>
            <div class="ruJSTheory">Какова цель метода clearInterval</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The clearInterval() function is used in javascript to clear the interval
                    which
                    has
                    been set by
                    setInterval() function. i.e, The return value returned by setInterval() function is stored in a
                    variable
                    and it’s passed into the clearInterval() function to clear the interval.
                </p>
                <p class="ruJSTheory">Функция ClearInterval() используется в JavaScript для очистки интервала,
                    установленного функцией
                    setInterval(). т. е. возвращаемое значение, возвращаемое функцией setInterval(), сохраняется в
                    переменной и передается в функцию clearInterval() для очистки интервала.
                </p>

                <p class="engJSTheory">For example, the below setInterval method is used to display the message for
                    every
                    3 seconds. This
                    interval can be cleared by the clearInterval() method.
                </p>
                <p class="ruJSTheory">Например, приведенный ниже метод setInterval используется для отображения
                    сообщения
                    каждые 3 секунды.
                    Этот интервал можно очистить методом clearInterval().x
                </p>

                <pre>
                    var msg;
                    function greeting() {
                        alert('Good morning');
                    }
                    function start() {
                        msg = setInterval(greeting, 3000);
                    }

                    function stop() {
                        clearInterval(msg);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment118">
            <div class="engJSTheory">How do you redirect new page in javascript</div>
            <div class="ruJSTheory">Как перенаправить на новую страницу в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In vanilla javascript, you can redirect to a new page using the location
                    property
                    of window object. The syntax would be as follows:
                </p>
                <p class="ruJSTheory">В ванильном JavaScript вы можете перенаправить на новую страницу, используя
                    свойство
                    location объекта window. Синтаксис будет следующим:
                </p>

                <pre>
                    function redirect() {
                        window.location.href = "newPage.html";
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment119">
            <div class="engJSTheory">How do you check whether a string contains a substring</div>
            <div class="ruJSTheory">Как проверить, содержит ли строка подстроку</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are 3 possible ways to check whether a string contains a substring or
                    not:</p>
                <p class="ruJSTheory">Существует 3 возможных способа проверить, содержит ли строка подстроку или
                    нет:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using includes: ES6 provided String.prototype.includes method to
                            test a
                            string contains a
                            substring:
                        </div>
                        <div class="ruJSTheory">Использование includes: ES6 предоставил метод
                            String.prototype.includes
                            для
                            проверки
                            того, что строка содержит подстроку:
                        </div>
                        <pre>
                            let mainString = "hello",
                            let subString = "hell";
                            mainString.includes(subString);
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using indexOf: In an ES5 or older environment, you can use
                            String.prototype.indexOf which
                            returns the index of a substring. If the index value is not equal to -1 then it means
                            the
                            substring exists in the main string.
                        </div>
                        <div class="ruJSTheory">Использование indexOf: в среде ES5 или более ранней версии вы можете
                            использовать
                            String.prototype.indexOf, который возвращает индекс подстроки. Если значение индекса не
                            равно
                            -1, это означает, что подстрока существует в основной строке.
                        </div>
                        <pre>
                            let mainString = "hello",
                            let subString = "hell";
                            mainString.indexOf(subString) !== -1;
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using RegEx: The advanced solution is using Regular expression's
                            test
                            method(RegExp.test),
                            which allows for testing for against regular expressions
                        </div>
                        <div class="ruJSTheory">Использование RegEx: расширенное решение использует метод проверки
                            регулярных выражений
                            (RegExp.test), который позволяет проводить тестирование регулярных выражений.
                        </div>
                        <pre>
                            let mainString = "hello",
                            let regex = /hell/;
                            regex.test(mainString);
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment120">
            <div class="engJSTheory">How do you validate an email in javascript</div>
            <div class="ruJSTheory">Как проверить электронную почту в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can validate an email in javascript using regular expressions. It is
                    recommended to do validations
                    on the server side instead of the client side. Because the javascript can be disabled on the
                    client
                    side.
                </p>
                <p class="ruJSTheory">Вы можете проверить электронную почту в JavaScript, используя регулярные
                    выражения.
                    Рекомендуется
                    выполнять проверки на стороне сервера, а не на стороне клиента. Потому что JavaScript можно
                    отключить на
                    стороне клиента.
                </p>

                <pre>
                    function validateEmail(email) {
                        let re =
                            /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
                        return re.test(String(email).toLowerCase());
                    }
                </pre>

                <p class="engJSTheory">The above regular expression accepts unicode characters.</p>
                <p class="ruJSTheory">Приведенное выше регулярное выражение принимает символы Юникода.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment121">
            <div class="engJSTheory">How do you get the current url with javascript</div>
            <div class="ruJSTheory">Как получить текущий URL с помощью JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use window.location.href expression to get the current url path and
                    you
                    can
                    use the same
                    expression for updating the URL too. You can also use document.URL for read-only purposes but
                    this
                    solution has issues in FF.
                </p>
                <p class="ruJSTheory">Вы можете использовать выражение window.location.href для получения текущего
                    URL-адреса, а также
                    использовать то же выражение для обновления URL-адреса. Вы также можете использовать
                    document.URL
                    только
                    для чтения, но у этого решения есть проблемы в FF.
                </p>

                <pre>
                    console.log("location.href", window.location.href); // Returns full URL
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment122">
            <div class="engJSTheory">What are the various url properties of location object</div>
            <div class="ruJSTheory">Каковы различные свойства URL объекта location?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The below Location object properties can be used to access URL components of
                    the
                    page:
                </p>
                <p class="ruJSTheory">Приведенные ниже свойства объекта Location можно использовать для доступа к
                    компонентам URL-адреса страницы:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">href - The entire URL</div>
                        <div class="ruJSTheory">href - весь URL-адрес</div>
                    </li>
                    <li>
                        <div class="engJSTheory">protocol - The protocol of the URL</div>
                        <div class="ruJSTheory">protocol - протокол URL-адреса.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">host - The hostname and port of the URL</div>
                        <div class="ruJSTheory">host - имя хоста и порт URL-адреса.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">hostname - The hostname of the URL</div>
                        <div class="ruJSTheory">hostname - имя хоста URL-адреса.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">port - The port number in the URL</div>
                        <div class="ruJSTheory">port - номер порта в URL-адресе.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">pathname - The path name of the URL</div>
                        <div class="ruJSTheory">pathname — путь к URL-адресу.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">search - The query portion of the URL</div>
                        <div class="ruJSTheory">search - часть запроса URL-адреса.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">hash - The anchor portion of the URL</div>
                        <div class="ruJSTheory">hash - якорная часть URL-адреса.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment123">
            <div class="engJSTheory">How do get query string values in javascript</div>
            <div class="ruJSTheory">Как получить значения строки запроса в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use URLSearchParams to get query string values in javascript. Let's
                    see
                    an
                    example to get the
                    client code value from URL query string:
                </p>
                <p class="ruJSTheory">Вы можете использовать URLSearchParams для получения значений строки запроса в
                    JavaScript. Давайте
                    посмотрим пример получения значения кода клиента из строки запроса URL:
                </p>

                <pre>
                    const urlParams = new URLSearchParams(window.location.search);
                    const clientCode = urlParams.get("clientCode");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment124">
            <div class="engJSTheory">How do you check if a key exists in an object</div>
            <div class="ruJSTheory">Как проверить, существует ли ключ в объекте</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can check whether a key exists in an object or not using three
                    approaches:</p>
                <p class="ruJSTheory">Проверить, существует ли ключ в объекте или нет, можно тремя способами:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using in operator: You can use the in operator whether a key exists
                            in an object or not:
                        </div>
                        <div class="ruJSTheory">Использование оператора in: вы можете использовать оператор in
                            независимо от того, существует ли ключ в объекте или нет:
                        </div>
                        <pre>
                            "key" in obj;
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">and If you want to check if a key doesn't exist, remember to use
                            parenthesis:
                        </div>
                        <div class="ruJSTheory">и если вы хотите проверить, не существует ли ключ, не забудьте
                            использовать круглые скобки:
                        </div>
                        <pre>
                            !("key" in obj);
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using hasOwnProperty method: You can use hasOwnProperty to
                            particularly
                            test for properties of
                            the object instance (and not inherited properties):
                        </div>
                        <div class="ruJSTheory">Использование метода hasOwnProperty: вы можете использовать
                            hasOwnProperty
                            для проверки свойств
                            экземпляра объекта (а не унаследованных свойств):
                        </div>
                        <pre>
                            obj.hasOwnProperty("key"); // true
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using undefined comparison: If you access a non-existing property
                            from
                            an
                            object, the result is
                            undefined. Let’s compare the properties against undefined to determine the existence of
                            the
                            property.
                        </div>
                        <div class="ruJSTheory">Использование сравнения undefined: если вы получаете доступ к
                            несуществующему свойству
                            объекта, результат не определен. Давайте сравним свойства с undefined, чтобы определить
                            существование свойства.
                        </div>
                        <pre>
                            const user = {
                                name: "John",
                            };

                            console.log(user.name !== undefined); // true
                            console.log(user.nickName !== undefined); // false
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment125">
            <div class="engJSTheory">How do you loop through or enumerate javascript object</div>
            <div class="ruJSTheory">Как вы перебираете или перечисляете объект javascript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the for-in loop to loop through javascript object. You can also
                    make
                    sure that the key you
                    get is an actual property of an object, and doesn't come from the prototype using hasOwnProperty
                    method.
                </p>
                <p class="ruJSTheory">Вы можете использовать цикл for-in для перебора объекта javascript. Вы также
                    можете
                    убедиться, что
                    полученный вами ключ является реальным свойством объекта, а не получен из прототипа, используя
                    метод
                    hasOwnProperty.
                </p>

                <pre>
                    var object = {
                        k1: "value1",
                        k2: "value2",
                        k3: "value3",
                    };

                    for (var key in object) {
                        if (object.hasOwnProperty(key)) {
                          console.log(key + " -> " + object[key]); // k1 -> value1 ...
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment126">
            <div class="engJSTheory">How do you test for an empty object</div>
            <div class="ruJSTheory">Как проверить пустой объект</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are different solutions based on ECMAScript versions:</p>
                <p class="ruJSTheory">Существуют разные решения на основе версий ECMAScript:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using Object entries(ECMA 7+): You can use object entries length
                            along
                            with
                            constructor type.
                        </div>
                        <div class="ruJSTheory">Использование Object.entries() (ECMA 7+): вы можете использовать
                            Object.entries() вместе с типом конструктора.
                        </div>
                        <pre>
                        Object.entries(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using Object keys(ECMA 5+): You can use object keys length along
                            with
                            constructor type.
                        </div>
                        <div class="ruJSTheory">Использование Object.keys() (ECMA 5+): вы можете использовать
                            Object.keys()
                            вместе с типом конструктора.
                        </div>
                        <pre>
                        Object.keys(obj).length === 0 && obj.constructor === Object; // Since date object length is 0, you need to check constructor check as well
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using for-in with hasOwnProperty(Pre-ECMA 5): You can use a for-in
                            loop
                            along with hasOwnProperty.
                        </div>
                        <div class="ruJSTheory">Использование цикла for-in с hasOwnProperty (до ECMA 5): вы можете
                            использовать цикл for-in вместе с hasOwnProperty.
                        </div>
                        <pre>
                            function isEmpty(obj) {
                                for (const prop in obj) {
                                  if (obj.hasOwnProperty(prop)) {
                                    return false;
                                  }
                                }

                                return JSON.stringify(obj) === JSON.stringify({});
                            }
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment127">
            <div class="engJSTheory">What is an arguments object</div>
            <div class="ruJSTheory">Что такое объект arguments</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The arguments object is an Array-like object accessible inside functions that
                    contains the values of
                    the arguments passed to that function. For example, let's see how to use arguments object inside
                    sum
                    function:
                </p>
                <p class="ruJSTheory">Объект arguments — это объект типа Array, доступный внутри функций, который
                    содержит
                    значения
                    аргументов, переданных этой функции. Например, давайте посмотрим, как использовать объект
                    аргументов
                    внутри функции sum:
                </p>

                <pre>
                    function sum() {
                        let total = 0;
                        for (let i = 0, len = arguments.length; i < len; ++i) {
                          total += arguments[i];
                        }
                        return total;
                    }

                    sum(1, 2, 3); // returns 6
                </pre>

                <p class="engJSTheory">Note: You can't apply array methods on arguments object. But you can convert
                    into
                    a
                    regular array as
                    below.
                </p>
                <p class="ruJSTheory">Примечание: Вы не можете применять методы массива к объекту аргументов. Но вы
                    можете
                    преобразовать в
                    обычный массив, как показано ниже.
                </p>

                <pre>
                    const argsArray = Array.prototype.slice.call(arguments);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment128">
            <div class="engJSTheory">How do you make first letter of the string in an uppercase</div>
            <div class="ruJSTheory">Как сделать первую букву строки заглавной?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can create a function which uses a chain of string methods such as
                    charAt,
                    toUpperCase and slice
                    methods to generate a string with the first letter in uppercase.
                </p>
                <p class="ruJSTheory">Вы можете создать функцию, которая использует цепочку строковых методов, таких
                    как
                    charAt, toUpperCase
                    и методы среза, для создания строки с первой буквой в верхнем регистре.
                </p>

                <pre>
                    function capitalizeFirstLetter(string) {
                        return string.charAt(0).toUpperCase() + string.slice(1);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment129">
            <div class="engJSTheory">What are the pros and cons of for loop</div>
            <div class="ruJSTheory">Каковы плюсы и минусы цикла for?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The for-loop is a commonly used iteration syntax in javascript. It has both
                    pros
                    and cons:
                </p>
                <p class="ruJSTheory">Цикл for — это часто используемый синтаксис итерации в JavaScript. У него есть
                    как
                    плюсы, так и минусы:
                </p>

                <p>Pros(+):</p>
                <ol>
                    <li>
                        <div class="engJSTheory">Works on every environment</div>
                        <div class="ruJSTheory">Работает в любой среде</div>
                    </li>
                    <li>
                        <div class="engJSTheory">You can use break and continue flow control statements</div>
                        <div class="ruJSTheory">Вы можете использовать операторы управления потоком break и
                            continue.
                        </div>
                    </li>
                </ol>
                <p>Cons(-):</p>
                <ol>
                    <li>
                        <div class="engJSTheory">Too verbose</div>
                        <div class="ruJSTheory">Слишком многословно</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Imperative</div>
                        <div class="ruJSTheory">Императивный подход</div>
                    </li>
                    <li>
                        <div class="engJSTheory">You might face one-by-off errors</div>
                        <div class="ruJSTheory">Вы можете столкнуться с отдельными ошибками</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment130">
            <div class="engJSTheory">How do you display the current date in javascript</div>
            <div class="ruJSTheory">Как отобразить текущую дату в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use new Date() to generate a new Date object containing the current
                    date
                    and time. For example,
                    let's display the current date in mm/dd/yyyy
                </p>
                <p class="ruJSTheory">Вы можете использовать new Date() для создания нового объекта Date,
                    содержащего
                    текущую дату и время.
                    Например, давайте отобразим текущую дату в формате мм/дд/гггг.
                </p>

                <pre>
                    const todayDate = new Date();
                    const dd = String(todayDate.getDate()).padStart(2, "0");
                    const mm = String(todayDate.getMonth() + 1).padStart(2, "0"); //January is 0!
                    const yyyy = todayDate.getFullYear();

                    const today = `${mm} ${dd} ${yyyy}`;
                    console.log(today); //document.write(today);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment131">
            <div class="engJSTheory">How do you compare two date objects</div>
            <div class="ruJSTheory">Как сравнить два объекта Date</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You need to use date.getTime() method to compare date values instead of
                    comparison
                    operators (==, !=,
                    ===, and !== operators)
                </p>
                <p class="ruJSTheory">Вам нужно использовать метод date.getTime() для сравнения значений даты вместо
                    прямого сравнения, тк в переменных находятся ссылки на объекты дат
                </p>

                <pre>
                    const d1 = new Date();
                    const d2 = new Date(d1);
                    console.log(d1.getTime() === d2.getTime()); //True
                    console.log(d1 === d2); // False
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment132">
            <div class="engJSTheory">How do you check if a string starts with another string</div>
            <div class="ruJSTheory">Как проверить, начинается ли строка с искомой строки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use ECMAScript 6's String.prototype.startsWith() method to check if a
                    string starts with
                    another string or not. Let's see an example to see this
                    usage:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод String.prototype.startsWith() ECMAScript 6, чтобы
                    проверить, начинается ли
                    строка с искомой строки или нет. Давайте посмотрим
                    пример, чтобы увидеть это использование:
                </p>

                <pre>
                    "Good morning".startsWith("Good"); // true
                    "Good morning".startsWith("morning"); // false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment133">
            <div class="engJSTheory">How do you trim a string in javascript</div>
            <div class="ruJSTheory">Как обрезать строку в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript provided a trim method on string types to trim any whitespaces
                    present
                    at the beginning or
                    ending of the string.
                </p>
                <p class="ruJSTheory">В JavaScript предусмотрен метод обрезки для типов строк, позволяющий обрезать
                    любые
                    пробелы,
                    присутствующие в начале или конце строки.
                </p>

                <pre>
                "  Hello World   ".trim(); //Hello World
            </pre>

                <p class="engJSTheory">If your browser(< IE9) doesn't support this method then you can use below
                    polyfill.
                </p>
                <p class="ruJSTheory">Если ваш браузер (< IE9) не поддерживает этот метод, вы можете использовать
                    приведенный ниже
                    полифилл.
                </p>

                <pre>
                    if (!String.prototype.trim) {
                        (function () {
                            // Make sure we trim BOM and NBSP
                            let rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
                            String.prototype.trim = function () {
                                return this.replace(rtrim, "");
                            };
                        })();
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment134">
            <div class="engJSTheory">How do you add a key value pair in javascript</div>
            <div class="ruJSTheory">Как добавить пару ключ-значение в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are two possible solutions to add new properties to an object. Let's
                    take a
                    simple object to
                    explain these solutions.
                </p>
                <p class="ruJSTheory">Существует два возможных решения для добавления новых свойств к объекту.
                    Давайте
                    возьмем простой
                    объект, чтобы объяснить эти решения.
                </p>

                <pre>
                    const object = {
                        key1: value1,
                        key2: value2,
                    };
                </pre>

                <ol>
                    <li>
                        <div class="engJSTheory">Using dot notation: This solution is useful when you know the name
                            of
                            the
                            property:
                        </div>
                        <div class="ruJSTheory">Использование точечной записи: это решение полезно, если вы знаете
                            имя свойства:
                        </div>
                        <pre>
                            object.key3 = "value3";
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using square bracket notation: This solution is useful when the
                            name of
                            the
                            property is dynamically determined:
                        </div>
                        <div class="ruJSTheory">Использование квадратных скобок. Это решение полезно, когда имя
                            свойства
                            определяется динамически:
                        </div>
                        <pre>
                            object["key3"] = "value3";
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment135">
            <div class="engJSTheory">Is the !-- notation represents a special operator</div>
            <div class="ruJSTheory">Является ли обозначение !-- специальным оператором?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No,that's not a special operator. But it is a combination of 2 standard
                    operators
                    one after the
                    other:
                </p>
                <p class="ruJSTheory">Нет, это не специальный оператор. Но это комбинация двух стандартных
                    операторов
                    друг
                    за другом:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">A logical not (!)</div>
                        <div class="ruJSTheory">Логический оператор нет (!)</div>
                    </li>
                    <li>
                        <div class="engJSTheory">A prefix decrement (--)</div>
                        <div class="ruJSTheory">Декремент (--)</div>
                    </li>
                </ol>

                <p class="engJSTheory">At first, the value decremented by one and then tested to see if it is equal
                    to
                    zero or not for
                    determining the truthy/falsy value.
                </p>
                <p class="ruJSTheory">Сначала значение уменьшается на единицу, а затем проверяется, равно ли оно
                    нулю или нет, для определения истинного/ложного значения.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment136">
            <div class="engJSTheory">How do you assign default values to variables</div>
            <div>Как присвоить переменным значения по умолчанию</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the logical or operator || in an assignment expression to provide
                    a
                    default value. The
                    syntax looks like as below:
                </p>
                <p class="ruJSTheory">Вы можете использовать логический оператор или || в выражении присваивания,
                    чтобы
                    указать значение по
                    умолчанию. Синтаксис выглядит следующим образом:
                </p>

                <pre>
                    let a = b || c;
                </pre>

                <p class="engJSTheory">As per the above expression, variable 'a' will get the value of 'c' only if
                    'b'
                    is
                    falsy (if is null,
                    false, undefined, 0, empty string, or NaN), otherwise 'a' will get the value of 'b'.
                </p>
                <p class="ruJSTheory">Согласно приведенному выше выражению, переменная 'a' получит значение 'c',
                    только
                    если 'b' имеет ложное
                    значение (если оно равно null, false, undefined, 0, пустая строка или NaN), в противном
                    случае
                    'a'
                    получит значение значение 'b'.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment137">
            <div class="engJSTheory">How do you define multiline strings</div>
            <div class="ruJSTheory">Как определить многострочные строки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can define multiline string literals using the '\' character followed by
                    line
                    terminator.
                </p>
                <p class="ruJSTheory">Вы можете определить многострочные строковые литералы, используя символ '\',
                    за
                    которым следует признак
                    конца строки.
                </p>

                <pre>
                    let str =
                        "This is a \
                    very lengthy \
                    sentence!";
            </pre>

                <p class="engJSTheory">But if you have a space after the '\' character, the code will look exactly
                    the
                    same, but it will raise a SyntaxError.
                </p>
                <p class="ruJSTheory">Но если после символа '\' стоит пробел, код будет выглядеть точно так же, но
                    выдаст
                    SyntaxError.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment138">
            <div class="engJSTheory">What is an app shell model</div>
            <div class="ruJSTheory">Что такое модель оболочки приложения</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An application shell (or app shell) architecture is one way to build a
                    Progressive
                    Web App that
                    reliably and instantly loads on your users' screens, similar to what you see in native
                    applications.
                    It
                    is useful for getting some initial HTML to the screen fast without a network.
                </p>
                <p class="ruJSTheory">Архитектура оболочки приложения — это один из способов создания
                    прогрессивного веб-приложения, которое надежно и мгновенно загружается на экранах ваших
                    пользователей,
                    подобно тому, что вы видите в собственных приложениях. Это полезно для быстрого вывода исходного
                    HTML-кода на экран без подключения к сети.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment139">
            <div class="engJSTheory">Can we define properties for functions</div>
            <div class="ruJSTheory">Можем ли мы определить свойства для функций</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, We can define properties for functions because functions are also
                    objects.
                </p>
                <p class="ruJSTheory">Да, мы можем определять свойства функций, поскольку функции также являются
                    объектами.
                </p>

                <pre>
                    const fn = function (x) {
                        //Function code goes here
                    };

                    fn.userName = "John"; //fn.name -> 'fn'

                    fn.profile = function (y) {
                        //Profile code goes here
                    };
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment140">
            <div class="engJSTheory">What is the way to find the number of parameters expected by a function</div>
            <div class="ruJSTheory">Как найти количество параметров, ожидаемых функцией?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use function.length syntax to find the number of parameters expected
                    by a function. Let's take an example of sum function to calculate the sum of numbers,
                </p>
                <p class="ruJSTheory">Вы можете использовать синтаксис function.length, чтобы найти количество
                    параметров, ожидаемых функцией. Давайте возьмем пример функции sum для вычисления суммы чисел:
                </p>

                <pre>
                    function sum(num1, num2, num3, num4) {
                        return num1 + num2 + num3 + num4;
                    }
                    sum.length; // 4 is the number of parameters expected.
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment141">
            <div class="engJSTheory">What is a polyfill</div>
            <div class="ruJSTheory">Что такое полифил</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A polyfill is a piece of JS code used to provide modern functionality on
                    older
                    browsers that do not
                    natively support it. For example, Silverlight plugin polyfill can be used to mimic the
                    functionality
                    of
                    an HTML Canvas element on Microsoft Internet Explorer 7.
                </p>
                <p class="ruJSTheory">Полифил — это фрагмент JS-кода, используемый для обеспечения современных
                    функций в
                    старых браузерах,
                    которые не поддерживают его изначально. Например, полифил подключаемого модуля Silverlight можно
                    использовать для имитации функциональности элемента HTML Canvas в Microsoft Internet Explorer 7.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment142">
            <div class="engJSTheory">What are break and continue statements</div>
            <div class="ruJSTheory">Что такое операторы break и continue</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The break statement is used to "jump out" of a loop. i.e, It breaks the loop
                    and continues executing the code after the loop.</p>
                <p class="ruJSTheory">Оператор Break используется для «выхода» из цикла. т. е. он разрывает цикл и
                    продолжает выполнение кода после цикла.</p>

                <pre>
                    for (i = 0; i < 10; i++) {
                        if (i === 5) {
                          break;
                        }
                        text += "Number: " + i + "< br>";
                    }
                </pre>

                <p class="engJSTheory">The continue statement is used to "jump over" one iteration in the loop. i.e,
                    It
                    breaks one iteration
                    (in the loop), if a specified condition occurs, and continues with the next iteration in the
                    loop.
                </p>
                <p class="ruJSTheory">Оператор continue используется для «перепрыгивания» одной итерации цикла. т.
                    е. он
                    прерывает одну
                    итерацию (в цикле), если возникает указанное условие, и продолжает следующую итерацию в цикле.
                </p>

                <pre>
                    for (i = 0; i < 10; i++) {
                        if (i === 5) {
                          continue;
                        }
                        text += "Number: " + i + "< br>";
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment143">
            <div class="engJSTheory">What are js labels</div>
            <div class="ruJSTheory">Что такое js-метки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The label statement allows us to name loops and blocks in JavaScript. We can
                    then use these labels to refer back to the code later. For example,
                    the below code with labels avoids printing the numbers when they are same,</p>
                <p class="ruJSTheory">JS метка позволяет нам называть циклы и блоки в JavaScript. Затем мы можем
                    использовать эти метки, чтобы позже вернуться к коду. Например,
                    приведенный ниже код с метками позволяет избежать печати чисел, если они одинаковы.</p>

                <pre>
                    let i, j;

                    loop1: for (i = 0; i < 3; i++) {
                        loop2: for (j = 0; j < 3; j++) {
                          if (i === j) {
                            continue loop1;
                          }
                          console.log("i = " + i + ", j = " + j);
                        }
                    }

                    // Output is:
                    //   "i = 1, j = 0"
                    //   "i = 2, j = 0"
                    //   "i = 2, j = 1"
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment144">
            <div class="engJSTheory">What are the benefits of keeping declarations at the top</div>
            <div class="ruJSTheory">Каковы преимущества размещения объявлений вверху?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is recommended to keep all declarations at the top of each script or
                    function.
                    The benefits of doing
                    this are:
                </p>
                <p class="ruJSTheory">Рекомендуется хранить все объявления в начале каждого скрипта или функции.
                    Преимущества этого
                    заключаются в том:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Gives cleaner code</div>
                        <div class="ruJSTheory">Получается более чистый код</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It provides a single place to look for local variables</div>
                        <div class="ruJSTheory">Предоставляется единое место для поиска локальных переменных.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Easy to avoid unwanted global variables</div>
                        <div class="ruJSTheory">Легко избежать нежелательных глобальных переменных</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It reduces the possibility of unwanted re-declarations</div>
                        <div class="ruJSTheory">Снижается вероятность нежелательных повторных деклараций.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment145">
            <div class="engJSTheory">What are the benefits of initializing variables</div>
            <div class="ruJSTheory">Каковы преимущества инициализации переменных</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is recommended to initialize variables because of the below benefits:</p>
                <p class="ruJSTheory">Рекомендуется инициализировать переменные из-за следующих преимуществ:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">It gives cleaner code</div>
                        <div class="ruJSTheory">Получается более чистый код</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It provides a single place to initialize variables</div>
                        <div class="ruJSTheory">Предоставляется единое место для инициализации переменных.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Avoid undefined values in the code</div>
                        <div class="ruJSTheory">Избегаются undefined значения в коде</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment146">
            <div class="engJSTheory">What are the recommendations to create new object</div>
            <div class="ruJSTheory">Каковы рекомендации по созданию нового объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is recommended to avoid creating new objects using new Object(). Instead
                    you
                    can
                    initialize values
                    based on it's type to create the objects.
                </p>
                <p class="ruJSTheory">Рекомендуется избегать создания новых объектов с помощью new Object(). Вместо
                    этого
                    вы можете
                    инициализировать значения на основе их типа для создания объектов.
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Assign {} instead of new Object()</div>
                        <div class="ruJSTheory">Назначьте {} вместо new Object()</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign "" instead of new String()</div>
                        <div class="ruJSTheory">Назначьте "" вместо new String()</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign 0 instead of new Number()</div>
                        <div class="ruJSTheory">Назначьте 0 вместо new Number()</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign false instead of new Boolean()</div>
                        <div class="ruJSTheory">Назначьте false вместо new Boolean()</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign [] instead of new Array()</div>
                        <div class="ruJSTheory">Назначьте [] вместо new Array()</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign /()/ instead of new RegExp()</div>
                        <div class="ruJSTheory">Назначьте /()/ вместо new RegExp().</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assign function (){} instead of new Function()</div>
                        <div class="ruJSTheory">Назначьте function (){} вместо new Function()</div>
                    </li>
                </ol>

                <p class="engJSTheory">You can define them as an example:</p>
                <p class="ruJSTheory">Вы можете определить их в качестве примера:</p>

                <pre>
                    let v1 = {};
                    let v2 = "";
                    let v3 = 0;
                    let v4 = false;
                    let v5 = [];
                    let v6 = /()/;
                    let v7 = function () {};
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment147">
            <div class="engJSTheory">How do you define JSON arrays</div>
            <div class="ruJSTheory">Как вы обозначаете массивы JSON</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JSON arrays are written inside square brackets and arrays contain javascript
                    objects. For example, the
                    JSON array of users would be as below:
                </p>
                <p class="ruJSTheory">Массивы JSON записываются в квадратных скобках, а массивы содержат объекты
                    JavaScript. Например, массив
                    пользователей JSON будет выглядеть следующим образом:
                </p>

                <pre>
                    "users":[
                        {"firstName":"John", "lastName":"Abrahm"},
                        {"firstName":"Anna", "lastName":"Smith"},
                        {"firstName":"Shane", "lastName":"Warn"}
                    ]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment148">
            <div class="engJSTheory">How do you generate random integers</div>
            <div class="ruJSTheory">Как генерировать случайные целые числа</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use Math.random() with Math.floor() to return random integers. For
                    example,
                    if you want
                    generate random integers between 1 to 10, the multiplication factor should be 10:
                </p>
                <p class="ruJSTheory">Вы можете использовать Math.random() с Math.floor() для возврата случайных
                    целых
                    чисел. Например, если
                    вы хотите генерировать случайные целые числа от 1 до 10, коэффициент умножения должен быть 10.
                </p>

                <pre>
                    Math.floor(Math.random() * 10) + 1; // returns a random integer from 1 to 10
                    Math.floor(Math.random() * 100) + 1; // returns a random integer from 1 to 100
                </pre>

                <p class="engJSTheory">Note: Math.random() returns a random number between 0 (inclusive), and 1
                    (exclusive)
                </p>
                <p class="ruJSTheory">Примечание: Math.random() возвращает случайное число от 0 (включительно) до 1
                    (исключительно).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment149">
            <div class="engJSTheory">Can you write a random integers function to print integers with in a range
            </div>
            <div class="ruJSTheory">Можете ли вы написать функцию случайных целых чисел для печати целых чисел в
                диапазоне?
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, you can create a proper random function to return a random number
                    between min and max (both included)</p>
                <p class="ruJSTheory">Да, вы можете создать правильную генерирующую рандомное число функцию, которая
                    будет возвращать случайное число между минимальным и максимальным значением (оба включены)</p>

                <pre>
                    function randomInteger(min, max) {
                        return Math.floor(Math.random() * (max - min + 1)) + min;
                    }
                    randomInteger(1, 100); // returns a random integer from 1 to 100
                    randomInteger(1, 1000); // returns a random integer from 1 to 1000
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment150">
            <div class="engJSTheory">What is tree shaking</div>
            <div class="ruJSTheory">Что такое встряхивание дерева(tree shaking)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Tree shaking is a form of dead code elimination. It means that unused modules
                    will not be included in the bundle during the build process and for that it relies on the static
                    structure of ES2015 module syntax,( i.e. import and export). Initially this has been popularized
                    by the ES2015 module bundler rollup.</p>
                <p class="ruJSTheory">Встряхивание дерева — это форма устранения мертвого кода. Это означает, что
                    неиспользуемые модули не будут включены в пакет во время процесса сборки, и для этого он полагается
                    на статическую структуру синтаксиса модуля ES2015 (т. е. импорт и экспорт). Первоначально это было
                    популяризировано с помощью накопительного пакета модулей ES2015.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment151">
            <div class="engJSTheory">What is the need of tree shaking</div>
            <div class="ruJSTheory">Для чего нужно встряхивание дерева</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Tree Shaking can significantly reduce the code size in any application. i.e,
                    The
                    less code we send over
                    the wire the more performant the application will be. For example, if we just want to create a
                    “Hello
                    World” Application using SPA frameworks then it will take around a few MBs, but by tree shaking
                    it
                    can
                    bring down the size to just a few hundred KBs. Tree shaking is implemented in Rollup and Webpack
                    bundlers.
                </p>
                <p class="ruJSTheory">Tree Shaking может значительно уменьшить размер кода в любом приложении. т. е.
                    чем
                    меньше кода мы
                    отправим по сети, тем более производительным будет приложение. Например, если мы просто хотим
                    создать
                    приложение «Hello World» с использованием фреймворков SPA, это займет около нескольких МБ, но
                    встряхивание дерева может уменьшить размер до нескольких сотен КБ. Встряхивание дерева
                    реализовано в
                    сборщиках Rollup и Webpack.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment152">
            <div class="engJSTheory">Is it recommended to use eval</div>
            <div class="ruJSTheory">Рекомендуется ли использовать eval</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, it allows arbitrary code to be run which causes a security problem. As we
                    know
                    that the eval()
                    function is used to run text as code. In most of the cases, it should not be necessary to use
                    it.
                </p>
                <p class="ruJSTheory">Нет, он позволяет запускать произвольный код, что вызывает проблемы с
                    безопасностью.
                    Как мы знаем,
                    функция eval() используется для запуска текста как кода. В большинстве случаев необходимости в
                    его
                    использовании нет.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment153">
            <div class="engJSTheory">What is a Regular Expression</div>
            <div class="ruJSTheory">Что такое регулярное выражение</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A regular expression is a sequence of characters that forms a search pattern.
                    You
                    can use this search
                    pattern for searching data in a text. These can be used to perform all types of text search and
                    text
                    replace operations. Let's see the syntax format now:
                </p>
                <p class="ruJSTheory">Регулярное выражение — это последовательность символов, образующая шаблон
                    поиска.
                    Вы
                    можете
                    использовать этот шаблон поиска для поиска данных в тексте. Их можно использовать для выполнения
                    всех
                    типов операций текстового поиска и замены текста. Давайте теперь посмотрим на формат синтаксиса:
                </p>

                <pre>
                /pattern/modifiers;
            </pre>

                <p class="engJSTheory">For example, the regular expression or search pattern with case-insensitive
                    username would be:
                </p>
                <p class="ruJSTheory">Например, регулярное выражение или шаблон поиска с именем пользователя без
                    учета
                    регистра будет выглядеть так:
                </p>

                <pre>
                /John/i;
            </pre>
                <p>Подробнее <a
                        href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Regular_expressions"
                        target="_blank">тут.</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment154">
            <div class="engJSTheory">What are the string methods available in Regular expression</div>
            <div class="ruJSTheory">Какие строковые методы доступны в регулярном выражении</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Regular Expressions has two string methods: search() and replace(). The
                    search()
                    method uses an
                    expression to search for a match, and returns the position of the match.
                </p>
                <p class="ruJSTheory">Регулярные выражения имеют два строковых метода: search() и replace(). Метод
                    search() использует
                    выражение для поиска совпадения и возвращает позицию совпадения.
                </p>

                <pre>
                    let msg = "Hello John";
                    let n = msg.search(/John/i); // 6
                </pre>

                <p class="engJSTheory">The replace() method is used to return a modified string where the pattern is
                    replaced.
                </p>
                <p class="ruJSTheory">Метод replace() используется для возврата измененной строки, в которой заменен
                    шаблон.
                </p>

                <pre>
                    let msg = "Hello John";
                    let n = msg.replace(/John/i, "Buttler"); // Hello Buttler
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment155">
            <div class="engJSTheory">What are modifiers in regular expression</div>
            <div class="ruJSTheory">Что такое модификаторы в регулярном выражении</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Modifiers can be used to perform case-insensitive and global searches. Let's
                    list
                    down some of the
                    modifiers:
                </p>
                <p class="ruJSTheory">Модификаторы можно использовать для выполнения регистронезависимого и
                    глобального
                    поиска. Давайте
                    перечислим некоторые модификаторы:
                </p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>
                            <div class="engJSTheory">Modifier</div>
                            <div class="ruJSTheory">Модификатор</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Description</div>
                            <div class="ruJSTheory">Описание</div>
                        </td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>i</td>
                        <td>
                            <div class="engJSTheory">Perform case-insensitive matching</div>
                            <div class="ruJSTheory">Выполнить сопоставление без учета регистра</div>
                        </td>
                    </tr>
                    <tr>
                        <td>g</td>
                        <td>
                            <div class="engJSTheory">Perform a global match rather than stops at first match</div>
                            <div class="ruJSTheory">Выполните глобальное сопоставление, а не останавливайтесь на
                                первом
                                совпадении.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>m</td>
                        <td>
                            <div class="engJSTheory">Perform multiline matching</div>
                            <div class="ruJSTheory">Выполнить многострочное сопоставление</div>
                        </td>
                    </tr>
                    </tbody>
                </table>

                <p class="engJSTheory">Let's take an example of global modifier:</p>
                <p class="ruJSTheory">Давайте возьмем пример глобального модификатора:</p>

                <pre>
                    let text = "Learn JS one by one";
                    let pattern = /one/g;
                    let result = text.match(pattern); // one,one
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment156">
            <div class="engJSTheory">What are regular expression patterns</div>
            <div class="ruJSTheory">Что такое шаблоны регулярных выражений</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Regular Expressions provide a group of patterns in order to match characters.
                    Basically they are
                    categorized into 3 types:
                </p>
                <p class="ruJSTheory">Регулярные выражения предоставляют группу шаблонов для сопоставления символов.
                    В основном они делятся на 3 типа:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Brackets: These are used to find a range of characters. For
                            example,
                            below
                            are some use cases:
                        </div>
                        <div class="ruJSTheory">Скобки: они используются для поиска диапазона символов. Например,
                            ниже
                            приведены некоторые варианты использования:
                        </div>
                        <ol>
                            <li>
                                <div class="engJSTheory">[abc]: Used to find any of the characters between the
                                    brackets(a,b,c)
                                </div>
                                <div class="ruJSTheory">[abc]: используется для поиска любого символа в скобках
                                    (a,b,c).
                                </div>
                            </li>
                            <li>
                                <div class="engJSTheory">[0-9]: Used to find any of the digits between the brackets
                                </div>
                                <div class="ruJSTheory">[0-9]: используется для поиска любой цифры в скобках.</div>
                            </li>
                            <li>
                                <div class="engJSTheory">(a|b): Used to find any of the alternatives separated with
                                    |
                                </div>
                                <div class="ruJSTheory">(a|b): используется для поиска любой альтернативы,
                                    разделенной |
                                </div>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <div class="engJSTheory">Metacharacters: These are characters with a special meaning For
                            example,
                            below are some use cases:
                        </div>
                        <div class="ruJSTheory">Метасимволы: это символы, имеющие особое значение. Например, ниже
                            приведены
                            некоторые варианты использования:
                        </div>
                        <ol>
                            <li>
                                <div class="engJSTheory">\d: Used to find a digit</div>
                                <div class="ruJSTheory">\d: используется для поиска цифры.</div>
                            </li>
                            <li>
                                <div class="engJSTheory">\s: Used to find a whitespace character</div>
                                <div class="ruJSTheory">\s: используется для поиска символа пробела.</div>
                            </li>
                            <li>
                                <div class="engJSTheory">\b: Used to find a match at the beginning or ending of a
                                    word
                                </div>
                                <div class="ruJSTheory">\b: используется для поиска совпадения в начале или конце
                                    слова.
                                </div>
                            </li>
                        </ol>
                    </li>
                    <li>
                        <div class="engJSTheory">Quantifiers: These are useful to define quantities For example,
                            below
                            are
                            some use cases:
                        </div>
                        <div class="ruJSTheory">Квантификаторы: они полезны для определения количества. Например,
                            ниже
                            приведены некоторые варианты использования:
                        </div>
                        <ol>
                            <li>
                                <div class="engJSTheory">n+: Used to find matches for any string that contains at
                                    least
                                    one
                                    n
                                </div>
                                <div class="ruJSTheory">n+: используется для поиска совпадений для любой строки,
                                    содержащей
                                    хотя бы один n.
                                </div>
                            </li>
                            <li>
                                <div class="engJSTheory">n*: Used to find matches for any string that contains zero
                                    or
                                    more
                                    occurrences of n
                                </div>
                                <div class="ruJSTheory">n*: используется для поиска совпадений для любой строки,
                                    которая
                                    содержит ноль или более вхождений n.
                                </div>
                            </li>
                            <li>
                                <div class="engJSTheory">n?: Used to find matches for any string that contains zero
                                    or
                                    one
                                    occurrences of n
                                </div>
                                <div class="ruJSTheory">n?: используется для поиска совпадений для любой строки,
                                    которая
                                    содержит ноль или одно вхождение n.
                                </div>
                            </li>
                        </ol>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment157">
            <div class="engJSTheory">What is a RegExp object</div>
            <div class="ruJSTheory">Что такое объект RegExp</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">RegExp object is a regular expression object with predefined properties and
                    methods. Let's see the simple usage of RegExp object:
                </p>
                <p class="ruJSTheory">Объект RegExp — это объект регулярного выражения с предопределенными
                    свойствами и
                    методами. Давайте посмотрим простое использование объекта RegExp:
                </p>

                <pre>
                    let regexp = new RegExp("\\w+");
                    console.log(regexp);
                    // expected output: /\w+/
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment158">
            <div class="engJSTheory">How do you search a string for a pattern</div>
            <div class="ruJSTheory">Как искать строку по шаблону</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the test() method of regular expression in order to search a
                    string
                    for
                    a pattern, and return true or false depending on the result.
                </p>
                <p class="ruJSTheory">Вы можете использовать метод регулярного выражения test(), чтобы найти строку
                    по
                    шаблону и вернуть true или false в зависимости от результата.
                </p>

                <pre>
                    let pattern = /you/;
                    console.log(pattern.test("How are you?")); //true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment159">
            <div class="engJSTheory">What is the purpose of exec method</div>
            <div class="ruJSTheory">Какова цель метода exec</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The purpose of exec() method is similar to test method but it executes a
                    search for a match in a specified string and returns a result array,
                    or null instead of returning true/false.</p>
                <p class="ruJSTheory">Цель метода exec() аналогична методу test(), но он выполняет поиск совпадения
                    в указанной строке и возвращает массив результатов или значение null вместо возврата true/false.</p>

                <pre>
                    let pattern = /you/;
                    console.log(pattern.exec("How are you?")); //["you", index: 8, input: "How are you?", groups: undefined]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment160">
            <div class="engJSTheory">How do you change the style of a HTML element</div>
            <div class="ruJSTheory">Как изменить стиль HTML-элемента</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can change inline style or classname of a HTML element using
                    javascript</p>
                <p class="ruJSTheory">Вы можете изменить встроенный стиль или имя класса элемента HTML, используя
                    JavaScript.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using style property: You can modify inline style using style
                            property:
                        </div>
                        <div class="ruJSTheory">Использование свойства style: Вы можете изменить встроенный стиль,
                            используя
                            свойство style:
                        </div>
                        <pre>
                        document.getElementById("title").style.fontSize = "30px";
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using ClassName property: It is easy to modify element class using
                            className property:
                        </div>
                        <div class="ruJSTheory">Использование свойства ClassName: класс элемента легко изменить,
                            используя свойство className:
                        </div>
                        <pre>
                            document.getElementById("title").className = "custom-title";
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment161">
            <div class="engJSTheory">What would be the result of 1+2+'3'</div>
            <div class="ruJSTheory">Каким будет результат 1+2+'3'</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The output is going to be 33. Since 1 and 2 are numeric values, the result of
                    the
                    first two digits is
                    going to be a numeric value 3. The next digit is a string type value because of that the
                    addition of
                    numeric value 3 and string type value 3 is just going to be a concatenation value 33.
                </p>
                <p class="ruJSTheory">Выходные данные будут 33. Поскольку 1 и 2 являются числовыми значениями,
                    результатом
                    первых двух цифр
                    будет числовое значение 3. Следующая цифра является значением строкового типа, поскольку в
                    результате
                    сложения числового значения 3 и Значение строкового типа 3 будет просто значением конкатенации
                    33.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment162">
            <div class="engJSTheory">What is a debugger statement</div>
            <div class="ruJSTheory">Что такое оператор debugger</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The debugger statement invokes any available debugging functionality, such as
                    setting a breakpoint. If
                    no debugging functionality is available, this statement has no effect. For example, in the below
                    function a debugger statement has been inserted. So execution is paused at the debugger
                    statement
                    just
                    like a breakpoint in the script source.
                </p>
                <p class="ruJSTheory">Оператор debugger вызывает любые доступные функции отладки, например установку
                    брейкпоинта. Если
                    функции отладки недоступны, этот оператор не имеет никакого эффекта. Например, в приведенную
                    ниже
                    функцию был вставлен оператор отладчика. Таким образом, выполнение приостанавливается в
                    операторе
                    отладчика, как брейкпоинт в исходном коде сценария.
                </p>

                <pre>
                    function getProfile() {
                        // code goes here
                        debugger;
                        // code goes here
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment163">
            <div class="engJSTheory">What is the purpose of breakpoints in debugging</div>
            <div class="ruJSTheory">Какова цель точек останова(брейкпоинтов) при отладке</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can set breakpoints in the javascript code once the debugger statement is
                    executed and the debugger
                    window pops up. At each breakpoint, javascript will stop executing, and let you examine the
                    JavaScript
                    values. After examining values, you can resume the execution of code using the play button.
                </p>
                <p class="ruJSTheory">Вы можете установить точки останова(брейкпоинты) в коде JavaScript после
                    выполнения
                    оператора отладчика и появления
                    всплывающего окна отладчика. В каждой точке останова выполнение javascript прекращается и вы
                    можете
                    проверить значения JavaScript. После проверки значений вы можете возобновить выполнение кода с
                    помощью
                    кнопки воспроизведения.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment164">
            <div class="engJSTheory">Can I use reserved words as identifiers</div>
            <div class="ruJSTheory">Могу ли я использовать зарезервированные слова в качестве идентификаторов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, you cannot use the reserved words as variables, labels, object or
                    function
                    names. Let's see one
                    simple example:
                </p>
                <p class="ruJSTheory">Нет, вы не можете использовать зарезервированные слова в качестве переменных,
                    меток, имен объектов или функций. Давайте посмотрим один простой пример:</p>

                <pre>
                    let else = "hello"; // Uncaught SyntaxError: Unexpected token else
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment165">
            <div class="engJSTheory">How do you detect a mobile browser</div>
            <div class="ruJSTheory">Как определить мобильный браузер</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use regex which returns a true or false value depending on whether or
                    not
                    the user is browsing
                    with a mobile.
                </p>
                <p class="ruJSTheory">Вы можете использовать регулярное выражение, которое возвращает значение true
                    или
                    false в зависимости
                    от того, просматривает ли пользователь мобильный телефон или нет.
                </p>

                <pre>
                    window.mobilecheck = function () {
                        let mobileCheck = false;
                        (function (a) {
                          if (
                            /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(
                              a
                            ) ||
                            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(
                              a.substr(0, 4)
                            )
                          )
                            mobileCheck = true;
                        })(navigator.userAgent || navigator.vendor || window.opera);
                        return mobileCheck;
                    };
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment166">
            <div class="engJSTheory">How do you detect a mobile browser without regexp</div>
            <div class="ruJSTheory">Как определить мобильный браузер без регулярного выражения</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can detect mobile browsers by simply running through a list of devices
                    and
                    checking if the
                    useragent matches anything. This is an alternative solution for RegExp usage:
                </p>
                <p class="ruJSTheory">Вы можете обнаружить мобильные браузеры, просто просмотрев список устройств и
                    проверив, соответствует
                    ли чему-нибудь пользовательский агент. Это альтернативное решение для использования RegExp:
                </p>

                <pre>
                    function detectmob() {
                        if (
                          navigator.userAgent.match(/Android/i) ||
                          navigator.userAgent.match(/webOS/i) ||
                          navigator.userAgent.match(/iPhone/i) ||
                          navigator.userAgent.match(/iPad/i) ||
                          navigator.userAgent.match(/iPod/i) ||
                          navigator.userAgent.match(/BlackBerry/i) ||
                          navigator.userAgent.match(/Windows Phone/i)
                        ) {
                          return true;
                        } else {
                          return false;
                        }
                    }
                    detectmob();
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment167">
            <div class="engJSTheory">How do you get the image width and height using JS</div>
            <div class="ruJSTheory">Как получить ширину и высоту изображения с помощью JS?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can programmatically get the image and check the dimensions(width and
                    height)
                    using Javascript.
                </p>
                <p class="ruJSTheory">Вы можете прКаковы способы выполнения javascript после загрузки страницы?ограммно
                    получить изображение и проверить размеры (ширину и
                    высоту) с
                    помощью Javascript.
                </p>

                <pre>
                    let img = new Image();
                    img.onload = function () {
                        console.log(this.width + "x" + this.height);
                    };
                    img.src = "http://www.google.com/intl/en_ALL/images/logo.gif";
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment168">
            <div class="engJSTheory">How do you make synchronous HTTP request</div>
            <div class="ruJSTheory">Как сделать синхронный HTTP-запрос</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Browsers provide an XMLHttpRequest object which can be used to make
                    synchronous
                    HTTP requests from
                    JavaScript:
                </p>
                <p class="ruJSTheory">Браузеры предоставляют объект XMLHttpRequest, который можно использовать для
                    выполнения синхронных
                    HTTP-запросов из JavaScript.
                </p>

                <pre>
                    function httpGet(URL) {
                        let xmlHttpReq = new XMLHttpRequest();
                        xmlHttpReq.open("GET", URL, false); // false for synchronous request
                        xmlHttpReq.send(null);
                        return xmlHttpReq.responseText;
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment169">
            <div class="engJSTheory">How do you make asynchronous HTTP request</div>
            <div class="ruJSTheory">Как сделать асинхронный HTTP-запрос</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Browsers provide an XMLHttpRequest object which can be used to make
                    asynchronous
                    HTTP requests from
                    JavaScript by passing the 3rd parameter as true.
                </p>
                <p class="ruJSTheory">Браузеры предоставляют объект XMLHttpRequest, который можно использовать для
                    выполнения асинхронных
                    HTTP-запросов из JavaScript, передав третий параметр как true.
                </p>

                <pre>
                    function httpGetAsync(URL, callback) {
                        let xmlHttpReq = new XMLHttpRequest();
                        xmlHttpReq.onreadystatechange = function () {
                          if (xmlHttpReq.readyState == 4 && xmlHttpReq.status == 200)
                            callback(xmlHttpReq.responseText);
                        };
                        xmlHttpReq.open("GET", URL, true); // true for asynchronous
                        xmlHttpReq.send(null);
                    }
                </pre>

                <p class="engJSTheory">Also you can use <a href="#fetchApi">fetch</a></p>
                <p class="ruJSTheory">Так же можно использовать <a href="#fetchApi">fetch</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment170">
            <div class="engJSTheory">How do you convert date to another timezone in javascript</div>
            <div class="ruJSTheory">Как преобразовать дату в другой часовой пояс в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the toLocaleString() method to convert dates in one timezone to
                    another. For example, let's
                    convert current date to British English timezone as below:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод toLocaleString() для преобразования дат из одного
                    часового пояса в другой. Например, давайте преобразуем текущую дату в часовой пояс
                    британского английского, как показано ниже:</p>

                <pre>
                    console.log(event.toLocaleString("en-GB", { timeZone: "UTC" })); //29/06/2019, 09:56:00
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment171">
            <div class="engJSTheory">What are the properties used to get size of window</div>
            <div class="ruJSTheory">Какие свойства используются для получения размера окна</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use innerWidth, innerHeight, clientWidth, clientHeight properties of
                    windows, document element
                    and document body objects to find the size of a window. Let's use them combination of these
                    properties
                    to calculate the size of a window or document,
                </p>
                <p class="ruJSTheory">Вы можете использовать свойства InsideWidth, InternalHeight, clientWidth,
                    clientHeight окон, элементов
                    документа и объектов тела документа, чтобы определить размер окна. Давайте воспользуемся
                    комбинацией
                    этих свойств для расчета размера окна или документа.
                </p>

                <pre>
                    let width =
                        window.innerWidth ||
                        document.documentElement.clientWidth ||
                        document.body.clientWidth;

                    let height =
                        window.innerHeight ||
                        document.documentElement.clientHeight ||
                        document.body.clientHeight;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment172">
            <div class="engJSTheory">What is a conditional operator in javascript</div>
            <div class="ruJSTheory">Что такое условный(тернарный) оператор в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The conditional (ternary) operator is the only JavaScript operator that takes
                    three
                    operands which acts as a shortcut for if statements.
                </p>
                <p class="ruJSTheory">Условный (тернарный) оператор — единственный оператор JavaScript, который
                    принимает
                    три операнда и служит сокращением для операторов if.
                </p>

                <pre>
                    let isAuthenticated = false;
                    console.log(
                        isAuthenticated ? "Hello, welcome" : "Sorry, you are not authenticated"
                    ); //Sorry, you are not authenticated
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment173">
            <div class="engJSTheory">Can you apply chaining on conditional operator</div>
            <div class="ruJSTheory">Можете ли вы применить цепочку к условному оператору?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, you can apply chaining on conditional operators similar to if … else if…
                    else
                    if … else chain. The
                    syntax is going to be as below:
                </p>
                <p class="ruJSTheory">Да, вы можете применять цепочку к условным операторам, аналогично цепочке if…
                    else
                    if… else if… else.
                    Синтаксис будет таким, как показано ниже:
                </p>

                <pre>
                    function traceValue(someParam) {
                        return condition1
                            ? value1
                            : condition2
                            ? value2
                            : condition3
                            ? value3
                            : value4;
                    }

                    // The above conditional operator is equivalent to:

                    function traceValue(someParam) {
                        if (condition1) {
                          return value1;
                        } else if (condition2) {
                          return value2;
                        } else if (condition3) {
                          return value3;
                        } else {
                          return value4;
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment174">
            <div class="engJSTheory">What are the ways to execute javascript after page load</div>
            <div class="ruJSTheory">Каковы способы выполнения javascript после загрузки страницы?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can execute javascript after page load in many different ways:</p>
                <p class="ruJSTheory">Вы можете выполнить JavaScript после загрузки страницы разными способами:</p>

                <ol>
                    <li>window.onload: window.onload = function ...</li>
                    <li>document.onload: document.onload = function ...</li>
                    <li>body onload attribute: < body onload="script();"></li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment175">
            <div class="engJSTheory">What is the difference between proto and prototype</div>
            <div class="ruJSTheory">В чем разница между proto и prototype</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The __proto__ object is the actual object that is used in the lookup chain to
                    resolve methods, etc.
                    Whereas prototype is the object that is used to build __proto__ when you create an object with
                    new.
                </p>
                <p class="ruJSTheory">Объект __proto__ — это фактический объект, который используется в цепочке
                    поиска для разрешения методов и т. д. Тогда как prototype — это объект, который используется
                    для построения __proto__, когда вы создаете объект с помощью new.</p>

                <pre>
                    new Employee().__proto__ === Employee.prototype;
                    new Employee().prototype === undefined;
                </pre>

                <p class="engJSTheory">There are few more differences:</p>
                <p class="ruJSTheory">Есть еще несколько отличий:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>feature</td>
                        <td>Prototype</td>
                        <td>proto</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Access</div>
                            <div class="ruJSTheory">Доступ</div>
                        </td>
                        <td>
                            <div class="engJSTheory">All the function constructors have prototype properties.</div>
                            <div class="ruJSTheory">Все конструкторы функций имеют свойство prototype.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">All the objects have __proto__ property</div>
                            <div class="ruJSTheory">Все объекты имеют свойство __proto__.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Purpose</div>
                            <div class="ruJSTheory">Цель</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Used to reduce memory wastage with a single copy of function
                            </div>
                            <div class="ruJSTheory">Используется для уменьшения трат памяти с помощью одинарной
                                копии
                                функции.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">Used in lookup chain to resolve methods, constructors etc.
                            </div>
                            <div class="ruJSTheory">Используется в цепочке поиска для разрешения методов,
                                конструкторов
                                и т.
                                д.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>ECMAScript</td>
                        <td>
                            <div class="engJSTheory">Introduced in ES6</div>
                            <div class="ruJSTheory">Представлено в ES6</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Introduced in ES5</div>
                            <div class="ruJSTheory">Представлено в ES5</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Usage</div>
                            <div class="ruJSTheory">Применение</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Frequently used</div>
                            <div class="ruJSTheory">Часто используемый</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Rarely used</div>
                            <div class="ruJSTheory">Редко используемый</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment176">
            <div class="engJSTheory">Give an example where do you really need semicolon</div>
            <div class="ruJSTheory">Приведите пример, где действительно нужна точка с запятой</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is recommended to use semicolons after every statement in JavaScript. For
                    example, in the below case
                    it throws an error "... is not a function" at runtime due to missing semicolon.
                </p>
                <p class="ruJSTheory">Рекомендуется использовать точки с запятой после каждого оператора JavaScript.
                    Например, в приведенном
                    ниже случае во время выполнения выдается ошибка "... is not a function" из-за отсутствия точки с
                    запятой.
                </p>

                <pre>
                    // define a function
                    let fn = (function () {
                        //...
                    })(
                        // semicolon missing at this line

                        // then execute some code inside a closure
                        function () {
                            //...
                        }
                    )();
                </pre>

                <p class="engJSTheory">and it will be interpreted as:</p>
                <p class="ruJSTheory">и это будет интерпретировано как:</p>

                <pre>
                    let fn = (function () {
                        //...
                    })(function () {
                        //...
                    })();
                </pre>

                <p class="engJSTheory">In this case, we are passing the second function as an argument to the first
                    function and then trying
                    to call the result of the first function call as a function. Hence, the second function will
                    fail
                    with a
                    "... is not a function" error at runtime.
                </p>
                <p class="ruJSTheory">В этом случае мы передаем вторую функцию в качестве аргумента первой функции,
                    а
                    затем пытаемся вызвать
                    результат вызова первой функции как функцию. Следовательно, вторая функция завершится с ошибкой
                    "...
                    is
                    not a function" во время выполнения.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment177">
            <div class="engJSTheory">What is a freeze method</div>
            <div class="ruJSTheory">Что такое метод freeze()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The freeze() method is used to freeze an object. Freezing an object does not
                    allow
                    adding new
                    properties to an object,prevents from removing and prevents changing the enumerability,
                    configurability,
                    or writability of existing properties. i.e, It returns the passed object and does not create a
                    frozen
                    copy.
                </p>
                <p class="ruJSTheory">Метод Freeze() используется для замораживания объекта. Замораживание объекта
                    не позволяет добавлять к объекту новые свойства, предотвращает удаление и изменение перечисляемости,
                    возможности настройки или записи существующих свойств. т. е. он возвращает переданный
                    объект и не создает замороженную копию.</p>

                <pre>
                    const obj = {
                        prop: 100,
                    };

                    Object.freeze(obj);
                    obj.prop = 200; // Throws an error in strict mode

                    console.log(obj.prop); //100
                </pre>

                <p class="engJSTheory">Remember freezing is only applied to the top-level properties in objects but
                    not
                    for nested objects.
                    For example, let's try to freeze user object which has employment details as nested object and
                    observe
                    that details have been changed.
                </p>
                <p class="ruJSTheory">Помните, что замораживание применяется только к свойствам верхнего уровня
                    объектов,
                    но не к вложенным
                    объектам. Например, давайте попробуем заморозить объект пользователя, который содержит сведения
                    о
                    занятости в качестве вложенного объекта, и заметим, что данные были изменены.
                </p>

                <pre>
                    const user = {
                        name: "John",
                        employment: {
                          department: "IT",
                        },
                    };

                    Object.freeze(user);
                    user.employment.department = "HR";
                    console.log(user.employment.department); //HR
                </pre>

                <p class="engJSTheory">Note: It causes a TypeError if the argument passed is not an object.</p>
                <p class="ruJSTheory">Если переданный аргумент в метод freeze() не является объектом, то это вызовет
                    ошибку TypeError.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment178">
            <div class="engJSTheory">What is the purpose of freeze method</div>
            <div class="ruJSTheory">В чем суть метода freeze()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the main benefits of using freeze method:</p>
                <p class="ruJSTheory">Ниже приведены основные преимущества использования метода freeze().</p>

                <ol>
                    <li>
                        <div class="engJSTheory">It is used for freezing objects and arrays.</div>
                        <div class="ruJSTheory">Используется для замораживания объектов и массивов.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used to make an object immutable.</div>
                        <div class="ruJSTheory">Используется для того, чтобы сделать объект
                            иммутабельным(неизменяемым).
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment179">
            <div class="engJSTheory">Why do I need to use freeze method</div>
            <div class="ruJSTheory">Почему мне нужно использовать метод freeze()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In the Object-oriented paradigm, an existing API contains certain elements
                    that are not intended to be extended, modified, or re-used outside of their current context.
                    Hence it works as the final keyword which is used in various languages.</p>
                <p class="ruJSTheory">В объектно-ориентированной парадигме существующий API содержит определенные
                    элементы, которые не предназначены для расширения, изменения или повторного использования вне
                    их текущего контекста. Следовательно, оно работает как последнее ключевое слово,
                    которое используется в разных языках.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment180">
            <div class="engJSTheory">How do you detect a browser language preference</div>
            <div class="ruJSTheory">Как определить языковые предпочтения браузера</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use navigator object to detect a browser language preference as
                    below:</p>
                <p class="ruJSTheory">Вы можете использовать объект navigator для определения языковых предпочтений
                    браузера, как показано ниже:
                </p>

                <pre>
                    let language =
                        (navigator.languages && navigator.languages[0]) ||  // Chrome / Firefox
                        navigator.language ||                               // All browsers
                        navigator.userLanguage;                             // IE <= 10

                    console.log(language);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment181">
            <div class="engJSTheory">How to convert string to title case with javascript</div>
            <div class="ruJSTheory">Как преобразовать строку в регистр заголовка с помощью JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Title case means that the first letter of each word is capitalized. You can
                    convert
                    a string to title
                    case using the below function:
                </p>
                <p class="ruJSTheory">Регистр заголовка(Title case) означает, что первая буква каждого слова пишется
                    с заглавной буквы. Вы можете преобразовать строку в регистр заголовка, используя функцию ниже:</p>

                <pre>
                    function toTitleCase(str) {
                        return str.replace(/\w\S*/g, function (txt) {
                          return txt.charAt(0).toUpperCase() + txt.substring(1).toLowerCase();
                        });
                    }
                    toTitleCase("good morning john"); // Good Morning John
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment182">
            <div class="engJSTheory">How do you detect javascript disabled in the page</div>
            <div class="ruJSTheory">Как обнаружить отключен ли JavaScript на странице</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the < noscript> tag to detect javascript disabled or not. The
                    code block inside < noscript> gets executed when JavaScript is disabled, and is typically
                    used to display alternative content when the page generated in JavaScript.</p>
                <p class="ruJSTheory">Вы можете использовать тег < noscript>, чтобы определить отключенный или нет
                    JavaScript. Блок кода
                    внутри < noscript> выполняется, когда JavaScript отключен, и обычно используется для отображения
                    альтернативного контента, когда страница генерируется в JavaScript.
                </p>

                <pre>
                    &lt;script type="javascript"&gt;
                        // JS related code goes here
                    &lt;/script&gt;
                    &lt;noscript&gt;
                        &lt;a href="next_page.html?noJS=true"&gt;JavaScript is disabled in the page. Please click Next Page&lt;/a&gt;
                    &lt;/noscript&gt;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment183">
            <div class="engJSTheory">What are various operators supported by javascript</div>
            <div class="ruJSTheory">Какие операторы поддерживаются JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An operator is capable of manipulating(mathematical and logical computations)
                    a
                    certain value or
                    operand. There are various operators supported by JavaScript as below:
                </p>
                <p class="ruJSTheory">Оператор способен манипулировать (математическими и логическими вычислениями)
                    определенным значением
                    или операндом. Существуют различные операторы, поддерживаемые JavaScript, как показано ниже:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Arithmetic Operators: Includes + (Addition),– (Subtraction), *
                            (Multiplication), / (Division),
                            % (Modulus), + + (Increment) and – – (Decrement)
                        </div>
                        <div class="ruJSTheory">Арифметические операторы: Включают + (сложение), – (вычитание), *
                            (умножение), / (деление), %
                            (модуль),
                            ++ (инкремент) и –– (декремент).
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Comparison Operators: Includes == (Equal), != (Not Equal), ===
                            (Equal
                            with
                            type), > (Greater
                            than), >= (Greater than or Equal to), < (Less than), <= (Less than or Equal to)
                        </div>
                        <div class="ruJSTheory">Операторы сравнения: Включают == (Равно), != (Не Равно), === (Равно
                            по
                            типу), > (Больше),
                            >= (Больше или Равно), < (Меньше), <= (Меньше или равно)
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Logical Operators: Includes && (Logical AND), || (Logical OR), !
                            (Logical
                            NOT)
                        </div>
                        <div class="ruJSTheory">Логические операторы: Включают && (логическое И), || (логическое
                            ИЛИ), !
                            (логическое НЕ).
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Assignment Operators: Includes = (Assignment Operator), += (Add and
                            Assignment Operator),
                            –= (Subtract and Assignment Operator), *= (Multiply and Assignment), /= (Divide and
                            Assignment),
                            %= (Modules and Assignment)
                        </div>
                        <div class="ruJSTheory">Операторы присваивания: включает = (оператор присваивания), +=
                            (оператор
                            сложения и
                            присваивания), –= (оператор вычитания и присваивания), *= (умножение и присваивание),
                            /= (деление и присваивание), %= (модули и присваивание). )
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Ternary Operators: It includes conditional (: ?) Operator</div>
                        <div class="ruJSTheory">Тернарные операторы: включают условный (: ?) оператор.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">typeof Operator: It uses to find type of variable. The syntax looks
                            like
                            "typeof variableName"
                        </div>
                        <div class="ruJSTheory">Оператор typeof: используется для определения типа переменной.
                            Синтаксис
                            выглядит как "typeof variableName"
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment184">
            <div class="engJSTheory">What is a rest parameter</div>
            <div class="ruJSTheory">Что такое параметр rest</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Rest parameter is an improved way to handle function parameters which allows
                    us
                    to
                    represent an
                    indefinite number of arguments as an array. The syntax would be as below:
                </p>
                <p class="ruJSTheory">Параметр Rest — это улучшенный способ обработки параметров функции, который
                    позволяет нам представлять
                    неопределенное количество аргументов в виде массива. Синтаксис будет таким, как показано ниже:
                </p>

                <pre>
                function f(a, b, ...theArgs) {
                    // ...
                }
            </pre>

                <p class="engJSTheory">For example, let's take a sum example to calculate on dynamic number of
                    parameters:
                </p>
                <p class="ruJSTheory">Например, давайте возьмем пример суммы для расчета динамического количества
                    параметров:
                </p>

                <pre>
                    function sum(...args) {
                        let total = 0;
                        for (const i of args) {
                            total += i;
                        }
                        return total;
                    }

                    console.log(sum(1, 2)); //3
                    console.log(sum(1, 2, 3)); //6
                    console.log(sum(1, 2, 3, 4)); //10
                    console.log(sum(1, 2, 3, 4, 5)); //15
                </pre>

                <p class="engJSTheory">Note: Rest parameter is added in ES2015 or ES6</p>
                <p class="ruJSTheory">Примечание: Параметр Rest добавлен в ES2015 или ES6.</p>

            </div>
        </section>

        <h3 id="JSbasicsForEmployment185">
            <div class="engJSTheory">What happens if you do not use rest parameter as a last argument</div>
            <div class="ruJSTheory">Что произойдет, если вы не используете параметр rest в качестве последнего
                аргумента
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The rest parameter should be the last argument, as its job is to collect all
                    the remaining arguments into an array. For example, if you define a function like below it doesn’t
                    make any sense and will throw an error.
                </p>
                <p class="ruJSTheory">Параметр rest должен быть последним аргументом, поскольку его задача — собрать
                    все
                    оставшиеся аргументы
                    в массив. Например, если вы определите функцию, как показано ниже, это не будет иметь никакого
                    смысла и
                    выдаст ошибку.
                </p>

                <pre>
                function someFunc(a,…b,c){
                    //You code goes here
                    return;
                } //SyntaxError
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment186">
            <div class="engJSTheory">What are the bitwise operators available in javascript</div>
            <div class="ruJSTheory">Какие побитовые операторы доступны в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of bitwise logical operators used in JavaScript:</p>
                <p class="ruJSTheory">Ниже приведен список побитовых логических операторов, используемых в
                    JavaScript:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Bitwise AND ( & )</div>
                        <div class="ruJSTheory">Побитовое И ( & )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Bitwise OR ( | )</div>
                        <div class="ruJSTheory">Побитовое ИЛИ ( | )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Bitwise XOR ( ^ )</div>
                        <div class="ruJSTheory">Побитовое исключающее ИЛИ ( ^ )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Bitwise NOT ( ~ )</div>
                        <div class="ruJSTheory">Побитовое НЕ ( ~ )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Left Shift ( << )</div>
                        <div class="ruJSTheory">Левый сдвиг ( << )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Sign Propagating Right Shift ( >> )</div>
                        <div class="ruJSTheory">Правый сдвиг, переносящий знак ( >> )</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Zero fill Right Shift ( >>> )</div>
                        <div class="ruJSTheory">Правый сдвиг с заполнением нулями ( >>> )</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment187">
            <div class="engJSTheory">What is a spread operator</div>
            <div class="ruJSTheory">Что такое spread оператор</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Spread operator allows iterables( arrays / objects / strings ) to be expanded
                    into
                    single
                    arguments/elements. Let's take an example to see this behavior:
                </p>
                <p class="ruJSTheory">Оператор Spread позволяет разворачивать итерации (массивы/объекты/строки) в
                    отдельные
                    аргументы/элементы. Давайте рассмотрим пример, чтобы увидеть это поведение:
                </p>

                <pre>
                    function calculateSum(x, y, z) {
                        return x + y + z;
                    }

                    const numbers = [1, 2, 3];

                    console.log(calculateSum(...numbers)); // 6
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment188">
            <div class="engJSTheory">How do you determine whether object is frozen or not</div>
            <div class="ruJSTheory">Как определить, заморожен объект или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Object.isFrozen() method is used to determine if an object is frozen or
                    not.An object is frozen if all of the below conditions hold true:
                </p>
                <p class="ruJSTheory">Метод Object.isFrozen() используется для определения того, заморожен объект
                    или нет. Объект замораживается, если все следующие условия выполняются:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">If it is not extensible.</div>
                        <div class="ruJSTheory">Если он не расширяемый.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">If all of its properties are non-configurable.</div>
                        <div class="ruJSTheory">Если все его свойства ненастраиваемые.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">If all its data properties are non-writable.</div>
                        <div class="ruJSTheory">Если все его свойства данных недоступны для записи.</div>
                    </li>
                </ol>
                <div class="engJSTheory">The usage is going to be as follows:</div>
                <div class="ruJSTheory">Синтаксис выглядит следующим образом:</div>

                <pre>
                        const object = {
                            property: "Welcome JS world",
                        };
                        Object.freeze(object);
                        console.log(Object.isFrozen(object));
                    </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment189">
            <div class="engJSTheory">How do you determine two values same or not using object</div>
            <div class="ruJSTheory">Как определить одинаковы ли два значения или нет используя объект</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.is() method determines whether two values are the same value. For
                    example, the usage with
                    different types of values would be:
                </p>
                <p class="ruJSTheory">Метод Object.is() определяет, являются ли два значения одним и тем же
                    значением. Например, использование с различными типами значений будет таким:</p>

                <pre>
                    Object.is("hello", "hello"); // true
                    Object.is(window, window); // true
                    Object.is([], []); // false
                </pre>

                <p class="engJSTheory">Two values are the same if one of the following holds:</p>
                <p class="ruJSTheory">Два значения являются одинаковыми, если выполняется одно из следующих
                    условий:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">both undefined</div>
                        <div class="ruJSTheory">оба undefined</div>
                    </li>
                    <li>
                        <div class="engJSTheory">both null</div>
                        <div class="ruJSTheory">оба null</div>
                    </li>
                    <li>
                        <div class="engJSTheory">both true or both false</div>
                        <div class="ruJSTheory">оба истинны(true) или оба ложны(false)</div>
                    </li>
                    <li>
                        <div class="engJSTheory">both strings of the same length with the same characters in the
                            same
                            order
                        </div>
                        <div class="ruJSTheory">обе строки одинаковой длины с одинаковыми символами в одном и том же
                            порядке
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">both the same object (means both object have same reference)</div>
                        <div class="ruJSTheory">оба одного и того же объекта (означает, что оба объекта имеют
                            одинаковую
                            ссылку)
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">both numbers and both +0 both -0 both NaN both non-zero and both
                            not NaN and both have the same value.
                        </div>
                        <div class="ruJSTheory">оба числа и оба +0, оба -0, оба NaN, оба ненулевые, и оба не NaN, и
                            оба
                            имеют одинаковое значение.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment190">
            <div class="engJSTheory">What is the purpose of using object is method</div>
            <div class="ruJSTheory">Какая цель использования метода Object.is()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Some of the applications of Object.is method are follows:</p>
                <p class="ruJSTheory">Некоторые цели из применений метода Object.is:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">It is used for comparison of two strings.</div>
                        <div class="ruJSTheory">Используется для сравнения двух строк.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used for comparison of two numbers.</div>
                        <div class="ruJSTheory">Используется для сравнения двух чисел.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used for comparing the polarity of two numbers.</div>
                        <div class="ruJSTheory">Используется для сравнения полярности двух чисел.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used for comparison of two objects.</div>
                        <div class="ruJSTheory">Используется для сравнения двух объектов.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment191">
            <div class="engJSTheory">How do you copy properties from one object to other</div>
            <div class="ruJSTheory">Как скопировать свойства одного объекта в другой?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.assign() method which is used to copy the values and
                    properties from one or more
                    source objects to a target object. It returns the target object which has properties and values
                    copied
                    from the source objects. The syntax would be as below:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.assign(), который используется для
                    копирования
                    значений и свойств
                    из одного или нескольких исходных объектов в целевой объект. Он возвращает целевой объект,
                    свойства
                    и
                    значения которого скопированы из исходных объектов. Синтаксис будет таким, как показано ниже:
                </p>

                <pre>
                Object.assign(target, ...sources);
            </pre>

                <p class="engJSTheory">Let's take example with one source and one target object:</p>
                <p class="ruJSTheory">Давайте рассмотрим пример с одним исходным и одним целевым объектом:</p>

                <pre>
                    const target = { a: 1, b: 2 };
                    const source = { b: 3, c: 4 };

                    const returnedTarget = Object.assign(target, source);

                    console.log(target); // { a: 1, b: 3, c: 4 }

                    console.log(returnedTarget); // { a: 1, b: 3, c: 4 }
                </pre>

                <p class="engJSTheory">As observed in the above code, there is a common property(b) from source to
                    target
                    so it's value has been overwritten.
                </p>
                <p class="ruJSTheory">Как видно в приведенном выше коде, существует общее свойство (b) от источника
                    к
                    цели, поэтому его значение было перезаписано.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment192">
            <div class="engJSTheory">What are the applications of assign method</div>
            <div class="ruJSTheory">Какие есть применения метода assign?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the some of main applications of Object.assign() method:</p>
                <p class="ruJSTheory">Ниже приведены некоторые основные применения метода Object.assign():</p>

                <ol>
                    <li>
                        <div class="engJSTheory">It is used for cloning an object.</div>
                        <div class="ruJSTheory">Используется для клонирования объекта.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used to merge objects with the same properties.</div>
                        <div class="ruJSTheory">Используется для объединения объектов с одинаковыми свойствами.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment193">
            <div class="engJSTheory">What is a proxy object</div>
            <div class="ruJSTheory">Что такое объект proxy</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Proxy object is used to define custom behavior for fundamental operations
                    such
                    as property lookup,
                    assignment, enumeration, function invocation, etc. The syntax would be as follows:
                </p>
                <p class="ruJSTheory">Объект Proxy используется для определения пользовательского поведения для
                    фундаментальных операций,
                    таких как поиск свойств, присвоение, перечисление, вызов функций и т. д. Синтаксис будет
                    следующим:
                </p>

                <pre>
                    let p = new Proxy(target, handler);
                </pre>

                <p class="engJSTheory">Let's take an example of proxy object:</p>
                <p class="ruJSTheory">Давайте возьмем пример объекта proxy:</p>

                <pre>
                    let handler = {
                        get: function (obj, prop) {
                          return prop in obj ? obj[prop] : 100;
                        },
                    };

                    let p = new Proxy({}, handler);
                    p.a = 10;
                    p.b = null;

                    console.log(p.a, p.b); // 10, null
                    console.log("c" in p, p.c); // false, 100
                </pre>

                <p class="engJSTheory">In the above code, it uses get handler which define the behavior of the proxy
                    when
                    an operation is
                    performed on it
                </p>
                <p class="ruJSTheory">В приведенном выше коде используется обработчик get, который определяет
                    поведение прокси-сервера при выполнении над ним операции.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment194">
            <div class="engJSTheory">What is the purpose of seal method</div>
            <div class="ruJSTheory">В чем суть метода seal()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.seal() method is used to seal an object, by preventing new
                    properties
                    from being added to it
                    and marking all existing properties as non-configurable. But values of present properties can
                    still
                    be
                    changed as long as they are writable. Let's see the below example to understand more about
                    seal()
                    method:
                </p>
                <p class="ruJSTheory">Метод Object.seal() используется для запечатывания объекта, предотвращая
                    добавление
                    к нему новых
                    свойств и отмечая все существующие свойства как ненастраиваемые. Но значения текущих свойств все
                    равно
                    можно изменить, если они доступны для записи. Давайте посмотрим на приведенный ниже пример,
                    чтобы
                    лучше
                    понять метод seal():
                </p>

                <pre>
                    const object = {
                        property: "Welcome JS world",
                    };
                    Object.seal(object);
                    object.property = "Welcome to object world";
                    console.log(Object.isSealed(object)); // true
                    delete object.property; // You cannot delete when sealed
                    console.log(object.property); //Welcome to object world
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment195">
            <div class="engJSTheory">What are the applications of seal() method</div>
            <div class="ruJSTheory">Каковы применения метода seal()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the main applications of Object.seal() method:</p>
                <p class="ruJSTheory">Ниже приведены основные применения метода Object.seal():</p>

                <ol>
                    <li>
                        <div class="engJSTheory">It is used for sealing objects and arrays.</div>
                        <div class="ruJSTheory">Используется для запечатывания объектов и массивов.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">It is used to make an object immutable.</div>
                        <div class="ruJSTheory">Используется для того, чтобы сделать объект
                            иммутабельным(неизменяемым).
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment196">
            <div class="engJSTheory">What are the differences between freeze and seal methods</div>
            <div class="ruJSTheory">В чем разница между методами freeze() и seal()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If an object is frozen using the Object.freeze() method then its properties
                    become
                    immutable and no
                    changes can be made in them whereas if an object is sealed using the Object.seal() method then
                    the
                    changes can be made in the existing properties of the object.
                </p>
                <p class="ruJSTheory">Если объект заморожен с помощью метода Object.freeze(), его свойства
                    становятся
                    неизменяемыми и в них
                    невозможно внести изменения, тогда как если объект запечатан с помощью метода Object.seal(), то
                    изменения можно внести в существующие свойства объекта.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment197">
            <div class="engJSTheory">How do you determine if an object is sealed or not</div>
            <div class="ruJSTheory">Как определить, применен ли к объекту метод seal() или нет</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.isSealed() method is used to determine if an object is sealed or
                    not.
                    An
                    object is sealed if all of the below conditions hold true:
                </p>
                <p class="ruJSTheory">Метод Object.isSealed() используется для определения того, запечатан ли объект
                    или
                    нет. Объект запечатан, если выполняются все приведенные ниже условия:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">If it is not extensible.</div>
                        <div class="ruJSTheory">Если он не расширяемый.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">If all of its properties are non-configurable.</div>
                        <div class="ruJSTheory">Если все его свойства ненастраиваемые.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">If it is not removable (but not necessarily non-writable). Let's
                            see it
                            in
                            the action:
                        </div>
                        <div class="ruJSTheory">Если свойства неудаляемые (но не обязательно незаписываемые).
                            Давайте
                            посмотрим на это в действии:
                        </div>
                    </li>
                </ol>

                <pre>
                    const object = {
                        property: "Hello, Good morning",
                    };

                    Object.seal(object); // Using seal() method to seal the object

                    console.log(Object.isSealed(object)); // checking whether the object is sealed or not
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment198">
            <div class="engJSTheory">How do you get enumerable key and value pairs</div>
            <div class="ruJSTheory">Как получить перечислимые пары ключей и значений?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.entries() method is used to return an array of a given object's
                    own
                    enumerable string-keyed
                    property [key, value] pairs, in the same order as that provided by a for...in loop. Let's see
                    the
                    functionality of object.entries() method in an example:
                </p>
                <p class="ruJSTheory">Метод Object.entries() используется для возврата массива собственных
                    перечислимых
                    пар свойств [ключ, значение] данного объекта со строковыми ключами в том же порядке, что и в
                    цикле
                    for...in. Давайте посмотрим на функциональность метода object.entries() на примере:
                </p>

                <pre>
                    const object = {
                        a: "Good morning",
                        b: 100,
                    };

                    for (let [key, value] of Object.entries(object)) {
                        console.log(`${key}: ${value}`);
                        // a: 'Good morning'
                        // b: 100
                    }
                </pre>

                <p class="engJSTheory">Note: The order is not guaranteed as object defined.</p>
                <p class="ruJSTheory">Примечание: Порядок не гарантируется как это определено(написано) в
                    объекте.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment199">
            <div class="engJSTheory">What is the main difference between Object.values and Object.entries method
            </div>
            <div class="ruJSTheory">В чем основное различие между методом Object.values и Object.entries?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.values() method's behavior is similar to Object.entries() method
                    but
                    it
                    returns an array of
                    values instead [key,value] pairs.
                </p>
                <p class="ruJSTheory">Поведение метода Object.values() аналогично методу Object.entries(), но он
                    возвращает массив значений
                    вместо пар [ключ, значение].
                </p>

                <pre>
                    const object = {
                        a: "Good morning",
                        b: 100,
                    };

                    for (let value of Object.values(object)) {
                        console.log(`${value}`);
                        // 'Good morning'
                        // 100;
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment200">
            <div class="engJSTheory">How can you get the list of keys of any object</div>
            <div class="ruJSTheory">Как получить список ключей любого объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.keys() method which is used to return an array of a
                    given
                    object's own property
                    names, in the same order as we get with a normal loop. For example, you can get the keys of a
                    user
                    object:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.keys(), который используется для возврата
                    массива имен собственных
                    свойств данного объекта в том же порядке, что и в обычном цикле. Например, вы можете получить
                    ключи
                    пользовательского объекта:
                </p>

                <pre>
                    const user = {
                        name: "John",
                        gender: "male",
                        age: 40,
                    };

                    console.log(Object.keys(user)); //['name', 'gender', 'age']
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment201">
            <div class="engJSTheory">How do you create an object with prototype</div>
            <div class="ruJSTheory">Как создать объект с прототипом</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.create() method is used to create a new object with the specified
                    prototype object and
                    properties. i.e, It uses an existing object as the prototype of the newly created object. It
                    returns
                    a
                    new object with the specified prototype object and properties.
                </p>
                <p class="ruJSTheory">Метод Object.create() используется для создания нового объекта с указанным
                    объектом-прототипом и
                    свойствами. т. е. он использует существующий объект в качестве прототипа вновь созданного
                    объекта.
                    Он
                    возвращает новый объект с указанным объектом-прототипом и свойствами.
                </p>

                <pre>
                    const user = {
                        name: "John",
                        printInfo: function () {
                            console.log(`My name is ${this.name}.`);
                        },
                    };

                    const admin = Object.create(user);

                    admin.name = "Nick"; // Remember that "name" is a property set on "admin" but not on "user" object

                    admin.printInfo(); // My name is Nick
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment202">
            <div class="engJSTheory">What is a WeakSet</div>
            <div class="ruJSTheory">Что такое WeakSet</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">WeakSet is used to store a collection of weakly(weak references) held
                    objects.
                    The
                    syntax would be as follows:
                </p>
                <p class="ruJSTheory">WeakSet используется для хранения коллекции объектов со слабыми ссылками.
                    Синтаксис
                    будет следующим:
                </p>

                <pre>
                new WeakSet([iterable]);
            </pre>

                <p class="engJSTheory">Let's see the below example to explain it's behavior:</p>
                <p class="ruJSTheory">Давайте посмотрим на пример ниже, чтобы объяснить его поведение:</p>

                <pre>
                    let ws = new WeakSet();
                    let user = {};
                    ws.add(user);
                    ws.has(user); // true
                    ws.delete(user); // removes user from the set
                    ws.has(user); // false, user has been removed
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment203">
            <div class="engJSTheory">What are the differences between WeakSet and Set</div>
            <div class="ruJSTheory">В чем разница между WeakSet и Set</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The main difference is that references to objects in Set are strong while
                    references to objects in
                    WeakSet are weak. i.e, An object in WeakSet can be garbage collected if there is no other
                    reference
                    to
                    it. Other differences are:
                </p>
                <p class="ruJSTheory">Основное отличие состоит в том, что ссылки на объекты в Set являются сильными,
                    а
                    ссылки на объекты в
                    WeakSet — слабыми. т. е. объект в WeakSet может быть подвергнут сборке мусора, если на него нет
                    другой
                    ссылки. Другие различия заключаются в следующем:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Sets can store any value Whereas WeakSets can store only
                            collections of
                            objects
                        </div>
                        <div class="ruJSTheory">Наборы могут хранить любое значение, тогда как WeakSets могут
                            хранить
                            только
                            коллекции объектов.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakSet does not have size property unlike Set</div>
                        <div class="ruJSTheory">WeakSet не имеет свойства size, в отличие от Set.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakSet does not have methods such as clear, keys, values, entries,
                            forEach.
                        </div>
                        <div class="ruJSTheory">WeakSet не имеет таких методов, как clear, keys, values, entries,
                            forEach.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakSet is not iterable.</div>
                        <div class="ruJSTheory">WeakSet не итерируемый</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment204">
            <div class="engJSTheory">List down the collection of methods available on WeakSet</div>
            <div class="ruJSTheory">Перечислите методы, доступные в WeakSet.</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of methods available on WeakSet:</p>
                <p class="ruJSTheory">Ниже приведен список методов, доступных в WeakSet:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">add(value): A new object is appended with the given value to the
                            weakSet
                        </div>
                        <div class="ruJSTheory">add(value): новый объект добавляется с заданным значением в weakSet.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">delete(value): Deletes the value from the WeakSet collection.</div>
                        <div class="ruJSTheory">delete(value): удаляет значение из коллекции WeakSet.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">has(value): It returns true if the value is present in the WeakSet
                            Collection, otherwise it
                            returns false.
                        </div>
                        <div class="ruJSTheory">has(value): возвращает true, если значение присутствует в коллекции
                            WeakSet,
                            в противном случае
                            возвращает false.
                        </div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's see the functionality of all the above methods in an example:</p>
                <p class="ruJSTheory">Давайте посмотрим функциональность всех вышеперечисленных методов на
                    примере:</p>

                <pre>
                    let weakSetObject = new WeakSet();
                    let firstObject = {};
                    let secondObject = {};
                    // add(value)
                    weakSetObject.add(firstObject);
                    weakSetObject.add(secondObject);
                    console.log(weakSetObject.has(firstObject)); //true
                    weakSetObject.delete(secondObject);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment205">
            <div class="engJSTheory">What is a WeakMap</div>
            <div class="ruJSTheory">Что такое WeakMap</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The WeakMap object is a collection of key/value pairs in which the keys are
                    weakly
                    referenced. In this
                    case, keys must be objects and the values can be arbitrary values. The syntax is looking like as
                    below:
                </p>
                <p class="ruJSTheory">Объект WeakMap представляет собой коллекцию пар ключ/значение, в которых ключи
                    имеют
                    слабую ссылку. В
                    этом случае ключи должны быть объектами, а значения могут быть произвольными. Синтаксис выглядит
                    следующим образом:
                </p>

                <pre>
                new WeakMap([iterable]);
            </pre>

                <p class="engJSTheory">Let's see the below example to explain it's behavior:</p>
                <p class="ruJSTheory">Давайте посмотрим на пример ниже, чтобы объяснить его поведение:</p>

                <pre>
                    let ws = new WeakMap();
                    let user = {};
                    ws.set(user);
                    ws.has(user); // true
                    ws.delete(user); // removes user from the map
                    ws.has(user); // false, user has been removed
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment206">
            <div class="engJSTheory">What are the differences between WeakMap and Map</div>
            <div class="ruJSTheory">В чем разница между WeakMap и Map</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The main difference is that references to key objects in Map are strong while
                    references to key objects
                    in WeakMap are weak. i.e, A key object in WeakMap can be garbage collected if there is no other
                    reference to it. Other differences are:
                </p>
                <p class="ruJSTheory">Основное отличие состоит в том, что ссылки на ключевые объекты в Map являются
                    сильными, а ссылки на
                    ключевые объекты в WeakMap — слабыми. т. е. ключевой объект в WeakMap может быть подвергнут
                    сборке
                    мусора, если на него нет другой ссылки. Другие различия заключаются в том:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Maps can store any key type Whereas WeakMaps can store only
                            collections
                            of
                            key objects
                        </div>
                        <div class="ruJSTheory">Maps могут хранить ключи любого типа, тогда как WeakMaps могут
                            хранить
                            только коллекции ключей-объектов.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakMap does not have size property unlike Map</div>
                        <div class="ruJSTheory">WeakMap не имеет свойства size, в отличие от Map.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakMap does not have methods such as clear, keys, values, entries,
                            forEach.
                        </div>
                        <div class="ruJSTheory">WeakMap не имеет таких методов, как clear, keys, values, entries,
                            forEach.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">WeakMap is not iterable.</div>
                        <div class="ruJSTheory">WeakMap не итерируемый.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment207">
            <div class="engJSTheory">List down the collection of methods available on WeakMap.</div>
            <div class="ruJSTheory">Перечислите коллекцию методов, доступных для WeakMap.</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of methods available on WeakMap:</p>
                <p class="ruJSTheory">Ниже приведен список методов, доступных для WeakMap:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">set(key, value): Sets the value for the key in the WeakMap object.
                            Returns
                            the WeakMap
                            object.
                        </div>
                        <div class="ruJSTheory">set(key, value): устанавливает значение ключа в объекте WeakMap.
                            Возвращает
                            объект WeakMap.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">delete(key): Removes any value associated to the key.</div>
                        <div class="ruJSTheory">delete(key): удаляет любое значение, связанное с ключом.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">has(key): Returns a Boolean asserting whether a value has been
                            associated
                            to the key in the
                            WeakMap object or not.
                        </div>
                        <div class="ruJSTheory">has(key): возвращает логическое значение, подтверждающее, было ли
                            значение
                            связано с ключом в
                            объекте WeakMap или нет.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">get(key): Returns the value associated to the key, or undefined if
                            there is
                            none.
                        </div>
                        <div class="ruJSTheory">get(key): Возвращает значение, связанное с ключом, или undefined,
                            если
                            его
                            нет.
                        </div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's see the functionality of all the above methods in an example:</p>
                <p class="ruJSTheory">Давайте посмотрим функциональность всех вышеперечисленных методов на
                    примере:</p>

                <pre>
                    let weakMapObject = new WeakMap();
                    let firstObject = {};
                    let secondObject = {};
                    // set(key, value)
                    weakMapObject.set(firstObject, "John");
                    weakMapObject.set(secondObject, 100);
                    console.log(weakMapObject.has(firstObject)); //true
                    console.log(weakMapObject.get(firstObject)); // John
                    weakMapObject.delete(secondObject);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment208">
            <div class="engJSTheory">What is the purpose of uneval(deprecated)</div>
            <div class="ruJSTheory">Какова цель uneval(устарела)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The uneval() is an inbuilt function which is used to create a string
                    representation
                    of the source code
                    of an Object. It is a top-level function and is not associated with any object. Let's see the
                    below
                    example to know more about it's functionality:
                </p>
                <p class="ruJSTheory">uneval() — это встроенная функция, которая используется для создания
                    строкового
                    представления исходного
                    кода объекта. Это функция верхнего уровня, не связанная ни с каким объектом. Давайте посмотрим
                    на
                    пример
                    ниже, чтобы узнать больше о его функциональности:
                </p>

                <pre>
                    let a = 1;
                    uneval(a); // returns a String containing 1
                    uneval(function user() {}); // returns "(function user(){})"
                </pre>

                <p class="engJSTheory">The uneval() function has been deprecated. It is recommended to use
                    toString()
                    for
                    functions and
                    JSON.toStringify() for other cases.
                </p>
                <p class="ruJSTheory">Функция uneval() устарела. Рекомендуется использовать toString() для функций и
                    JSON.toStringify() для
                    других случаев.
                </p>

                <pre>
                    function user() {}
                    console.log(user.toString()); // returns "(function user(){})"
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment209">
            <div class="engJSTheory">How do you encode an URL</div>
            <div class="ruJSTheory">Как вы кодируете URL-адрес</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The encodeURI() function is used to encode complete URI which has special
                    characters except (, / ? : @ & = + $ #) characters.
                </p>
                <p class="ruJSTheory">Функция encodeURI() используется для кодирования полного URL, который содержит
                    специальные символы, за исключением символов (, / ? : @ & = + $ #).
                </p>

                <pre>
                    let uri = "https://mozilla.org/?x=шеллы";
                    let encoded = encodeURI(uri);
                    console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment210">
            <div class="engJSTheory">How do you decode an URL</div>
            <div class="ruJSTheory">Как декодировать URL</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The decodeURI() function is used to decode a Uniform Resource Identifier
                    (URI)
                    previously created by
                    encodeURI().
                </p>
                <p class="ruJSTheory">Функция decodeURI() используется для декодирования универсального
                    идентификатора
                    ресурса (URI), ранее
                    созданного функцией encodeURI().
                </p>

                <pre>
                    var uri = "https://mozilla.org/?x=шеллы";
                    var encoded = encodeURI(uri);
                    console.log(encoded); // https://mozilla.org/?x=%D1%88%D0%B5%D0%BB%D0%BB%D1%8B
                    try {
                        console.log(decodeURI(encoded)); // "https://mozilla.org/?x=шеллы"
                    } catch (e) {
                        // catches a malformed URI
                        console.error(e);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment211">
            <div class="engJSTheory">How do you print the contents of web page</div>
            <div class="ruJSTheory">Как распечатать содержимое веб-страницы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The window object provided a print() method which is used to print the
                    contents
                    of
                    the current window.
                    It opens a Print dialog box which lets you choose between various printing options. Let's see
                    the
                    usage
                    of print method in an example:
                </p>
                <p class="ruJSTheory">Объект window предоставил метод print(), который используется для печати
                    содержимого
                    текущего окна.
                    Откроется диалоговое окно «Печать», в котором можно выбрать различные параметры печати. Давайте
                    посмотрим на использование метода print на примере:
                </p>

                <pre>
                < input type="button" value="Print" onclick="window.print()" />
            </pre>
                <input type="button" value="Print" onclick="window.print()"/>

                <p class="engJSTheory">Note: In most browsers, it will block while the print dialog is open.</p>
                <p class="ruJSTheory">Примечание: В большинстве браузеров он блокируется, пока открыто диалоговое
                    окно
                    печати.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment212">
            <div class="engJSTheory">What is the difference between uneval and eval</div>
            <div class="ruJSTheory">В чем разница между uneval и eval</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The uneval function returns the source of a given object; whereas the eval
                    function
                    does the opposite,
                    by evaluating that source code in a different memory area. Let's see an example to clarify the
                    difference:
                </p>
                <p class="ruJSTheory">Функция uneval возвращает источник данного объекта; тогда как функция eval
                    делает
                    противоположное,
                    оценивая этот исходный код в другой области памяти. Давайте посмотрим пример, чтобы прояснить
                    разницу:
                </p>

                <pre>
                    let msg = uneval(function greeting() {
                        return "Hello, Good morning";
                    });
                    let greeting = eval(msg);
                    greeting(); // returns "Hello, Good morning"
                </pre>
                <p>Uneval - DEPRECATED!!!</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment213">
            <div class="engJSTheory">What is an anonymous function</div>
            <div class="ruJSTheory">Что такое анонимная функция</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An anonymous function is a function without a name! Anonymous functions are
                    commonly assigned to a
                    variable name or used as a callback function. The syntax would be as below:
                </p>
                <p class="ruJSTheory">Анонимная функция — это функция без имени! Анонимные функции обычно
                    присваиваются
                    имени переменной или
                    используются в качестве функции обратного вызова. Синтаксис будет таким, как показано ниже:
                </p>

                <pre>
                    function (optionalParameters) {
                        //do something
                    }

                    const myFunction = function(){ //Anonymous function assigned to a variable
                        //do something
                    };

                    [1, 2, 3].map(function(element){ //Anonymous function used as a callback function
                        //do something
                    });
                </pre>

                <p class="engJSTheory">Let's see the above anonymous function in an example:</p>
                <p class="ruJSTheory">Давайте посмотрим на приведенную выше анонимную функцию на примере:</p>

                <pre>
                    let x = function (a, b) {
                        return a * b;
                    };
                    let z = x(5, 10);
                    console.log(z); // 50
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment214">
            <div class="engJSTheory">What is the precedence order between local and global variables</div>
            <div class="ruJSTheory">Каков порядок приоритета между локальными и глобальными переменными?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A local variable takes precedence over a global variable with the same name.
                    Let's
                    see this behavior in
                    an example:
                </p>
                <p class="ruJSTheory">Локальная переменная имеет приоритет над глобальной переменной с тем же
                    именем.
                    Давайте посмотрим на
                    это поведение на примере:
                </p>

                <pre>
                    var msg = "Good morning";
                    function greeting() {
                        msg = "Good Evening";
                        console.log(msg); // Good Evening
                    }
                    greeting();
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment215">
            <div class="engJSTheory">What are javascript accessors</div>
            <div class="ruJSTheory">Что такое аксессоры JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">ECMAScript 5 introduced javascript object accessors or computed properties
                    through
                    getters and setters.
                    Getters uses the get keyword whereas Setters uses the set keyword.
                </p>
                <p class="ruJSTheory">ECMAScript 5 представил средства доступа к объектам JavaScript или вычисляемые
                    свойства через геттеры и
                    сеттеры. Getters использует ключевое слово get, тогда как Setters использует ключевое слово set.
                </p>

                <pre>
                    let user = {
                        firstName: "John",
                        lastName: "Abraham",
                        language: "en",
                        get lang() {
                          return this.language;
                        },
                        set lang(lang) {
                          this.language = lang;
                        },
                    };
                    console.log(user.lang); // getter access lang as en
                    user.lang = "fr";
                    console.log(user.lang); // setter used to set lang as fr
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment216">
            <div class="engJSTheory">How do you define property on Object constructor</div>
            <div class="ruJSTheory">Как определить свойство в конструкторе объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.defineProperty() static method is used to define a new property
                    directly
                    on an object, or
                    modify an existing property on an object, and returns the object. Let's see an example to know
                    how
                    to
                    define property:
                </p>
                <p class="ruJSTheory">Статический метод Object.defineProperty() используется для определения нового
                    свойства непосредственно
                    объекта или изменения существующего свойства объекта и возвращает объект. Давайте посмотрим
                    пример,
                    чтобы узнать, как определить свойство:
                </p>

                <pre>
                    const newObject = {};

                    Object.defineProperty(newObject, "newProperty", {
                        value: 100,
                        writable: false,
                    });

                    console.log(newObject.newProperty); // 100

                    newObject.newProperty = 200; // It throws an error in strict mode due to writable setting
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment217">
            <div class="engJSTheory">What is the difference between get and defineProperty</div>
            <div class="ruJSTheory">В чем разница между get и defineProperty</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Both have similar results until unless you use classes. If you use get the
                    property
                    will be defined on
                    the prototype of the object whereas using Object.defineProperty() the property will be defined
                    on
                    the
                    instance it is applied to.
                </p>
                <p class="ruJSTheory">Оба имеют схожие результаты, пока вы не используете классы. Если вы
                    используете get, свойство будет определено в прототипе объекта, тогда как при использовании
                    Object.defineProperty() свойство будет определено в экземпляре, к которому оно применяется.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment218">
            <div class="engJSTheory">What are the advantages of Getters and Setters</div>
            <div class="ruJSTheory">Каковы преимущества геттеров и сеттеров</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of benefits of Getters and Setters:</p>
                <p class="ruJSTheory">Ниже приведен список преимуществ геттеров и сеттеров:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">They provide simpler syntax</div>
                        <div class="ruJSTheory">Они обеспечивают более простой синтаксис</div>
                    </li>
                    <li>
                        <div class="engJSTheory">They are used for defining computed properties, or accessors in JS.
                        </div>
                        <div class="ruJSTheory">Они используются для определения вычисляемых свойств или средств
                            доступа
                            в
                            JS.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Useful to provide equivalence relation between properties and
                            methods
                        </div>
                        <div class="ruJSTheory">Полезно для обеспечения отношения эквивалентности между свойствами и
                            методами.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">They can provide better data quality</div>
                        <div class="ruJSTheory">Они могут обеспечить лучшее качество данных</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Useful for doing things behind the scenes with the encapsulated
                            logic.
                        </div>
                        <div class="ruJSTheory">Полезно для скрытых действий с инкапсулированной логикой.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment219">
            <div class="engJSTheory">Can I add getters and setters using defineProperty method</div>
            <div class="ruJSTheory">Могу ли я добавить геттеры и сеттеры, используя метод defineProperty?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, You can use the Object.defineProperty() method to add Getters and
                    Setters.
                    For
                    example, the below
                    counter object uses increment, decrement, add and subtract properties:
                </p>
                <p class="ruJSTheory">Да, вы можете использовать метод Object.defineProperty() для добавления
                    геттеров и
                    сеттеров. Например,
                    приведенный ниже объект счетчика использует свойства увеличения, уменьшения, добавления и
                    вычитания.
                </p>

                <pre>
                    let obj = { counter: 0 };

                    // Define getters
                    Object.defineProperty(obj, "increment", {
                        get: function () {
                          this.counter++;
                        },
                    });
                    Object.defineProperty(obj, "decrement", {
                        get: function () {
                          this.counter--;
                        },
                    });

                    // Define setters
                    Object.defineProperty(obj, "add", {
                        set: function (value) {
                          this.counter += value;
                        },
                    });
                    Object.defineProperty(obj, "subtract", {
                        set: function (value) {
                          this.counter -= value;
                        },
                    });

                    obj.add = 10;
                    obj.subtract = 5;
                    console.log(obj.increment); //6
                    console.log(obj.decrement); //5
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment220">
            <div class="engJSTheory">What is the purpose of switch-case</div>
            <div class="ruJSTheory">Какова цель switch-case</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The switch case statement in JavaScript is used for decision making purposes.
                    In
                    a
                    few cases, using the
                    switch case statement is going to be more convenient than if-else statements. The syntax would
                    be as
                    below:
                </p>
                <p class="ruJSTheory">Оператор switch case в JavaScript используется для принятия решений. В
                    некоторых
                    случаях
                    использование оператора Switch Case будет более удобным, чем операторов if-else. Синтаксис будет
                    таким,
                    как показано ниже:
                </p>

                <pre>
                    switch (expression) {
                        case value1:
                            statement1;
                            break;
                        case value2:
                            statement2;
                            break;
                        .
                        .
                        case valueN:
                            statementN;
                            break;
                        default:
                            statementDefault;
                    }
                </pre>

                <p class="engJSTheory">The above multi-way branch statement provides an easy way to dispatch
                    execution
                    to
                    different parts of
                    code based on the value of the expression.
                </p>
                <p class="ruJSTheory">Приведенный выше оператор многопутевого ветвления обеспечивает простой способ
                    распределения выполнения
                    различных частей кода в зависимости от значения выражения.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment221">
            <div class="engJSTheory">What are the conventions to be followed for the usage of switch case</div>
            <div class="ruJSTheory">Каковы правила использования switch case?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of conventions should be taken care:</p>
                <p class="ruJSTheory">Ниже приведен список соглашений, на которые следует обратить внимание.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The expression can be of type either number or string.</div>
                        <div class="ruJSTheory">Выражение может иметь числовой или строковый тип.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Duplicate values are not allowed for the expression.</div>
                        <div class="ruJSTheory">Для выражения не допускаются повторяющиеся значения.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">The default statement is optional. If the expression passed to
                            switch
                            does
                            not match with any
                            case value then the statement within default case will be executed.
                        </div>
                        <div class="ruJSTheory">Оператор default является необязательным. Если выражение, переданное
                            в
                            переключатель, не
                            соответствует ни одному значению регистра, будет выполнен оператор default.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">The break statement is used inside the switch to terminate a
                            statement
                            sequence.
                        </div>
                        <div class="ruJSTheory">Оператор Break используется внутри переключателя для завершения
                            последовательности операторов.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">The break statement is optional. But if it is omitted, the
                            execution
                            will
                            continue on into the next case.
                        </div>
                        <div class="ruJSTheory">Оператор Break не является обязательным. Но если он опущен,
                            выполнение
                            продолжится до следующего случая.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment222">
            <div class="engJSTheory">What are primitive data types</div>
            <div class="ruJSTheory">Что такое примитивные типы данных</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A primitive data type is data that has a primitive value (which has no
                    properties
                    or methods). There
                    are 7 types of primitive data types:
                </p>
                <p class="ruJSTheory">Примитивный тип данных — это данные, которые имеют примитивное значение (не
                    имеющее
                    свойств или
                    методов). Существует 7 типов примитивных типов данных:
                </p>

                <ol>
                    <li>string</li>
                    <li>number</li>
                    <li>boolean</li>
                    <li>null</li>
                    <li>undefined</li>
                    <li>bigint</li>
                    <li>symbol</li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment223">
            <div class="engJSTheory">What are the different ways to access object properties</div>
            <div class="ruJSTheory">Какие существуют способы доступа к свойствам объекта?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are 3 possible ways for accessing the property of an object.</p>
                <p class="ruJSTheory">Существует 3 возможных способа доступа к свойству объекта.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Dot notation: It uses dot for accessing the properties</div>
                        <div class="ruJSTheory">Обозначение через точку: точка используется для доступа к свойствам.
                        </div>
                        <pre>
                        objectName.property;
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Square brackets notation: It uses square brackets for property
                            access
                        </div>
                        <div class="ruJSTheory">Обозначение квадратных скобок: для доступа к свойствам используются
                            квадратные скобки.
                        </div>
                        <pre>
                        objectName["property"];
                    </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Expression notation: It uses expression in the square brackets
                        </div>
                        <div class="ruJSTheory">Обозначение выражения: используется выражение в квадратных скобках.
                        </div>
                        <pre>
                        objectName[expression];
                    </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment224">
            <div class="engJSTheory">What are the function parameter rules</div>
            <div class="ruJSTheory">Каковы правила параметров функции</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript functions follow below rules for parameters:</p>
                <p class="ruJSTheory">Функции JavaScript следуют приведенным ниже правилам для параметров:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The function definitions do not specify data types for parameters.
                        </div>
                        <div class="ruJSTheory">В определениях функций не указаны типы данных для параметров.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Do not perform type checking on the passed arguments.</div>
                        <div class="ruJSTheory">Не выполняйте проверку типа переданных аргументов.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Do not check the number of arguments received. i.e, The below
                            function
                            follows the above rules:
                        </div>
                        <div class="ruJSTheory">Не проверяйте количество полученных аргументов. т. е. функция ниже
                            следует
                            приведенным выше правилам,
                        </div>
                    </li>
                </ol>

                <pre>
                    function functionName(parameter1, parameter2, parameter3) {
                        console.log(parameter1); // 1
                    }
                    functionName(1);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment225">
            <div class="engJSTheory">What is an error object</div>
            <div class="ruJSTheory">Что такое объект error</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An error object is a built in error object that provides error information
                    when
                    an
                    error occurs. It has
                    two properties: name and message. For example, the below function logs error details:
                </p>
                <p class="ruJSTheory">Объект ошибки — это встроенный объект ошибки, который предоставляет информацию
                    об
                    ошибке при
                    возникновении ошибки. Он имеет два свойства: name и message. Например, приведенная ниже функция
                    регистрирует сведения об ошибках:
                </p>

                <pre>
                    try {
                        greeting("Welcome");
                    } catch (err) {
                        console.log(err.name + "< br>" + err.message);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment226">
            <div class="engJSTheory">When you get a syntax error</div>
            <div class="ruJSTheory">Когда вы получаете синтаксическую ошибку</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A SyntaxError is thrown if you try to evaluate code with a syntax error. For
                    example, the below missing
                    quote for the function parameter throws a syntax error
                </p>
                <p class="ruJSTheory">SyntaxError выдается, если вы пытаетесь запустить код с синтаксической
                    ошибкой.
                    Например, недостающая
                    кавычка ниже для параметра функции вызывает синтаксическую ошибку.
                </p>

                <pre>
                    try {
                        eval("greeting('welcome)"); // Missing ' will produce an error
                    } catch (err) {
                        console.log(err.name);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment227">
            <div class="engJSTheory">What are the different error names from error object</div>
            <div class="ruJSTheory">Какие есть имена ошибок из объекта error?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are 6 different types of error names returned from error object:</p>
                <p class="ruJSTheory">Существует 6 различных типов имен ошибок, возвращаемых объектом error:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Error Name</td>
                        <td>
                            <div class="engJSTheory">Description</div>
                            <div class="ruJSTheory">Описание</div>
                        </td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>EvalError</td>
                        <td>
                            <div class="engJSTheory">An error has occurred in the eval() function</div>
                            <div class="ruJSTheory">Произошла ошибка в функции eval().</div>
                        </td>
                    </tr>
                    <tr>
                        <td>RangeError</td>
                        <td>
                            <div class="engJSTheory">An error has occurred with a number "out of range"</div>
                            <div class="ruJSTheory">Произошла ошибка: число "вне диапазона"</div>
                        </td>
                    </tr>
                    <tr>
                        <td>ReferenceError</td>
                        <td>
                            <div class="engJSTheory">An error due to an illegal reference</div>
                            <div class="ruJSTheory">Ошибка из-за незаконной ссылки</div>
                        </td>
                    </tr>
                    <tr>
                        <td>SyntaxError</td>
                        <td>
                            <div class="engJSTheory">An error due to a syntax error</div>
                            <div class="ruJSTheory">Ошибка из-за синтаксической ошибки</div>
                        </td>
                    </tr>
                    <tr>
                        <td>TypeError</td>
                        <td>
                            <div class="engJSTheory">An error due to a type error</div>
                            <div class="ruJSTheory">Ошибка из-за ошибки типа</div>
                        </td>
                    </tr>
                    <tr>
                        <td>URIError</td>
                        <td>
                            <div class="engJSTheory">An error due to encodeURI()</div>
                            <div class="ruJSTheory">Ошибка из-за encodeURI()</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment228">
            <div class="engJSTheory">What are the various statements in error handling</div>
            <div class="ruJSTheory">Какие существуют операторы обработки ошибок?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of statements used in an error handling:</p>
                <p class="ruJSTheory">Ниже приведен список операторов, используемых при обработке ошибок:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">try: This statement is used to test a block of code for errors
                        </div>
                        <div class="ruJSTheory">try: этот оператор используется для проверки блока кода на наличие
                            ошибок.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">catch: This statement is used to handle the error</div>
                        <div class="ruJSTheory">catch: этот оператор используется для обработки ошибки</div>
                    </li>
                    <li>
                        <div class="engJSTheory">throw: This statement is used to create custom errors.</div>
                        <div class="ruJSTheory">throw: этот оператор используется для создания пользовательских
                            ошибок.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">finally: This statement is used to execute code after try and catch
                            regardless of the result.
                        </div>
                        <div class="ruJSTheory">finally: этот оператор используется для выполнения кода после try и
                            catch
                            независимо от результата.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment229">
            <div class="engJSTheory">What are the two types of loops in javascript</div>
            <div class="ruJSTheory">Какие два типа циклов существуют в JavaScript?</div>
        </h3>

        <section>
            <div>
                <ol>
                    <li>
                        <div class="engJSTheory">Entry Controlled loops: In this kind of loop type, the test
                            condition
                            is
                            tested before entering
                            the loop body. For example, For Loop and While Loop comes under this category.
                        </div>
                        <div class="ruJSTheory">Циклы с контролируемым входом: в циклах этого типа тестовое условие
                            проверяется перед входом в
                            тело цикла. Например, к этой категории относятся циклы For и While.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Exit Controlled Loops: In this kind of loop type, the test
                            condition is
                            tested or evaluated at
                            the end of the loop body. i.e, the loop body will execute at least once irrespective of
                            test
                            condition true or false. For example, do-while loop comes under this category.
                        </div>
                        <div class="ruJSTheory">Циклы с контролируемым выходом: в этом типе цикла тестовое условие
                            проверяется или оценивается в
                            конце тела цикла. т. е. тело цикла выполнится хотя бы один раз, независимо от того,
                            истинно
                            или
                            ложно тестовое условие. Например, к этой категории относится цикл do-while.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment230">
            <div class="engJSTheory">What is nodejs</div>
            <div class="ruJSTheory">Что такое nodejs</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Node.js is a server-side platform built on Chrome's JavaScript runtime for
                    easily
                    building fast and
                    scalable network applications. It is an event-based, non-blocking, asynchronous I/O runtime that
                    uses
                    Google's V8 JavaScript engine and libuv library.
                </p>
                <p class="ruJSTheory">Node.js — это серверная платформа, созданная на основе среды выполнения
                    JavaScript
                    Chrome, позволяющая
                    легко создавать быстрые и масштабируемые сетевые приложения. Это основанная на событиях
                    неблокирующая
                    асинхронная среда выполнения ввода-вывода, использующая движок JavaScript V8 от Google и
                    библиотеку
                    libuv.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment231">
            <div class="engJSTheory">What is an Intl object</div>
            <div class="ruJSTheory">Что такое Intl объект</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Intl object is the namespace for the ECMAScript Internationalization API,
                    which
                    provides language
                    sensitive string comparison, number formatting, and date and time formatting. It provides access
                    to
                    several constructors and language sensitive functions.
                </p>
                <p class="ruJSTheory">Объект Intl — это пространство имен для API интернационализации ECMAScript,
                    который
                    обеспечивает
                    сравнение строк с учетом языка, форматирование чисел, а также форматирование даты и времени. Он
                    обеспечивает доступ к нескольким конструкторам и функциям, чувствительным к языку.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment232">
            <div class="engJSTheory">How do you perform language specific date and time formatting</div>
            <div class="ruJSTheory">Как выполнить форматирование даты и времени для конкретного языка?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Intl.DateTimeFormat object which is a constructor for objects
                    that
                    enable language-sensitive date and time formatting. Let's see this behavior with an example:
                </p>
                <p class="ruJSTheory">Вы можете использовать объект Intl.DateTimeFormat, который является
                    конструктором
                    для объектов, которые
                    обеспечивают форматирование даты и времени с учетом языка. Давайте посмотрим на это поведение на
                    примере:
                </p>

                <pre>
                    let date = new Date(Date.UTC(2019, 07, 07, 3, 0, 0));
                    console.log(new Intl.DateTimeFormat("en-GB").format(date)); // 07/08/2019
                    console.log(new Intl.DateTimeFormat("en-AU").format(date)); // 07/08/2019
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment233">
            <div class="engJSTheory">What is an Iterator</div>
            <div class="ruJSTheory">Что такое итератор</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An iterator is an object which defines a sequence and a return value upon its
                    termination. It
                    implements the Iterator protocol with a next() method which returns an object with two
                    properties:
                    value
                    (the next value in the sequence) and done (which is true if the last value in the sequence has
                    been
                    consumed).
                </p>
                <p class="ruJSTheory">Итератор — это объект, который определяет последовательность и возвращаемое
                    значение
                    после ее
                    завершения. Он реализует протокол Iterator с методом next(), который возвращает объект с двумя
                    свойствами: value (следующее значение в последовательности) и Done (что верно, если последнее
                    значение в
                    последовательности было использовано).
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment234">
            <div class="engJSTheory">How does synchronous iteration works</div>
            <div class="ruJSTheory">Как работает синхронная итерация</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Synchronous iteration was introduced in ES6 and it works with below set of
                    components:
                </p>
                <p class="ruJSTheory">Синхронная итерация была введена в ES6 и работает с приведенным ниже набором
                    компонентов:
                </p>

                <p class="engJSTheory">Iterable: It is an object which can be iterated over via a method whose key
                    is
                    Symbol.iterator.
                    Iterator: It is an object returned by invoking [Symbol.iterator]() on an iterable. This iterator
                    object
                    wraps each iterated element in an object and returns it via next() method one by one.
                    IteratorResult: It
                    is an object returned by next() method. The object contains two properties; the value property
                    contains
                    an iterated element and the done property determines whether the element is the last element or
                    not.
                </p>
                <p class="ruJSTheory">Iterable(Итерируемый): это объект, который можно перебирать с помощью метода,
                    ключ
                    которого —
                    Symbol.iterator.
                    Iterator(Итератор): это объект, возвращаемый вызовом [Symbol.iterator]() для итерации. Этот
                    объект-итератор
                    оборачивает каждый итерируемый элемент в объект и возвращает его через метод next() один за
                    другим.
                    IteratorResult: это объект, возвращаемый методом next(). Объект содержит два свойства; Свойство
                    value
                    содержит повторяемый элемент, а свойство Done определяет, является ли элемент последним
                    элементом
                    или
                    нет.
                </p>

                <p class="engJSTheory">Let's demonstrate synchronous iteration with an array as below:</p>
                <p class="ruJSTheory">Давайте продемонстрируем синхронную итерацию с массивом, как показано
                    ниже:</p>

                <pre>
                    const iterable = ["one", "two", "three"];
                    const iterator = iterable[Symbol.iterator]();
                    console.log(iterator.next()); // { value: 'one', done: false }
                    console.log(iterator.next()); // { value: 'two', done: false }
                    console.log(iterator.next()); // { value: 'three', done: false }
                    console.log(iterator.next()); // { value: 'undefined, done: true }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment235">
            <div class="engJSTheory">What is an event loop</div>
            <div class="ruJSTheory">Что такое цикл событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The event loop is a process that continuously monitors both the call stack
                    and
                    the
                    event queue and
                    checks whether or not the call stack is empty. If the call stack is empty and there are pending
                    events
                    in the event queue, the event loop dequeues the event from the event queue and pushes it to the
                    call
                    stack. The call stack executes the event, and any additional events generated during the
                    execution
                    are
                    added to the end of the event queue.
                </p>
                <p class="ruJSTheory">Цикл событий — это процесс, который постоянно отслеживает как стек вызовов,
                    так и
                    очередь событий, а
                    также проверяет, пуст ли стек вызовов. Если стек вызовов пуст и в очереди событий есть ожидающие
                    события, цикл событий удаляет событие из очереди событий и помещает его в стек вызовов. Стек
                    вызовов
                    выполняет событие, и любые дополнительные события, сгенерированные во время выполнения,
                    добавляются
                    в
                    конец очереди событий.
                </p>

                <p class="engJSTheory">Note: The event loop allows Node.js to perform non-blocking I/O operations,
                    even
                    though JavaScript is
                    single-threaded, by offloading operations to the system kernel whenever possible. Since most
                    modern
                    kernels are multi-threaded, they can handle multiple operations executing in the background.
                </p>
                <p class="ruJSTheory">Примечание: Цикл событий позволяет Node.js выполнять неблокирующие операции
                    ввода-вывода, даже несмотря на
                    однопоточность JavaScript, по возможности перекладывая операции на ядро системы. Поскольку
                    большинство современных ядер являются многопоточными, они могут обрабатывать несколько операций,
                    выполняемых в фоновом режиме.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment236">
            <div class="engJSTheory">What is call stack</div>
            <div class="ruJSTheory"> Что такое стек вызовов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Call Stack is a data structure for javascript interpreters to keep track of
                    function calls(creates
                    execution context) in the program. It has two major actions:
                </p>
                <p class="ruJSTheory">Стек вызовов — это структура данных для интерпретаторов JavaScript,
                    позволяющая
                    отслеживать вызовы
                    функций (создает контекст выполнения) в программе. Он имеет два основных действия:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Whenever you call a function for its execution, you are pushing it
                            to
                            the
                            stack.
                        </div>
                        <div class="ruJSTheory">Всякий раз, когда вы вызываете функцию для ее выполнения, вы
                            помещаете
                            ее в
                            стек.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Whenever the execution is completed, the function is popped out of
                            the
                            stack.
                        </div>
                        <div class="ruJSTheory">Всякий раз, когда выполнение завершается, функция извлекается из
                            стека.
                        </div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's take an example and it's state representation in a diagram format:</p>
                <p class="ruJSTheory">Давайте рассмотрим пример и представление его состояния в формате
                    диаграммы:</p>

                <pre>
                    function hungry() {
                        eatFruits();
                    }
                    function eatFruits() {
                        return "I'm eating fruits";
                    }

                    // Invoke the `hungry` function
                    hungry();
                </pre>

                <p class="engJSTheory">The above code processed in a call stack as below:</p>
                <p class="ruJSTheory">Приведенный выше код обрабатывается в стеке вызовов, как показано ниже:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Add the hungry() function to the call stack list and execute the
                            code.
                        </div>
                        <div class="ruJSTheory">Добавьте функцию hungry() в список стека вызовов и выполните код.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Add the eatFruits() function to the call stack list and execute the
                            code.
                        </div>
                        <div class="ruJSTheory">Добавьте функцию eatFruits() в список стека вызовов и выполните код.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Delete the eatFruits() function from our call stack list.</div>
                        <div class="ruJSTheory">Удалите функцию eatFruits() из нашего списка стека вызовов.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Delete the hungry() function from the call stack list since there
                            are
                            no
                            items anymore.
                        </div>
                        <div class="ruJSTheory">Удалите функцию hungry() из списка стека вызовов, так как в нем
                            больше
                            нет
                            элементов.
                        </div>
                    </li>
                </ol>
                <img src="./images/call-stack.png" alt="call-stack">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment237">
            <div class="engJSTheory">What is an event queue</div>
            <div class="ruJSTheory">Что такое очередь событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The event queue follows the queue data structure. It stores async callbacks
                    to be
                    added to the call
                    stack. It is also known as the Callback Queue or Macrotask Queue.
                </p>
                <p class="ruJSTheory">Очередь событий соответствует структуре данных очереди. Она хранит асинхронные
                    колбэки для
                    добавления в стек вызовов. Она также известна как очередь колбэков или очередь макрозадач.
                </p>

                <p class="engJSTheory">Whenever the call stack receives an async function, it is moved into the Web
                    API.
                    Based on the
                    function, Web API executes it and awaits the result. Once it is finished, it moves the callback
                    into
                    the
                    event queue (the callback of the promise is moved into the microtask queue).
                </p>
                <p class="ruJSTheory">Всякий раз, когда стек вызовов получает асинхронную функцию, она перемещается
                    в
                    веб-API. На основе
                    функции веб-API выполняет ее и ожидает результата. По завершении колбэк перемещается в очередь
                    событий (обратный вызов промиса перемещается в очередь микрозадач).
                </p>

                <p class="engJSTheory">The event loop constantly checks whether or not the call stack is empty. Once
                    the
                    call stack is empty
                    and there is a callback in the event queue, the event loop moves the callback into the call
                    stack.
                    But
                    if there is a callback in the microtask queue as well, it is moved first. The microtask queue
                    has a
                    higher priority than the event queue.
                </p>
                <p class="ruJSTheory">Цикл событий постоянно проверяет, пуст ли стек вызовов. Когда стек вызовов
                    пуст и
                    в
                    очереди событий
                    есть колбэк, цикл событий перемещает колбэк в стек вызовов. Но если в очереди микрозадач
                    также есть колбэк, он перемещается первым. Очередь микрозадач имеет более высокий приоритет, чем
                    очередь событий.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment238">
            <div class="engJSTheory">What is a decorator</div>
            <div class="ruJSTheory">Что такое декоратор</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A decorator is an expression that evaluates to a function and that takes the
                    target, name, and
                    decorator descriptor as arguments. Also, it optionally returns a decorator descriptor to install
                    on
                    the
                    target object. Let's define admin decorator for user class at design time:
                </p>
                <p class="ruJSTheory">Декоратор — это выражение, результатом которого является функция, которое
                    принимает
                    в качестве
                    аргументов цель, имя и дескриптор декоратора. Кроме того, он опционально возвращает дескриптор
                    декоратора для установки на целевой объект. Давайте определим декоратор администратора для
                    класса
                    пользователя во время разработки:
                </p>

                <pre>
                    //typescript decorator with experimental syntax

                    function admin(isAdmin) {
                        return function(target) {
                            target.isAdmin = isAdmin;
                        }
                    }

                    @admin(true)
                    class User() {
                    }
                    console.log(User.isAdmin); //true

                    @admin(false)
                    class User() {
                    }
                    console.log(User.isAdmin); //false

                    //standard function decorator

                    let printFuncResult = (x) => {
                        return x * 2;
                    }

                    const cacheDecorator = (func) => {
                        let cache = new Map();

                        return function (x) {
                            if (cache.has(x)) {
                                console.log("Value is from cache");
                                return cache.get(x)
                            }

                            let result = func(x);
                            cache.set(x, result);

                            return result;
                        }
                    }

                    printFuncResult = cacheDecorator(printFuncResult);
                    printFuncResult(2); // 4
                    printFuncResult(2); // 4 // Value is from cache
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment239">
            <div class="engJSTheory">What are the properties of Intl object</div>
            <div class="ruJSTheory">Какие есть свойства у объекта Intl</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of properties available on Intl object:</p>
                <p class="ruJSTheory">Ниже приведен список свойств, доступных для объекта Intl:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Collator: These are the objects that enable language-sensitive
                            string
                            comparison.
                        </div>
                        <div class="ruJSTheory">Collator: это объекты, которые позволяют сравнивать строки с учетом
                            языка.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">DateTimeFormat: These are the objects that enable
                            language-sensitive
                            date
                            and time
                            formatting.
                        </div>
                        <div class="ruJSTheory">DateTimeFormat: это объекты, которые позволяют форматировать дату и
                            время с
                            учетом языка.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">ListFormat: These are the objects that enable language-sensitive
                            list
                            formatting.
                        </div>
                        <div class="ruJSTheory">ListFormat: это объекты, которые позволяют форматировать список с
                            учетом
                            языка.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">NumberFormat: Objects that enable language-sensitive number
                            formatting.
                        </div>
                        <div class="ruJSTheory">NumberFormat: объекты, которые позволяют форматировать числа с
                            учетом
                            языка.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">PluralRules: Objects that enable plural-sensitive formatting and
                            language-specific rules for
                            plurals.
                        </div>
                        <div class="ruJSTheory">PluralRules: объекты, которые обеспечивают форматирование с учетом
                            множественного числа и
                            специфичные для языка правила для множественного числа.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">RelativeTimeFormat: Objects that enable language-sensitive relative
                            time
                            formatting.
                        </div>
                        <div class="ruJSTheory">RelativeTimeFormat: объекты, которые позволяют форматировать
                            относительное
                            время с учетом
                            языка.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment240">
            <div class="engJSTheory">What is an Unary operator</div>
            <div class="ruJSTheory">Что такое унарный оператор</div>
        </h3>

        <section>
            <div>
                <p>Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный
                    минус
                    "-"
                    меняет знак числа на противоположный:</p>

                <pre>
                    //let x = 1;

                    x = -x;
                    alert( x ); // -1, применили унарный минус


                    //унарный плюс, преобразует значение операнда в число(подобно Number())
                    let x = "100";
                    let y = +x;
                    console.log(typeof x, typeof y); // string, number

                    let a = "Hello";
                    let b = +a;
                    console.log(typeof a, typeof b, b); // string, number, NaN
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment241">
            <div class="engJSTheory">How do you sort elements in an array</div>
            <div class="ruJSTheory">Как сортировать элементы в массиве</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The sort() method is used to sort the elements of an array in place and
                    returns
                    the
                    sorted array. The
                    example usage would be as below:
                </p>
                <p class="ruJSTheory">Метод sort() используется для сортировки элементов массива и возвращает
                    отсортированный массив. Метод является калечащим!!! Пример
                    использования будет таким, как показано ниже:
                </p>

                <pre>
                    let months = ["Aug", "Sep", "Jan", "June"];
                    months.sort();
                    console.log(months); //  ["Aug", "Jan", "June", "Sep"]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment242">
            <div class="engJSTheory">What is the purpose of compareFunction while sorting arrays</div>
            <div class="ruJSTheory">Какова цель compareFunction при сортировке массивов?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The compareFunction is used to define the sort order. If omitted, the array
                    elements are converted to
                    strings, then sorted according to each character's Unicode code point value. Let's take an
                    example
                    to
                    see the usage of compareFunction:
                </p>
                <p class="ruJSTheory">compareFunction используется для определения порядка сортировки. Если этот
                    параметр
                    опущен, элементы
                    массива преобразуются в строки, а затем сортируются в соответствии со значением кодовой точки
                    Юникода
                    каждого символа. Давайте рассмотрим пример, чтобы увидеть использование CompareFunction:
                </p>

                <pre>
                    let numbers = [1, 2, 5, 3, 4];
                    numbers.sort((a, b) => b - a); // arr.sort([compareFunction])
                    console.log(numbers); // [5, 4, 3, 2, 1]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment243">
            <div class="engJSTheory">How do you reversing an array</div>
            <div class="ruJSTheory">Как вы переворачиваете массив</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the reverse() method to reverse the elements in an array. This
                    method
                    is useful to sort an
                    array in descending order. Let's see the usage of reverse() method in an example:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод reverse(), чтобы перевернуть элементы массива.
                    Этот
                    метод полезен для
                    сортировки массива в порядке убывания. Давайте посмотрим на использование метода reverse() на
                    примере:
                </p>

                <pre>
                    let numbers = [1, 2, 5, 3, 4];
                    numbers.sort((a, b) => b - a); // [5, 4, 3, 2, 1]
                    numbers.reverse();
                    console.log(numbers); // [1, 2, 3, 4 ,5]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment244">
            <div class="engJSTheory">How do you find min and max value in an array</div>
            <div class="ruJSTheory">Как найти минимальное и максимальное значение в массиве</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use Math.min and Math.max methods on array variables to find the
                    minimum
                    and maximum elements
                    within an array. Let's create two functions to find the min and max value with in an array,
                </p>
                <p class="ruJSTheory">Вы можете использовать методы Math.min и Math.max для переменных массива,
                    чтобы
                    найти минимальный и
                    максимальный элементы в массиве. Давайте создадим две функции для поиска минимального и
                    максимального
                    значения в массиве:
                </p>

                <pre>
                    let marks = [50, 20, 70, 60, 45, 30];
                    function findMin(arr) {
                        return Math.min.apply(null, arr);
                    }
                    function findMax(arr) {
                        return Math.max.apply(null, arr);
                    }

                    console.log(findMin(marks));
                    console.log(findMax(marks));
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment245">
            <div class="engJSTheory">How do you find min and max values without Math functions</div>
            <div class="ruJSTheory">Как найти минимальные и максимальные значения без математических функций?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can write functions which loop through an array comparing each value with
                    the
                    lowest value or
                    highest value to find the min and max values. Let's create those functions to find min and max
                    values:
                </p>
                <p class="ruJSTheory">Вы можете написать функции, которые просматривают массив, сравнивая каждое
                    значение
                    с наименьшим или
                    максимальным значением, чтобы найти минимальное и максимальное значения. Давайте создадим эти
                    функции
                    для поиска минимальных и максимальных значений:
                </p>

                <pre>
                    let marks = [50, 20, 70, 60, 45, 30];
                    function findMin(arr) {
                        let length = arr.length;
                        let min = Infinity;
                        while (length--) {
                          if (arr[length] < min) {
                            min = arr[length];
                          }
                        }
                        return min;
                    }

                    function findMax(arr) {
                        let length = arr.length;
                        let max = -Infinity;
                        while (length--) {
                          if (arr[length] > max) {
                            max = arr[length];
                          }
                        }
                        return max;
                    }

                    console.log(findMin(marks));
                    console.log(findMax(marks));
                </pre>

                <p>ну или посчитать прямо через цикл:</p>

                <pre>
                    let marks = [50, 20, 70, 60, 45, 30];
                    let min = marks[0];
                    let max = marks[0];
                    marks.forEach(el => {
                        if (el < min) {
                            min = el
                        }
                        if (el > max) {
                            max = el
                        }
                    })
                    console.log(min) //20
                    console.log(max) //70
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment246">
            <div class="engJSTheory">What is an empty statement and purpose of it</div>
            <div class="ruJSTheory">Что такое пустое заявление и его цель</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The empty statement is a semicolon (;) indicating that no statement will be
                    executed, even if
                    JavaScript syntax requires one. Since there is no action with an empty statement you might think
                    that
                    it's usage is quite less, but the empty statement is occasionally useful when you want to create
                    a
                    loop
                    that has an empty body. For example, you can initialize an array with zero values as below:
                </p>
                <p class="ruJSTheory">Пустой оператор представляет собой точку с запятой (;), указывающую, что ни
                    один
                    оператор не будет
                    выполнен, даже если синтаксис JavaScript требует этого. Поскольку с пустым оператором нет
                    никаких
                    действий, вы можете подумать, что его использование значительно меньше, но пустой оператор
                    иногда
                    бывает
                    полезен, когда вы хотите создать цикл с пустым телом. Например, вы можете инициализировать
                    массив
                    нулевыми значениями, как показано ниже:
                </p>

                <pre>
                    // Initialize an array a
                    for (let i = 0; i < a.length; a[i++] = 0);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment247">
            <div class="engJSTheory">How do you get metadata of a module</div>
            <div class="ruJSTheory">Как получить метаданные модуля</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the import.meta object which is a meta-property exposing
                    context-specific meta data to a
                    JavaScript module. It contains information about the current module, such as the module's URL.
                    In
                    browsers, you might get different meta data than NodeJS.
                </p>
                <p class="ruJSTheory">Вы можете использовать объект import.meta, который представляет собой
                    метасвойство,
                    предоставляющее
                    контекстно-зависимые метаданные модулю JavaScript. Он содержит информацию о текущем модуле,
                    например
                    URL-адрес модуля. В браузерах вы можете получить метаданные, отличные от NodeJS.
                </p>

                <pre>
                < script type="module" src="welcome-module.js">< /script>;
                console.log(import.meta); // { url: "file:///home/user/welcome-module.js" }
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment248">
            <div class="engJSTheory">What is a comma operator</div>
            <div class="ruJSTheory">Что такое оператор запятая</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The comma operator is used to evaluate each of its operands from left to
                    right
                    and
                    returns the value of
                    the last operand. This is totally different from comma usage within arrays, objects, and
                    function
                    arguments and parameters. For example, the usage for numeric expressions would be as below:
                </p>
                <p class="ruJSTheory">Оператор запятая используется для оценки каждого из своих операндов слева
                    направо
                    и
                    возвращает значение
                    последнего операнда. Это полностью отличается от использования запятых в массивах, объектах,
                    аргументах
                    и параметрах функций. Например, использование числовых выражений будет выглядеть следующим
                    образом:
                </p>

                <pre>
                    let x = 1;
                    x = (x++, x);

                    console.log(x); // 2
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment249">
            <div class="engJSTheory">What is the advantage of a comma operator</div>
            <div class="ruJSTheory">В чем преимущество оператора запятой</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is normally used to include multiple expressions in a location that
                    requires a
                    single expression.
                    One of the common usages of this comma operator is to supply multiple parameters in a for loop.
                    For
                    example, the below for loop uses multiple expressions in a single location using comma operator,
                </p>
                <p class="ruJSTheory">Обычно этот оператор используется для включения нескольких выражений в место,
                    где
                    требуется одно
                    выражение. Одним
                    из распространенных вариантов использования этого оператора-запятой является предоставление
                    нескольких
                    параметров в цикле for. Например, в приведенном ниже цикле for используется несколько выражений
                    в
                    одном
                    месте с использованием оператора-запятой:
                </p>

                <pre>
                for (let a = 0, b =10; a <= 10; a++, b--)
            </pre>

                <p class="engJSTheory">You can also use the comma operator in a return statement where it processes
                    before
                    returning.
                </p>
                <p class="ruJSTheory">Вы также можете использовать оператор запятой в операторе возврата, где он
                    обрабатывается перед возвратом.
                </p>

                <pre>
                    function myFunction() {
                        let a = 1;
                        return (a += 10), a; // 11
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment250">
            <div class="engJSTheory">What is typescript</div>
            <div class="ruJSTheory">Что такое typescript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">TypeScript is a typed superset of JavaScript created by Microsoft that adds
                    optional types, classes,
                    async/await, and many other features, and compiles to plain JavaScript. Angular built entirely
                    in
                    TypeScript and used as a primary language. You can install it globally as:
                </p>
                <p class="ruJSTheory">TypeScript — это типизированный расширенный набор JavaScript, созданный
                    Microsoft,
                    который добавляет
                    дополнительные типы, классы, async/await и многие другие функции и компилируется в простой
                    JavaScript.
                    Angular полностью построен на TypeScript и используется в качестве основного языка. Вы можете
                    установить
                    его глобально как:
                </p>

                <pre>
                    npm install -g typescript
                </pre>

                <p class="engJSTheory">Let's see a simple example of TypeScript usage:</p>
                <p class="ruJSTheory">Давайте посмотрим простой пример использования TypeScript:</p>

                <pre>
                function greeting(name: string): string {
                    return "Hello, " + name;
                }

                let user = "Sudheer";

                console.log(greeting(user));
            </pre>

                <p class="engJSTheory">The greeting method allows only string type as argument.</p>
                <p class="ruJSTheory">Метод greeting допускает в качестве аргумента только строковый тип.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment251">
            <div class="engJSTheory">What are the differences between javascript and typescript</div>
            <div class="ruJSTheory">В чем разница между javascript и typescript</div>
        </h3>

        <section>
            <div>
                <div class="engJSTheory">Below are the list of differences between javascript and typescript:</div>
                <div class="ruJSTheory">Ниже приведен список различий между javascript и typescript:</div>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>feature</td>
                        <td>typescript</td>
                        <td>javascript</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Language paradigm</div>
                            <div class="ruJSTheory">Языковая парадигма</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Object oriented programming language</div>
                            <div class="ruJSTheory">Объектно-ориентированный язык программирования</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Scripting language</div>
                            <div class="ruJSTheory">Язык сценариев</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Typing support</div>
                            <div class="ruJSTheory">Поддержка типов</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Supports static typing</div>
                            <div class="ruJSTheory">Поддерживает статическую типизацию.</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It has dynamic typing</div>
                            <div class="ruJSTheory">Имеет динамическую типизацию</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Modules</div>
                            <div class="ruJSTheory">Модули</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Supported</div>
                            <div class="ruJSTheory">Поддерживается</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Not supported(only since ES6)</div>
                            <div class="ruJSTheory">Поддерживается только с ES6(2015)</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Interface</div>
                            <div class="ruJSTheory">Интерфейс</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It has interfaces concept</div>
                            <div class="ruJSTheory">Имеет концепцию интерфейсов</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Doesn't support interfaces</div>
                            <div class="ruJSTheory">Не поддерживает интерфейсы</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Optional parameters</div>
                            <div class="ruJSTheory">Опциональные параметры</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Functions support optional parameters</div>
                            <div class="ruJSTheory">Функции поддерживают необязательные параметры</div>
                        </td>
                        <td>
                            <div class="engJSTheory">No support of optional parameters for functions</div>
                            <div class="ruJSTheory">Нет поддержки опциональных параметров для функций.</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment252">
            <div class="engJSTheory">What are the advantages of typescript over javascript</div>
            <div class="ruJSTheory">Каковы преимущества typescript перед javascript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory"> Below are some of the advantages of typescript over javascript:</p>
                <p class="ruJSTheory">Ниже приведены некоторые преимущества typescript перед
                    javascript.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">TypeScript is able to find compile time errors at the development
                            timeКаковы различные способы сделать объект нерасширяемым?
                            only
                            and it makes sures
                            less runtime errors. Whereas javascript is an interpreted language.
                        </div>
                        <div class="ruJSTheory">TypeScript способен находить ошибки времени компиляции только во
                            время
                            разработки и снижает
                            количество ошибок во время выполнения. В то время как javascript является
                            интерпретируемым
                            языком.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">TypeScript is strongly-typed or supports static typing which allows
                            for
                            checking type
                            correctness at compile time. This is not available in javascript.
                        </div>
                        <div class="ruJSTheory">TypeScript строго типизирован или поддерживает статическую
                            типизацию,
                            что
                            позволяет проверять
                            правильность типов во время компиляции. Это недоступно в JavaScript.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">TypeScript compiler can compile the .ts files into ES3,ES4 and ES5
                            unlike
                            ES6 features of
                            javascript which may not be supported in some browsers.
                        </div>
                        <div class="ruJSTheory">Компилятор TypeScript может компилировать файлы .ts в ES3, ES4 и
                            ES5, в
                            отличие от функций
                            javascript ES6, которые могут не поддерживаться в некоторых браузерах.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment253">
            <div class="engJSTheory">What is an object initializer</div>
            <div class="ruJSTheory">Что такое инициализатор объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An object initializer is an expression that describes the initialization of
                    an
                    Object. The syntax for
                    this expression is represented as a comma-delimited list of zero or more pairs of property names
                    and
                    associated values of an object, enclosed in curly braces ({}). This is also known as literal
                    notation.
                    It is one of the ways to create an object.
                </p>
                <p class="ruJSTheory">Инициализатор объекта — это выражение, описывающее инициализацию объекта.
                    Синтаксис этого выражения представлен в виде разделенного запятыми списка из нуля или
                    более пар имен свойств и связанных значений объекта, заключенных в фигурные скобки ({}).
                    Это также известно как буквальная(литеральная) запись.
                    Это один из способов создания объекта.</p>

                <pre>
                    let initObject = { a: "John", b: 50, c: {} };

                    console.log(initObject.a); // John
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment254">
            <div class="engJSTheory">What is a constructor method</div>
            <div class="ruJSTheory">Что такое метод конструктора</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The constructor method is a special method for creating and initializing an
                    object created within a class. If you do not specify a constructor method,
                    a default constructor is used. The example usage of constructor would be as below:
                </p>
                <p class="ruJSTheory">Метод конструктора — это специальный метод для создания и инициализации
                    объекта,
                    созданного внутри
                    класса. Если вы не укажете метод конструктора, используется конструктор по умолчанию. Пример
                    использования конструктора будет выглядеть следующим образом:
                </p>

                <pre>
                    class Employee {
                        constructor() {
                          this.name = "John";
                        }
                    }

                    let employeeObject = new Employee();

                    console.log(employeeObject.name); // John
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment255">
            <div class="engJSTheory">What happens if you write constructor more than once in a class</div>
            <div>Что произойдет, если вы напишете конструктор более одного раза в классе</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The "constructor" in a class is a special method and it should be defined
                    only once in a class. i.e, If you write a constructor method more than once in a class
                    it will throw a SyntaxError error.
                </p>
                <p class="ruJSTheory">«Конструктор» в классе — это специальный метод, и его следует определять в
                    классе только один раз. т.е. если вы напишете метод конструктора более одного раза в классе,
                    он выдаст ошибку SyntaxError.</p>

                <pre>
                    class Employee {
                        constructor() {
                          this.name = "John";
                        }
                        constructor() {   //  Uncaught SyntaxError: A class may only have one constructor
                          this.age = 30;
                        }
                    }

                    let employeeObject = new Employee();
                    console.log(employeeObject.name);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment256">
            <div class="engJSTheory">How do you call the constructor of a parent class</div>
            <div class="ruJSTheory">Как вызвать конструктор родительского класса?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the super keyword to call the constructor of a parent class.
                    Remember that super() must be called before using 'this' reference. Otherwise it will cause
                    a reference error. Let's the usage of it,
                </p>
                <p class="ruJSTheory">Вы можете использовать ключевое слово super для вызова конструктора
                    родительского класса. Помните, что super() необходимо вызвать перед использованием ссылки this.
                    В противном случае это приведет к ошибке ссылки. Пример:</p>

                <pre>
                    class Square extends Rectangle {
                        constructor(length) {
                          super(length, length);
                          this.name = "Square";
                        }

                        get area() {
                          return this.width * this.height;
                        }

                        set area(value) {
                          this.area = value;
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment257">
            <div class="engJSTheory">How do you get the prototype of an object</div>
            <div class="ruJSTheory">Как получить прототип объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.getPrototypeOf(obj) method to return the prototype of
                    the
                    specified object. i.e.
                    The value of the internal prototype property. If there are no inherited properties then null
                    value
                    is
                    returned.
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.getPrototypeOf(obj) для возврата прототипа
                    указанного объекта. то
                    есть значение внутреннего свойства прототипа. Если унаследованных свойств нет, возвращается
                    нулевое
                    значение.
                </p>

                <pre>
                    const newPrototype = {};
                    const newObject = Object.create(newPrototype);

                    console.log(Object.getPrototypeOf(newObject) === newPrototype); // true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment258">
            <div class="engJSTheory">What happens If I pass string type for getPrototype method</div>
            <div class="ruJSTheory">Что произойдет, если я передам тип строки для метода getPrototype</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In ES5, it will throw a TypeError exception if the obj parameter isn't an
                    object.
                    Whereas in ES2015,
                    the parameter will be coerced to an Object.
                </p>
                <p class="ruJSTheory">В ES5 будет выдано исключение TypeError, если параметр obj не является
                    объектом.
                    Тогда как в ES2015
                    параметр будет привязан к объекту.
                </p>

                <pre>
                    // ES5
                    Object.getPrototypeOf("James"); // TypeError: "James" is not an object
                    // ES2015
                    Object.getPrototypeOf("James"); // String.prototype
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment259">
            <div class="engJSTheory">How do you set prototype of one object to another</div>
            <div class="ruJSTheory">Как вы устанавливаете прототип одного объекта на другой?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.setPrototypeOf() method that sets the prototype (i.e.,
                    the
                    internal Prototype
                    property) of a specified object to another object or null. For example, if you want to set
                    prototype
                    of
                    a square object to rectangle object would be as follows:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.setPrototypeOf(), который устанавливает
                    прототип
                    (т. е. внутреннее
                    свойство Prototype) указанного объекта в другой объект или в значение null. Например, если вы
                    хотите
                    установить прототип square object в rectangle object, это будет выглядеть следующим образом:
                </p>

                <pre>
                Object.setPrototypeOf(Square.prototype, Rectangle.prototype);
                Object.setPrototypeOf({}, null);
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment260">
            <div class="engJSTheory">How do you check whether an object can be extendable or not</div>
            <div class="ruJSTheory">Как проверить, может ли объект быть расширяемым или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.isExtensible() method is used to determine if an object is
                    extendable
                    or
                    not. i.e, Whether
                    it can have new properties added to it or not.
                </p>
                <p class="ruJSTheory">Метод Object.isExtensible() используется для определения того, является ли
                    объект
                    расширяемым или нет.
                    то есть, могут ли к нему быть добавлены новые свойства или нет.
                </p>

                <pre>
                    const newObject = {};
                    console.log(Object.isExtensible(newObject)); //true
                </pre>

                <p class="engJSTheory">Note: By default, all the objects are extendable. i.e, The new properties can
                    be
                    added or modified.
                </p>
                <p class="ruJSTheory">Примечание: По умолчанию все объекты являются расширяемыми. т. е. новые
                    свойства
                    могут быть добавлены
                    или изменены.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment261">
            <div class="engJSTheory">How do you prevent an object to extend</div>
            <div class="ruJSTheory">Как предотвратить расширение объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.preventExtensions() method is used to prevent new properties from
                    ever
                    being added to an
                    object. In other words, it prevents future extensions to the object. Let's see the usage of this
                    property:
                </p>
                <p class="ruJSTheory">Метод Object.preventExtensions() используется для предотвращения добавления
                    новых
                    свойств к объекту.
                    Другими словами, это предотвращает будущие расширения объекта. Давайте посмотрим, как
                    используется
                    это
                    свойство:
                </p>

                <pre>
                    const newObject = {};
                    Object.preventExtensions(newObject); // NOT extendable

                    try {
                        Object.defineProperty(newObject, "newProperty", {
                          // Adding new property
                          value: 100,
                        });
                    } catch (e) {
                        console.log(e); // TypeError: Cannot define property newProperty, object is not extensible
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment262">
            <div class="engJSTheory">What are the different ways to make an object non-extensible</div>
            <div class="ruJSTheory">Какоие существуют способы сделать объект нерасширяемым?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can mark an object non-extensible in 3 ways:</p>
                <p class="ruJSTheory">Вы можете пометить объект как нерасширяемый тремя способами:</p>

                <ol>
                    <li>Object.preventExtensions</li>
                    <li>Object.seal</li>
                    <li>Object.freeze</li>
                </ol>

                <pre>
                    let newObject = {};

                    Object.preventExtensions(newObject); // Prevent objects are non-extensible
                    Object.isExtensible(newObject); // false

                    let sealedObject = Object.seal({}); // Sealed objects are non-extensible
                    Object.isExtensible(sealedObject); // false

                    let frozenObject = Object.freeze({}); // Frozen objects are non-extensible
                    Object.isExtensible(frozenObject); // false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment263">
            <div class="engJSTheory">How do you define multiple properties on an object</div>
            <div class="ruJSTheory">Как определить/изменить несколько свойств объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Object.defineProperties() method is used to define new or modify existing
                    properties directly on an
                    object and returning the object. Let's define multiple properties on an empty object:
                </p>
                <p class="ruJSTheory">Метод Object.defineProperties() используется для определения новых или
                    изменения
                    существующих свойств
                    непосредственно объекта и возврата объекта. Давайте определим несколько свойств пустого объекта:
                </p>

                <pre>
                    const newObject = {};

                    Object.defineProperties(newObject, {
                        newProperty1: {
                            value: "John",
                            writable: true,
                        },
                        newProperty2: {},
                    });
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment264">
            <div class="engJSTheory">What is MEAN in javascript</div>
            <div class="ruJSTheory">Что такое MEAN в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The MEAN (MongoDB, Express, AngularJS, and Node.js) stack is the most popular
                    open-source JavaScript
                    software tech stack available for building dynamic web apps where you can write both the
                    server-side
                    and
                    client-side halves of the web project entirely in JavaScript.
                </p>
                <p class="ruJSTheory">Стек MEAN (MongoDB, Express, AngularJS и Node.js) — это самый популярный
                    технологический стек
                    программного обеспечения JavaScript с открытым исходным кодом, доступный для создания
                    динамических
                    веб-приложений, где вы можете писать как серверную, так и клиентскую половины веб-проекта.
                    полностью
                    на
                    JavaScript.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment265">
            <div class="engJSTheory">What Is Obfuscation in javascript</div>
            <div class="ruJSTheory">Что такое обфускация в JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Obfuscation is the deliberate act of creating obfuscated javascript code(i.e,
                    source or machine code)
                    that is difficult for humans to understand. It is something similar to encryption, but a machine
                    can
                    understand the code and execute it. Let's see the below function before Obfuscation:
                </p>
                <p class="ruJSTheory">Обфускация — это преднамеренное действие по созданию запутанного кода
                    Javascript (т.е. исходного или машинного кода), который трудно понять людям.
                    Это похоже на шифрование, но машина может понять код и выполнить его.
                    Давайте посмотрим на функцию ниже перед обфускацией:</p>

                <pre>
                    function greeting() {
                       console.log("Hello, welcome to JS world");
                    }
                </pre>

                <p class="engJSTheory">And after the code Obfuscation, it would be appeared as below:</p>
                <p class="ruJSTheory">И после обфускации кода он будет выглядеть так, как показано ниже:</p>

                <pre>
                    eval(
                        (function (p, a, c, k, e, d) {
                            e = function (c) {
                              return c;
                            };
                            if (!"".replace(/^/, String)) {
                              while (c--) {
                                d[c] = k[c] || c;
                              }
                              k = [
                                function (e) {
                                  return d[e];
                                },
                              ];
                              e = function () {
                                return "\\w+";
                              };
                              c = 1;
                            }
                            while (c--) {
                              if (k[c]) {
                                p = p.replace(new RegExp("\\b" + e(c) + "\\b", "g"), k[c]);
                              }
                            }
                            return p;
                        })(
                            "2 1(){0.3('4, 7 6 5 8')}",
                            9,
                            9,
                            "console|greeting|function|log|Hello|JS|to|welcome|world".split("|"),
                            0,
                            {}
                        )
                    );
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment266">
            <div class="engJSTheory">Why do you need Obfuscation</div>
            <div class="ruJSTheory">Зачем нужна обфускация</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the few reasons for Obfuscation:</p>
                <p class="ruJSTheory">Ниже приведены несколько причин обфускации:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The Code size will be reduced. So data transfers between server and
                            client
                            will be fast.
                        </div>
                        <div class="ruJSTheory">Размер кода будет уменьшен. Таким образом, передача данных между
                            сервером и
                            клиентом будет быстрой.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">It hides the business logic from outside world and protects the
                            code
                            from
                            others
                        </div>
                        <div class="ruJSTheory">Он скрывает бизнес-логику от внешнего мира и защищает код от других.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Reverse engineering is highly difficult</div>
                        <div class="ruJSTheory">Реверс-инжиниринг очень сложен</div>
                    </li>
                    <li>
                        <div class="engJSTheory">The download time will be reduced</div>
                        <div class="ruJSTheory">Время загрузки будет сокращено</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment267">
            <div class="engJSTheory">What is Minification</div>
            <div class="ruJSTheory">Что такое минификация</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Minification is the process of removing all unnecessary characters(empty
                    spaces
                    are
                    removed) and
                    variables will be renamed without changing it's functionality. It is also a type of obfuscation.
                </p>
                <p class="ruJSTheory">Минификация — это процесс удаления всех ненужных символов (пустые пробелы
                    удаляются), а переменные
                    переименовываются без изменения их функциональности. Это также своего рода запутывание.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment268">
            <div class="engJSTheory">What are the advantages of minification</div>
            <div class="ruJSTheory">В чем преимущества минификации</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Normally it is recommended to use minification for heavy traffic and
                    intensive
                    requirements of
                    resources. It reduces file sizes with below benefits:
                </p>
                <p class="ruJSTheory">Обычно рекомендуется использовать минификацию при интенсивном трафике и
                    высоких
                    требованиях к ресурсам.
                    Это уменьшает размеры файлов со следующими преимуществами:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Decreases loading times of a web page</div>
                        <div class="ruJSTheory">Уменьшает время загрузки веб-страницы</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Saves bandwidth usages</div>
                        <div class="ruJSTheory">Экономит использование полосы пропускания</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment269">
            <div class="engJSTheory">What are the differences between Obfuscation and Encryption</div>
            <div class="ruJSTheory">В чем разница между обфускацией и шифрованием</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the main differences between Obfuscation and Encryption:</p>
                <p class="ruJSTheory">Ниже приведены основные различия между обфускацией и шифрованием.</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Feature</td>
                        <td>Obfuscation</td>
                        <td>Encryption</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Definition</div>
                            <div class="ruJSTheory">Определение</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Changing the form of any data in any other form</div>
                            <div class="ruJSTheory">Изменение формы любых данных в любую другую форму</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Changing the form of information to an unreadable format by
                                using a
                                key
                            </div>
                            <div class="ruJSTheory">Изменение формы информации в нечитаемый формат с помощью ключа
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">A key to decode</div>
                            <div class="ruJSTheory">Ключ для декодирования</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It can be decoded without any key</div>
                            <div class="ruJSTheory">Можно расшифровать без какого-либо ключа</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It is required</div>
                            <div class="ruJSTheory">Требуется</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Target data format</div>
                            <div class="ruJSTheory">Целевой формат данных</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It will be converted to a complex form</div>
                            <div class="ruJSTheory">Данные будут преобразованы в сложную форму</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Converted into an unreadable format</div>
                            <div class="ruJSTheory">Данные будут преобразованы в нечитаемый формат</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment270">
            <div class="engJSTheory">What are the common tools used for minification</div>
            <div class="ruJSTheory">Какие общие инструменты используются для минификации</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are many online/offline tools to minify the javascript files:</p>
                <p class="ruJSTheory">Существует множество онлайн-/оффлайн-инструментов для минимизации файлов
                    JavaScript:
                </p>

                <ol>
                    <li>Google's Closure Compiler</li>
                    <li>UglifyJS2</li>
                    <li>jsmin</li>
                    <li>javascript-minifier.com/</li>
                    <li>prettydiff.com</li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment271">
            <div class="engJSTheory">How do you perform form validation using javascript</div>
            <div class="ruJSTheory">Как выполнить валидацию формы с помощью JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript can be used to perform HTML form validation. For example, if the
                    form
                    field is empty, the
                    function needs to notify, and return false, to prevent the form being submitted. Lets' perform
                    user
                    login in an html form:
                </p>
                <p class="ruJSTheory">JavaScript можно использовать для проверки HTML-формы. Например, если поле
                    формы
                    пусто, функция должна
                    уведомить об этом и вернуть false, чтобы предотвратить отправку формы. Давайте выполним вход
                    пользователя в html-форму:
                </p>

                <pre>
                    &lt;form name="myForm" onsubmit="return validateForm()" method="post"&gt;
                        User name: &lt;input type="text" name="uname" /&gt;
                        &lt;input type="submit" value="Submit" /&gt;
                    &lt;/form&gt;
                </pre>

                <p class="engJSTheory">And the validation on user login is below:</p>
                <p class="ruJSTheory">И проверка входа пользователя приведена ниже:</p>

                <pre>
                    function validateForm() {
                        let x = document.forms["myForm"]["uname"].value;
                        if (x == "") {
                            alert("The username shouldn't be empty");
                            return false;
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment272">
            <div class="engJSTheory">How do you perform form validation without javascript</div>
            <div class="ruJSTheory">Как выполнить валидацию формы без JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can perform HTML form validation automatically without using javascript.
                    The
                    validation enabled by
                    applying the required attribute to prevent form submission when the input is empty:
                </p>
                <p class="ruJSTheory">Вы можете выполнить проверку HTML-формы автоматически без использования
                    JavaScript.
                    Проверка включается
                    путем применения required атрибута для предотвращения отправки формы, когда ввод пуст.
                </p>

                <pre>
                    &lt;form method="post"&gt;
                        &lt;input type="text" name="uname" required /&gt;
                        &lt;input type="submit" value="Submit" /&gt;
                    &lt;/form&gt;
                </pre>

                <p class="engJSTheory">Note: Automatic form validation does not work in Internet Explorer 9 or
                    earlier.</p>
                <p class="ruJSTheory">Примечание: Автоматическая проверка формы не работает в Internet Explorer 9 и
                    более
                    ранних версиях.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment273">
            <div class="engJSTheory">What are the DOM methods available for constraint validation</div>
            <div class="ruJSTheory">Какие методы DOM доступны для проверки ограничений</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The below DOM methods are available for constraint validation on an invalid
                    input:
                </p>
                <p class="ruJSTheory">Приведенные ниже методы DOM доступны для проверки ограничений на недопустимый
                    ввод:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">checkValidity(): It returns true if an input element contains valid
                            data.
                        </div>
                        <div class="ruJSTheory">checkValidity(): возвращает true, если входной элемент содержит
                            действительные данные.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">setCustomValidity(): It is used to set the validationMessage
                            property
                            of an
                            input element.
                            Let's take an user login form with DOM validations
                        </div>
                        <div class="ruJSTheory">setCustomValidity(): используется для установки свойства
                            validationMessage
                            входного элемента.
                            Давайте возьмем форму входа пользователя с проверкой DOM.

                            <pre>
                                function myFunction() {
                                    let userName = document.getElementById("uname");
                                    if (!userName.checkValidity()) {
                                        document.getElementById("message").innerHTML = userName.validationMessage;
                                    } else {
                                        document.getElementById("message").innerHTML = "Entered a valid username";
                                    }
                                }
                            </pre>
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment274">
            <div class="engJSTheory">What are the available constraint validation DOM properties</div>
            <div class="ruJSTheory">Какие есть доступные свойства DOM для проверки ограничений?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of some of the constraint validation DOM properties
                    available:</p>
                <p class="ruJSTheory">Ниже приведен список некоторых доступных свойств DOM для проверки
                    ограничений.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">validity: It provides a list of boolean properties related to the
                            validity
                            of an input element.
                        </div>
                        <div class="ruJSTheory">validity: предоставляет список логических свойств, связанных с
                            достоверностью входного элемента.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">validationMessage: It displays the message when the validity is
                            false.
                        </div>
                        <div class="ruJSTheory">validationMessage: отображает сообщение, когда действительность
                            ложна.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">willValidate: It indicates if an input element will be validated or
                            not.
                        </div>
                        <div class="ruJSTheory">willValidate: указывает, будет ли входной элемент проверен или нет.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment275">
            <div class="engJSTheory">What are the list of validity properties</div>
            <div class="ruJSTheory">Каков список свойств validity</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The validity property of an input element provides a set of properties
                    related to
                    the validity of data:</p>
                <p class="ruJSTheory">Свойство validity input элемента предоставляет набор свойств, связанных с
                    достоверностью данных:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">customError: It returns true, if a custom validity message is set.
                        </div>
                        <div class="ruJSTheory">customError: возвращает true, если установлено пользовательское
                            сообщение о
                            достоверности.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">patternMismatch: It returns true, if an element's value does not
                            match
                            its
                            pattern attribute.
                        </div>
                        <div class="ruJSTheory">patternMismatch: возвращает true, если значение элемента не
                            соответствует
                            его pattern атрибуту.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">rangeOverflow: It returns true, if an element's value is greater
                            than
                            its
                            max attribute.
                        </div>
                        <div class="ruJSTheory">rangeOverflow: возвращает true, если значение элемента больше его
                            max
                            атрибута.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">rangeUnderflow: It returns true, if an element's value is less than
                            its
                            min
                            attribute.
                        </div>
                        <div class="ruJSTheory">rangeUnderflow: возвращает true, если значение элемента меньше его
                            min
                            атрибута.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">stepMismatch: It returns true, if an element's value is invalid
                            according
                            to step attribute.
                        </div>
                        <div class="ruJSTheory">stepMismatch: возвращает true, если значение элемента недопустимо в
                            соответствии с атрибутом step.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">tooLong: It returns true, if an element's value exceeds its
                            maxLength
                            attribute.
                        </div>
                        <div class="ruJSTheory">tooLong: возвращает true, если значение элемента превышает его
                            атрибут
                            maxLength.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">typeMismatch: It returns true, if an element's value is invalid
                            according
                            to type attribute.
                        </div>
                        <div class="ruJSTheory">typeMismatch: возвращает true, если значение элемента недопустимо в
                            соответствии с атрибутом type.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">valueMissing: It returns true, if an element with a required
                            attribute
                            has
                            no value.
                        </div>
                        <div class="ruJSTheory">valueMissing: возвращает true, если элемент с required атрибутом не
                            имеет
                            значения.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">valid: It returns true, if an element's value is valid.</div>
                        <div class="ruJSTheory">valid: возвращает true, если значение элемента допустимо.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment276">
            <div class="engJSTheory">Give an example usage of rangeOverflow property</div>
            <div class="ruJSTheory">Приведите пример использования свойства rangeOverflow.</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If an element's value is greater than its max attribute then rangeOverflow
                    property
                    returns true. For
                    example, the below form submission throws an error if the value is more than 100:
                </p>
                <p class="ruJSTheory">Если значение элемента больше, чем его атрибут max, свойство rangeOverflow
                    возвращает true. Например,
                    при отправке формы ниже выдается ошибка, если значение превышает 100:
                </p>

                <pre>
                    &lt;input id="age" type="number" max="100" /&gt;
                    &lt;button onclick="myOverflowFunction()"&gt;OK&lt;/button&gt;

                    -----------------------------------------------------

                    function myOverflowFunction() {
                        if (document.getElementById("age").validity.rangeOverflow) {
                            alert("The mentioned age is not allowed");
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment277">
            <div class="engJSTheory">Is enums feature available in javascript</div>
            <div class="ruJSTheory">Доступна ли функционал enums в JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, javascript does not natively support enums. But there are different kinds
                    of
                    solutions to simulate
                    them even though they may not provide exact equivalents. For example, you can use freeze or seal
                    on
                    object:
                </p>
                <p class="ruJSTheory">Нет, JavaScript изначально не поддерживает enums. Но существуют различные виды
                    решений для их
                    моделирования, даже если они не могут обеспечить точных эквивалентов. Например, вы можете
                    использовать
                    freeze или seal объекта:
                </p>

                <pre>
                    const DaysEnum = Object.freeze({"monday":1, "tuesday":2, "wednesday":3, ...})
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment278">
            <div class="engJSTheory">What is an enum</div>
            <div class="ruJSTheory">Что такое enum(перечисление)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An enum is a type restricting variables to one value from a predefined set of
                    constants. JavaScript has
                    no enums but typescript provides built-in enum support.
                </p>
                <p class="ruJSTheory">enum — это тип, ограничивающий переменные одним значением из предопределенного
                    набора констант.
                    В JavaScript нет перечислений, но Typescript обеспечивает встроенную поддержку перечислений.
                </p>

                <pre>
                    //TS
                    enum Color {
                        RED, GREEN, BLUE
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment279">
            <div class="engJSTheory">How do you list all properties of an object</div>
            <div class="ruJSTheory">Как составить список всех свойств объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.getOwnPropertyNames() method which returns an array of
                    all
                    properties found
                    directly in a given object. Let's the usage of it in an example:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.getOwnPropertyNames(), который возвращает
                    массив
                    всех свойств,
                    найденных непосредственно в данном объекте. Давайте использовать его в примере:
                </p>

                <pre>
                    const newObject = {
                        a: 1,
                        b: 2,
                        c: 3,
                    };

                    console.log(Object.getOwnPropertyNames(newObject)); // ["a", "b", "c"];
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment280">
            <div class="engJSTheory">How do you get property descriptors of an object</div>
            <div class="ruJSTheory">Как получить дескрипторы свойств объекта</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Object.getOwnPropertyDescriptors() method which returns all
                    own
                    property descriptors of
                    a given object. The example usage of this method is below:
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Object.getOwnPropertyDescriptors(), который
                    возвращает
                    все собственные
                    дескрипторы свойств данного объекта. Пример использования этого метода приведен ниже:
                </p>

                <pre>
                    const newObject = {
                        a: 1,
                        b: 2,
                        c: 3,
                    };
                    const descriptorsObject = Object.getOwnPropertyDescriptors(newObject);
                    console.log(descriptorsObject.a.writable); //true
                    console.log(descriptorsObject.a.configurable); //true
                    console.log(descriptorsObject.a.enumerable); //true
                    console.log(descriptorsObject.a.value); // 1
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment281">
            <div class="engJSTheory">What are the attributes provided by a property descriptor</div>
            <div class="ruJSTheory">Какие есть атрибуты, предоставляемые дескриптором свойства?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A property descriptor is a record which has the following attributes:</p>
                <p class="ruJSTheory">Дескриптор свойства — это запись, которая имеет следующие атрибуты:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">value: The value associated with the property</div>
                        <div class="ruJSTheory">value: значение, связанное со свойством.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">writable: Determines whether the value associated with the property
                            can
                            be
                            changed or not
                        </div>
                        <div class="ruJSTheory">writable: определяет, можно ли изменить значение, связанное со
                            свойством,
                            или нет.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">configurable: Returns true if the type of this property descriptor
                            can
                            be
                            changed and if the
                            property can be deleted from the corresponding object.
                        </div>
                        <div class="ruJSTheory">configurable: возвращает true, если тип этого дескриптора свойства
                            можно
                            изменить и если
                            свойство можно удалить из соответствующего объекта.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">enumerable: Determines whether the property appears during
                            enumeration
                            of
                            the properties on the
                            corresponding object or not.
                        </div>
                        <div class="ruJSTheory">enumerable: определяет, отображается ли свойство во время
                            перечисления
                            свойств соответствующего
                            объекта или нет.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">set: A function which serves as a setter for the property</div>
                        <div class="ruJSTheory">set: функция, которая служит установщиком свойства.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">get: A function which serves as a getter for the property</div>
                        <div class="ruJSTheory">get: функция, которая служит для получения свойства.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment282">
            <div class="engJSTheory">How do you extend classes</div>
            <div class="ruJSTheory">Как создавать цепочку наследований классов(extends)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The extends keyword is used in class declarations/expressions to create a
                    class which is a child of another class. It can be used to subclass custom classes as well
                    as built-in objects. The syntax would be as below:</p>
                <p class="ruJSTheory">Ключевое слово extends используется в объявлениях/выражениях для создания
                    класса, который является дочерним по отношению к другому классу. Его можно использовать для
                    создания подклассов пользовательских классов, а также встроенных объектов. Синтаксис будет таким,
                    как показано ниже:</p>

                <pre>
                    class ChildClass extends ParentClass { ... }
                </pre>

                <p class="engJSTheory">Let's take an example of Square subclass from Rectangle parent class:</p>
                <p class="ruJSTheory">Давайте возьмем пример подкласса Square из родительского класса Rectangle:</p>

                <pre>
                    class Square extends Rectangle {
                        constructor(length) {
                          super(length, length);
                          this.name = "Square";
                        }

                        get area() {
                          return this.width * this.height;
                        }

                        set area(value) {
                          this.area = value;
                        }
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment283">
            <div class="engJSTheory">How do I modify the URL without reloading the page</div>
            <div class="ruJSTheory">Как изменить URL без перезагрузки страницы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The window.location.href property will be helpful to modify the url but it
                    reloads
                    the page. HTML5
                    introduced the history.pushState() and history.replaceState() methods, which allow you to add
                    and
                    modify
                    history entries, respectively. For example, you can use pushState as below:
                </p>
                <p class="ruJSTheory">Свойство window.location.href поможет изменить URL-адрес, но оно перезагружает
                    страницу. В HTML5
                    появились методы History.pushState() и History.replaceState(), которые позволяют добавлять и
                    изменять
                    записи истории соответственно. Например, вы можете использовать pushState, как показано ниже:
                </p>

                <pre>
                    window.history.pushState("page2", "Title", "/page2.html");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment284">
            <div class="engJSTheory">How do you check whether an array includes a particular value or not</div>
            <div class="ruJSTheory">Как проверить, содержит ли массив определенное значение или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Array.includes() method is used to determine whether an array includes a
                    particular value among its
                    entries by returning either true or false. Let's see an example to find an element(numeric and
                    string)
                    within an array.
                </p>
                <p class="ruJSTheory">Метод Array.includes() используется для определения того, включает ли массив
                    определенное значение
                    среди своих записей, возвращая либо true, либо false. Давайте посмотрим пример поиска элемента
                    (числового и строкового) в массиве.
                </p>

                <pre>
                    const numericArray = [1, 2, 3, 4];
                    console.log(numericArray.includes(3)); // true

                    const stringArray = ["green", "yellow", "blue"];
                    console.log(stringArray.includes("blue")); //true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment285">
            <div class="engJSTheory">How do you compare scalar arrays</div>
            <div class="ruJSTheory">Как сравнивать скалярные массивы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use length and every method of arrays to compare two scalar(compared
                    directly using ===)
                    arrays. The combination of these expressions can give the expected result:
                </p>
                <p class="ruJSTheory">Вы можете использовать длину и every метод массивов для сравнения двух
                    скалярных
                    (сравниваемых напрямую
                    с использованием ===) массивов. Комбинация этих выражений может дать ожидаемый результат:
                </p>

                <pre>
                    const arrayFirst = [1, 2, 3, 4, 5];
                    const arraySecond = [1, 2, 3, 4, 5];
                    console.log(
                        arrayFirst.length === arraySecond.length && arrayFirst.every((value, index) => value === arraySecond[index])
                    ); // true
                </pre>

                <p class="engJSTheory">If you would like to compare arrays irrespective of order then you should
                    sort
                    them
                    before:
                </p>
                <p class="ruJSTheory">Если вы хотите сравнить неотсортированные массивы, вам следует отсортировать
                    их заранее:</p>

                <pre>
                    const arrayFirst = [2, 3, 1, 4, 5];
                    const arraySecond = [1, 2, 3, 4, 5];
                    console.log(
                        arrayFirst.length === arraySecond.length && arrayFirst.sort().every((value, index) => value === arraySecond[index])
                    ); //true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment286">
            <div class="engJSTheory">How to get the value from get parameters</div>
            <div class="ruJSTheory">Как получить значение из параметров get</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The new URL() object accepts the url string and searchParams property of this
                    object can be used to
                    access the get parameters. Remember that you may need to use polyfill or window.location to
                    access
                    the
                    URL in older browsers(including IE).
                </p>
                <p class="ruJSTheory">Новый объект URL() принимает строку URL-адреса, а свойство searchParams этого
                    объекта можно
                    использовать для доступа к get параметрам. Помните, что вам может потребоваться использовать
                    полифилл или window.location для доступа к URL-адресу в старых браузерах (включая IE).
                </p>

                <pre>
                    let urlString = "http://www.some-domain.com/about.html?x=1&y=2&z=3"; //window.location.href
                    let url = new URL(urlString);
                    let parameterZ = url.searchParams.get("z");
                    console.log(parameterZ); // 3
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment287">
            <div class="engJSTheory">How do you print numbers with commas as thousand separators</div>
            <div class="ruJSTheory">Как печатать числа через запятую в виде разделителей тысяч?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the Number.prototype.toLocaleString() method which returns a
                    string
                    with a
                    language-sensitive representation such as thousand separator,currency etc of this number.
                </p>
                <p class="ruJSTheory">Вы можете использовать метод Number.prototype.toLocaleString(), который
                    возвращает строку с
                    представлением этого числа, зависящим от языка, например разделителем тысяч, валютой и т.д.
                </p>

                <pre>
                    function convertToThousandFormat(x) {
                        return x.toLocaleString();
                    }

                    console.log(convertToThousandFormat(12345.6789)); // 12,345.679
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment288">
            <div class="engJSTheory">What is the difference between java and javascript</div>
            <div class="ruJSTheory">В чем разница между Java и JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Both are totally unrelated programming languages and no relation between
                    them.
                    Java
                    is statically
                    typed, compiled, runs on its own VM. Whereas Javascript is dynamically typed, interpreted, and
                    runs
                    in a
                    browser and nodejs environments. Let's see the major differences in a tabular format:
                </p>
                <p class="ruJSTheory">Оба языка программирования совершенно не связаны друг с другом, и между ними
                    нет
                    никакой связи. Java
                    статически типизирована, компилируется и работает на собственной виртуальной машине. В то время
                    как
                    Javascript динамически типизируется, интерпретируется и запускается в средах браузера и nodejs.
                    Давайте
                    посмотрим основные различия в табличном формате:
                </p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Feature</td>
                        <td>Java</td>
                        <td>JavaScript</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Typed</div>
                            <div class="ruJSTheory">Типизация</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It's a strongly typed language</div>
                            <div class="ruJSTheory">Строго типизированный язык</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It's a dynamic typed language</div>
                            <div class="ruJSTheory">Динамически типизированный язык</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Paradigm</div>
                            <div class="ruJSTheory">Парадигма</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Object oriented programming</div>
                            <div class="ruJSTheory">Объектно-ориентированного программирования</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Prototype based programming</div>
                            <div class="ruJSTheory">Программирование на основе прототипов</div>
                        </td>
                    </tr>
                    <tr>
                        <td>Scoping</td>
                        <td>Block scoped</td>
                        <td>Function-scoped</td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Concurrency</div>
                            <div class="ruJSTheory">Параллелизм</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Thread based</div>
                            <div class="ruJSTheory">На основе потоков</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Event based</div>
                            <div class="ruJSTheory">На основе событий</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Memory</div>
                            <div class="ruJSTheory">Память</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Uses more memory</div>
                            <div class="ruJSTheory">Использует больше памяти</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Uses less memory. Hence it will be used for web pages</div>
                            <div class="ruJSTheory">Использует меньше памяти. Следовательно, он будет использоваться
                                для
                                веб-страниц.
                            </div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment289">
            <div class="engJSTheory">Does JavaScript supports namespace</div>
            <div class="ruJSTheory">Поддерживает ли JavaScript namespace(пространство имен)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript doesn’t support namespace by default. So if you create any
                    element(function, method, object,
                    variable) then it becomes global and pollutes the global namespace. Let's take an example of
                    defining
                    two functions without any namespace:
                </p>
                <p class="ruJSTheory">JavaScript по умолчанию не поддерживает пространство имен. Поэтому, если вы
                    создаете
                    какой-либо элемент
                    (функцию, метод, объект, переменную), он становится глобальным и загрязняет глобальное
                    пространство
                    имен. Давайте рассмотрим пример определения двух функций без какого-либо пространства имен:
                </p>

                <pre>
                    function func1() {
                        console.log("This is a first definition");
                    }
                    function func1() {
                        console.log("This is a second definition");
                    }
                    func1(); // This is a second definition
                </pre>

                <p class="engJSTheory">It always calls the second function definition. In this case, namespace will
                    solve
                    the name collision
                    problem.
                </p>
                <p class="ruJSTheory">Всегда вызывается второе определение функции. В этом случае пространство имен
                    решило проблему конфликта имен.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment290">
            <div class="engJSTheory">How do you declare namespace</div>
            <div class="ruJSTheory">Как вы объявляете пространство имен</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Even though JavaScript lacks namespaces, we can use Objects , IIFE to create
                    namespaces.
                </p>
                <p class="ruJSTheory">Несмотря на то, что в JavaScript отсутствуют пространства имен, мы можем
                    использовать Objects, IIFE для
                    создания пространств имен.
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using Object Literal Notation: Let's wrap variables and functions
                            inside an
                            Object literal
                            which acts as a namespace. After that you can access them using object notation
                        </div>
                        <div class="ruJSTheory">Использование обозначения объектного литерала. Давайте обернем
                            переменные и
                            функции внутри
                            литерала
                            объекта, который действует как пространство имен. После этого вы можете получить к ним
                            доступ,
                            используя нотацию объекта.
                        </div>
                        <pre>
                            let namespaceOne = {
                                function func1() {
                                    console.log("This is a first definition");
                                }
                            }
                            let namespaceTwo = {
                                function func1() {
                                    console.log("This is a second definition");
                                }
                            }
                            namespaceOne.func1(); // This is a first definition
                            namespaceTwo.func1(); // This is a second definition
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using IIFE (Immediately invoked function expression): The outer
                            pair of
                            parentheses of IIFE
                            creates a local scope for all the code inside of it and makes the anonymous function a
                            function
                            expression. Due to that, you can create the same function in two different function
                            expressions
                            to act as a namespace.
                        </div>
                        <div class="ruJSTheory">Использование IIFE (выражение функции с немедленным вызовом):
                            внешняя
                            пара
                            круглых скобок IIFE
                            создает локальную область видимости для всего кода внутри него и превращает анонимную
                            функцию в
                            функциональное выражение. Благодаря этому вы можете создать одну и ту же функцию в двух
                            разных
                            выражениях функций, которые будут выступать в качестве пространства имен.
                        </div>
                        <pre>
                            (function () {
                                function fun1() {
                                  console.log("This is a first definition");
                                }
                                fun1();
                            })();

                            (function () {
                                function fun1() {
                                  console.log("This is a second definition");
                                }
                                fun1();
                            })();
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using a block and a let/const declaration: In ECMAScript 6, you can
                            simply
                            use a block and a
                            let declaration to restrict the scope of a variable to a block.
                        </div>
                        <div class="ruJSTheory">Использование блока и объявления let/const. В ECMAScript 6 вы можете
                            просто
                            использовать блок и
                            объявление let, чтобы ограничить область действия переменной блоком.
                        </div>
                        <pre>
                            {
                                let myFunction = function fun1() {
                                  console.log("This is a first definition");
                                };
                                myFunction();
                            }
                            //myFunction(): ReferenceError: myFunction is not defined.

                            {
                                let myFunction = function fun1() {
                                  console.log("This is a second definition");
                                };
                                myFunction();
                            }
                            //myFunction(): ReferenceError: myFunction is not defined.
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment291">
            <div class="engJSTheory">How do you invoke javascript code in an iframe from parent page(deprecated)
            </div>
            <div class="ruJSTheory">Как вызвать код JavaScript в iframe с родительской страницы?(deprecated)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Initially iFrame needs to be accessed using either document.getElementBy or
                    window.frames. After that
                    contentWindow property of iFrame gives the access for targetFunction
                </p>
                <p class="ruJSTheory">Первоначально доступ к iFrame должен осуществляться с помощью
                    document.getElementBy
                    или window.frames.
                    После этого свойство contentWindow iFrame предоставляет доступ к targetFunction.
                </p>

                <pre>
                    document.getElementById("targetFrame").contentWindow.targetFunction();
                    window.frames[0].frameElement.contentWindow.targetFunction(); // Accessing iframe this way may not work in latest versions chrome and firefox
                </pre>

                <p>Информация устарела, об общении между окнами почитать можно <a
                        href="https://learn.javascript.ru/cross-window-communication" target="_blank">тут.</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment292">
            <div class="engJSTheory">How do get the timezone offset from date</div>
            <div class="ruJSTheory">Как получить смещение часового пояса относительно даты</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the getTimezoneOffset method of the date object. This method
                    returns
                    the time zone
                    difference, in minutes, from current locale (host system settings) to UTC
                </p>
                <p class="ruJSTheory">Вы можете использовать метод getTimezoneOffset объекта даты. Этот метод
                    возвращает
                    разницу часовых
                    поясов в минутах от текущего языкового стандарта (настройки хост-системы) до UTC.
                </p>

                <pre>
                    let offset = new Date().getTimezoneOffset();
                    console.log(offset); // -480
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment293">
            <div class="engJSTheory">How do you load CSS and JS files dynamically</div>
            <div class="ruJSTheory">Как динамически загружать файлы CSS и JS</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can create both link and script elements in the DOM and append them as
                    child
                    to
                    head tag. Let's
                    create a function to add script and style resources as below:
                </p>
                <p class="ruJSTheory">Вы можете создавать элементы ссылок и сценариев в DOM и добавлять их в
                    качестве
                    дочерних элементов к
                    тегу заголовка. Давайте создадим функцию для добавления ресурсов скриптов и стилей, как показано
                    ниже:
                </p>

                <pre>
                    function loadAssets(filename, filetype) {
                        if (filetype == "css") {
                          // External CSS file
                          var fileReference = document.createElement("link");
                          fileReference.setAttribute("rel", "stylesheet");
                          fileReference.setAttribute("type", "text/css");
                          fileReference.setAttribute("href", filename);
                        } else if (filetype == "js") {
                          // External JavaScript file
                          var fileReference = document.createElement("script");
                          fileReference.setAttribute("type", "text/javascript");
                          fileReference.setAttribute("src", filename);
                        }
                        if (typeof fileReference != "undefined")
                          document.getElementsByTagName("head")[0].appendChild(fileReference);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment294">
            <div class="engJSTheory">What are the different methods to find HTML elements in DOM</div>
            <div class="ruJSTheory">Какие существуют методы поиска HTML-элементов в DOM?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you want to access any element in an HTML page, you need to start with
                    accessing
                    the document
                    object. Later you can use any of the below methods to find the HTML element:
                </p>
                <p class="ruJSTheory">Если вы хотите получить доступ к любому элементу HTML-страницы, вам нужно
                    начать с
                    доступа к объекту
                    document. Позже вы можете использовать любой из следующих методов, чтобы найти элемент HTML:
                </p>

                <ol>
                    <li>
                        <div class="engJSTheory">document.getElementById(id): It finds an element by Id</div>
                        <div class="ruJSTheory">document.getElementById(id): находит элемент по идентификатору.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">document.getElementsByTagName(name): It finds an element by tag
                            name
                        </div>
                        <div class="ruJSTheory">document.getElementsByTagName(name): находит элемент по имени тега.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">document.getElementsByClassName(name): It finds an element by class
                            name
                        </div>
                        <div class="ruJSTheory">document.getElementsByClassName(name): находит элемент по имени
                            класса.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment295">
            <div class="engJSTheory">What is jQuery</div>
            <div class="ruJSTheory">Что такое jQuery</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">jQuery is a popular cross-browser JavaScript library that provides Document
                    Object
                    Model (DOM)
                    traversal, event handling, animations and AJAX interactions by minimizing the discrepancies
                    across
                    browsers. It is widely famous with its philosophy of “Write less, do more”. For example, you can
                    display
                    welcome message on the page load using jQuery as below,
                </p>
                <p class="ruJSTheory">jQuery — это популярная кросс-браузерная библиотека JavaScript, которая
                    обеспечивает
                    обход объектной
                    модели документа (DOM), обработку событий, анимацию и взаимодействие AJAX, сводя к минимуму
                    расхождения
                    между браузерами. Он широко известен своей философией «Пиши меньше, делай больше». Например, вы
                    можете
                    отобразить приветственное сообщение при загрузке страницы с помощью jQuery, как показано ниже:
                </p>

                <pre>
                $(document).ready(function () {
                    // It selects the document and apply the function on page load
                    alert("Welcome to jQuery world");
                });
            </pre>

                <p class="engJSTheory">Note: You can download it from jquery's official site or install it from CDNs,
                    like
                    google.
                </p>
                <p class="ruJSTheory">Примечание: Вы можете скачать его с официального сайта jquery или установить с
                    CDN,
                    например Google.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment296">
            <div class="engJSTheory">What is V8 JavaScript engine</div>
            <div class="ruJSTheory">Что такое движок JavaScript V8</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">V8 is an open source high-performance JavaScript engine used by the Google
                    Chrome
                    browser, written in
                    C++. It is also being used in the node.js project. It implements ECMAScript and WebAssembly, and
                    runs on
                    Windows 7 or later, macOS 10.12+, and Linux systems that use x64, IA-32, ARM, or MIPS
                    processors.
                    Note:
                    It can run standalone, or can be embedded into any C++ application.</p>
                <p class="ruJSTheory">V8 — это высокопроизводительный движок JavaScript с открытым исходным кодом,
                    используемый браузером
                    Google Chrome и написанный на C++. Он также используется в проекте node.js. Он реализует
                    ECMAScript
                    и
                    WebAssembly и работает в Windows 7 или более поздней версии, macOS 10.12+ и системах Linux,
                    использующих
                    процессоры x64, IA-32, ARM или MIPS. Примечание. Он может работать автономно или быть встроен в
                    любое
                    приложение C++.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment297">
            <div class="engJSTheory">Why do we call javascript as dynamic language</div>
            <div class="ruJSTheory">Почему JavaScript называется динамическим языком</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript is a loosely typed or a dynamic language because variables in
                    JavaScript
                    are not directly
                    associated with any particular value type, and any variable can be assigned/reassigned with
                    values
                    of
                    all types.</p>
                <p class="ruJSTheory">JavaScript — это слабо типизированный или динамический язык, поскольку
                    переменные
                    в
                    JavaScript не связаны
                    напрямую с каким-либо конкретным типом значения, и любой переменной можно
                    присвоить/переназначить
                    значения всех типов.</p>

                <pre>
                    let age = 50; // age is a number now
                    age = "old"; // age is a string now
                    age = true; // age is a boolean
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment298">
            <div class="engJSTheory">What is a void operator</div>
            <div class="ruJSTheory">Что такое оператор void</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The void operator evaluates the given expression and then returns
                    undefined(i.e,
                    without returning
                    value). The syntax would be as below:</p>
                <p class="ruJSTheory">Оператор void оценивает данное выражение, а затем возвращает undefined (т. е.
                    без
                    возврата значения).
                    Синтаксис будет таким, как показано ниже:</p>

                <pre>
                void expression;
                void expression;
            </pre>
                <p class="engJSTheory">Let's display a message without any redirection or reload:</p>
                <p class="ruJSTheory">Давайте отобразим сообщение без перенаправления или перезагрузки:</p>

                <pre>
                    &lt;a href="javascript:void(alert('Welcome to JS world'))"&gt;
                        Click here to see a message
                    &lt;/a&gt;
                </pre>

                <p class="engJSTheory">Note: This operator is often used to obtain the undefined primitive value,
                    using
                    "void(0)".</p>
                <p class="ruJSTheory">Примечание. Этот оператор часто используется для получения примитивного
                    значения
                    undefined с помощью «void(0)».</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment299">
            <div class="engJSTheory">How to set the cursor to wait</div>
            <div class="ruJSTheory">Как поставить курсор на ожидание</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The cursor can be set to wait in JavaScript by using the property "cursor".
                    Let's
                    perform this behavior
                    on page load using the below function.</p>
                <p class="ruJSTheory">Курсор можно настроить на ожидание в JavaScript, используя свойство "cursor".
                    Давайте
                    реализуем это поведение при загрузке страницы, используя функцию ниже.</p>

                <pre>
                    function myFunction() {
                        window.document.body.style.cursor = "wait";
                    }
                </pre>

                <p class="engJSTheory">and this function invoked on page load</p>
                <p class="ruJSTheory">и эта функция вызывается при загрузке страницы</p>

                <pre>
                < body onload="myFunction()">< /body>
            </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment300">
            <div class="engJSTheory">How do you create an infinite loop</div>
            <div class="ruJSTheory">Как создать бесконечный цикл</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">How do you create an infinite loop
                    You can create infinite loops using for and while loops without using any expressions. The for
                    loop
                    construct or syntax is better approach in terms of ESLint and code optimizer tools:</p>
                <p class="ruJSTheory">Вы можете создавать бесконечные циклы, используя циклы for и while, без
                    использования
                    каких-либо
                    выражений. Конструкция или синтаксис цикла for является лучшим подходом с точки зрения
                    инструментов
                    ESLint и оптимизатора кода.</p>

                <pre>
                    for (;;) {}
                    while (true) {}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment301">
            <div class="engJSTheory">Why do you need to avoid "with" statement</div>
            <div class="ruJSTheory">Почему нужно избегать оператора "with"</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript's with statement was intended to provide a shorthand for writing
                    recurring
                    accesses to
                    objects. So it can help reduce file size by reducing the need to repeat a lengthy object
                    reference
                    without performance penalty. Let's take an example where it is used to avoid redundancy when
                    accessing
                    an object several times.</p>
                <p class="ruJSTheory">Оператор with в JavaScript был предназначен для сокращения записи
                    повторяющихся
                    обращений к объектам.
                    Таким образом, это может помочь уменьшить размер файла за счет уменьшения необходимости
                    повторять
                    длинную ссылку на объект без снижения производительности. Давайте рассмотрим пример, где он
                    используется, чтобы избежать избыточности при многократном доступе к объекту.</p>

                <pre>
                    a.b.c.greeting = "welcome";
                    a.b.c.age = 32;
                </pre>

                <p class="engJSTheory">Using with it turns this into:</p>
                <p class="ruJSTheory">Использование «with» превращает это в:</p>

                <pre>
                    with (a.b.c) {
                        greeting = "welcome";
                        age = 32;
                    }
                </pre>

                <p class="engJSTheory">But this with statement creates performance problems since one cannot predict
                    whether
                    an argument will
                    refer to a real variable or to a property inside the with argument.</p>
                <p class="ruJSTheory">Но оператор with создает проблемы с производительностью, поскольку невозможно
                    предсказать, будет ли
                    аргумент ссылаться на действительную переменную или на свойство внутри аргумента with.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment302">
            <div class="engJSTheory">What is the output of below for loops</div>
            <div class="ruJSTheory">Каков вывод для приведенных ниже примеров циклов for</div>
        </h3>

        <section>
            <div>
                <pre>
                    for (var i = 0; i < 4; i++) {
                        // global scope
                        setTimeout(() => console.log(i));
                    }

                    for (let i = 0; i < 4; i++) {
                        // block scope
                        setTimeout(() => console.log(i));
                    }
                </pre>

                <p class="engJSTheory">The output of the above for loops is 4 4 4 4 and 0 1 2 3</p>
                <p class="ruJSTheory">Вывод приведенных выше циклов for равен 4 4 4 4 и 0 1 2 3.</p>
                <p class="engJSTheory">Explanation: Due to the event queue/loop of javascript, the setTimeout
                    callback
                    function is called after
                    the loop has been executed. Since the variable i is declared with the var keyword it became a
                    global
                    variable and the value was equal to 4 using iteration when the time setTimeout function is
                    invoked.
                    Hence, the output of the first loop is 4 4 4 4.</p>
                <p class="ruJSTheory">Объяснение: Из-за очереди событий/цикла JavaScript функция обратного вызова
                    setTimeout
                    вызывается после
                    выполнения цикла. Поскольку переменная i объявлена с ключевым словом var, она стала глобальной
                    переменной, и ее значение было равно 4 при использовании итерации при вызове функции time
                    setTimeout.
                    Следовательно, выход первого цикла равен 4 4 4 4.</p>
                <p class="engJSTheory">Whereas in the second loop, the variable i is declared as the let keyword it
                    becomes
                    a block scoped
                    variable and it holds a new value(0, 1 ,2 3) for each iteration. Hence, the output of the second
                    loop is
                    0 1 2 3.</p>
                <p class="ruJSTheory">В то время как во втором цикле переменная i объявлена как ключевое слово let,
                    она
                    становится переменной
                    области действия блока и содержит новое значение (0, 1, 2 3) для каждой итерации. Следовательно,
                    выход
                    второго цикла равен 0 1 2 3.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment303">
            <div class="engJSTheory">List down some of the features of ES6</div>
            <div class="ruJSTheory">Перечислите некоторые возможности ES6.</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of some new features of ES6:</p>
                <p class="ruJSTheory">Ниже приведен список некоторых новых функций ES6:</p>

                <ul>
                    <li>
                        <div class="engJSTheory">Support for constants or immutable variables</div>
                        <div class="ruJSTheory">Поддержка констант или неизменяемых переменных</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Block-scope support for variables, constants and functions</div>
                        <div class="ruJSTheory">Поддержка блочной области видимости для переменных, констант и
                            функций
                        </div>
                    </li>
                    <li>Стрелочные функции (Arrow functions)</li>
                    <li>Параметры по умолчанию (Default parameters)</li>
                    <li>Операторы Rest and Spread (Rest and Spread Parameters)</li>
                    <li>Шаблонные литералы (Template Literals)</li>
                    <li>Многострочные строки (Multi-line Strings)</li>
                    <li>Деструктуризация (Destructuring Assignment)</li>
                    <li>Расширенные объектные литералы(Enhanced Object Literals)</li>
                    <li>Промисы (Promises)</li>
                    <li>Классы (Classes)</li>
                    <li>Модули (Modules)</li>
                </ul>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment304">
            <div class="engJSTheory">What is ES6</div>
            <div class="ruJSTheory">Что такое ES6</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">ES6 is the sixth edition of the javascript language and it was released in
                    June
                    2015.
                    It was initially
                    known as ECMAScript 6 (ES6) and later renamed to ECMAScript 2015. Almost all the modern browsers
                    support
                    ES6 but for the old browsers there are many transpilers, like Babel.js etc.</p>
                <p class="ruJSTheory">ES6 — шестая редакция языка javascript, выпущенная в июне 2015 года.
                    Первоначально
                    он
                    был известен как
                    ECMAScript 6 (ES6), а затем переименован в ECMAScript 2015. Почти все современные браузеры
                    поддерживают
                    ES6, но для старых браузеров существует множество транспиляторов, например Babel.js и т. д.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment305">
            <div class="engJSTheory">Can I redeclare let and const variables</div>
            <div class="ruJSTheory">Могу ли я переопределить переменные let и const?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, you cannot redeclare let and const variables. If you do, it throws below
                    error:</p>
                <p class="ruJSTheory">Нет, вы не можете переопределить переменные let и const. Если вы это сделаете,
                    он
                    выдаст ошибку как показано ниже:</p>

                <pre>
                    Uncaught SyntaxError: Identifier 'someVariable' has already been declared
                </pre>

                <p class="engJSTheory">Explanation: The variable declaration with var keyword refers to a function
                    scope
                    and
                    the variable is
                    treated as if it were declared at the top of the enclosing scope due to hoisting feature. So all
                    the
                    multiple declarations contributing to the same hoisted variable without any error. Let's take an
                    example
                    of re-declaring variables in the same scope for both var and let/const variables.</p>
                <p class="ruJSTheory">Объяснение: Объявление переменной с ключевым словом var относится к области
                    действия
                    функции, и
                    переменная обрабатывается так, как если бы она была объявлена в верхней части охватывающей
                    области
                    видимости из-за функции подъема. Таким образом, все многочисленные объявления, вносящие вклад в
                    одну
                    и
                    ту же поднятую переменную, без каких-либо ошибок. Давайте рассмотрим пример повторного
                    объявления
                    переменных в одной области как для переменных var, так и для переменных let/const.</p>

                <pre>
                    let name = "John";
                    function myFunc() {
                        var name = "Nick";
                        var name = "Abraham"; // Re-assigned in the same function block
                        alert(name); // Abraham
                    }
                    myFunc();
                    alert(name); // John
                </pre>

                <p class="engJSTheory">The block-scoped multi-declaration throws syntax error:</p>
                <p class="ruJSTheory">Многократное объявление с областью действия блока выдает синтаксическую
                    ошибку:</p>

                <pre>
                    let name = "John";
                    function myFunc() {
                        let name = "Nick";
                        let name = "Abraham"; // Uncaught SyntaxError: Identifier 'name' has already been declared
                        alert(name);
                    }

                    myFunc();
                    alert(name);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment306">
            <div class="engJSTheory">Is const variable makes the value immutable</div>
            <div class="ruJSTheory">Константная переменная делает значение неизменяемым?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No, the const variable doesn't make the value immutable. But it disallows
                    subsequent
                    assignments(i.e, You
                    can declare with assignment but can't assign another value later)</p>
                <p class="ruJSTheory">Нет, переменная const не делает значение неизменяемым. Но он запрещает
                    последующие
                    назначения (т. е. вы
                    можете объявить с присвоением, но не можете позже присвоить другое значение)</p>

                <pre>
                    const userList = [];
                    userList.push("John"); // Can mutate even though it can't re-assign
                    console.log(userList); // ['John']
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment307">
            <div class="engJSTheory">What are default parameters</div>
            <div class="ruJSTheory">Что такое параметры по умолчанию</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In ES5, we need to depend on logical OR operators to handle default values of
                    function parameters.
                    Whereas in ES6, Default function parameters feature allows parameters to be initialized with
                    default
                    values if no value or undefined is passed. Let's compare the behavior with an examples:</p>
                <p class="ruJSTheory">В ES5 нам нужно полагаться на логические операторы ИЛИ для обработки значений
                    параметров функции по
                    умолчанию. В то время как в ES6 функция параметров функции по умолчанию позволяет
                    инициализировать
                    параметры значениями по умолчанию, если не передано никакое значение или неопределенное
                    значение.
                    Давайте сравним поведение с примерами:</p>

                <pre>
                    //ES5
                    var calculateArea = function (height, width) {
                        height = height || 50;
                        width = width || 60;

                        return width * height;
                    };
                    console.log(calculateArea()); //300
                </pre>

                <p class="engJSTheory">The default parameters makes the initialization more simpler:</p>
                <p class="ruJSTheory">Параметры по умолчанию упрощают инициализацию:</p>

                <pre>
                    //ES6
                    var calculateArea = function (height = 50, width = 60) {
                        return width * height;
                    };

                    console.log(calculateArea()); //300
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment308">
            <div class="engJSTheory">What are template literals</div>
            <div class="ruJSTheory">Что такое шаблонные литералы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Template literals or template strings are string literals allowing embedded
                    expressions. These are
                    enclosed by the back-tick (`) character instead of double or single quotes. In ES6, this feature
                    enables
                    using dynamic expressions as below:</p>
                <p class="ruJSTheory">Литералы шаблонов или строки шаблонов — это строковые литералы, позволяющие
                    встраивать
                    выражения. Они
                    заключаются в обратную галочку (`) вместо двойных или одинарных кавычек. В ES6 эта функция
                    позволяет
                    использовать динамические выражения, как показано ниже:</p>

                <pre>
                    let greeting = `Welcome to JS World, Mr. ${firstName} ${lastName}.`;
                </pre>

                <p class="engJSTheory">In ES5, you need break string like below:</p>
                <p class="ruJSTheory">В ES5 вам нужно разорвать строку, как показано ниже:</p>

                <pre>
                    var greeting = 'Welcome to JS World, Mr. ' + firstName + ' ' + lastName;
                </pre>

                <p class="engJSTheory">Note: You can use multi-line strings and string interpolation features with
                    template
                    literals.</p>
                <p class="ruJSTheory">Примечание. С литералами шаблона можно использовать многострочные строки и
                    функции
                    интерполяции строк.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment309">
            <div class="engJSTheory">How do you write multi-line strings in template literals</div>
            <div class="ruJSTheory">Как писать многострочные строки в литералах шаблона</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In ES5, you would have to use newline escape characters('\n') and
                    concatenation
                    symbols(+) in order to get multi-line strings.</p>
                <p class="ruJSTheory">В ES5 вам придется использовать escape-символы новой строки ('\n') и символы
                    конкатенации (+), чтобы получить многострочные строки.</p>

                <pre>
                console.log("This is string sentence 1\n" + "This is string sentence 2");
            </pre>

                <p class="engJSTheory">Whereas in ES6, You don't need to mention any newline sequence character:</p>
                <p class="ruJSTheory">В то время как в ES6 вам не нужно упоминать какой-либо символ новой
                    строки:</p>

                <pre>
                    console.log(`This is string sentence
                    'This is string sentence 2`);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment310">
            <div class="engJSTheory">What are nesting templates</div>
            <div class="ruJSTheory">Что такое шаблоны вложения(nesting templates)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The nesting template is a feature supported within template literals syntax
                    to
                    allow
                    inner backticks
                    inside a placeholder ${ } within the template. For example, the below nesting template is used
                    to
                    display the icons based on user permissions whereas outer template checks for platform type:</p>
                <p class="ruJSTheory">Шаблон вложения — это функция, поддерживаемая в синтаксисе литералов шаблона,
                    позволяющая использовать
                    внутренние обратные кавычки внутри заполнителя ${ } внутри шаблона. Например, приведенный ниже
                    шаблон
                    вложения используется для отображения значков на основе разрешений пользователя, тогда как
                    внешний
                    шаблон проверяет тип платформы:</p>

                <pre>
                    const iconStyles = `icon ${
                        isMobilePlatform()
                            ? ""
                            : `icon-${user.isAuthorized ? "submit" : "disabled"}`
                    }`;
                </pre>

                <p class="engJSTheory">You can write the above use case without nesting template features as well.
                    However,
                    the nesting template
                    feature is more compact and readable.</p>
                <p class="ruJSTheory">Вы также можете написать приведенный выше вариант использования без вложения
                    функций
                    шаблона. Однако
                    функция шаблона вложения более компактна и удобочитаема.</p>

                <pre>
                    //Without nesting templates
                    const iconStyles = `icon ${
                        isMobilePlatform()
                            ? ""
                            : user.isAuthorized
                            ? "icon-submit"
                            : "icon-disabled"
                    }`;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment311">
            <div class="engJSTheory">What are tagged templates</div>
            <div class="ruJSTheory">Что такое теговые шаблоны(tagged templates)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Tagged templates are the advanced form of templates in which tags allow you
                    to
                    parse
                    template literals
                    with a function. The tag function accepts the first parameter as an array of strings and
                    remaining
                    parameters as expressions. This function can also return manipulated strings based on
                    parameters.
                    Let's
                    see the usage of this tagged template behavior of an IT professional skill set in an
                    organization:</p>
                <p class="ruJSTheory">Шаблоны с тегами — это расширенная форма шаблонов, в которой теги позволяют
                    анализировать литералы
                    шаблона с помощью функции. Функция тега принимает первый параметр как массив строк, а остальные
                    параметры как выражения. Эта функция также может возвращать измененные строки на основе
                    параметров.
                    Давайте посмотрим, как этот шаблон с тегами используется в наборе навыков ИТ-специалиста в
                    организации:</p>

                <pre>
                    var user1 = "John";
                    var skill1 = "JavaScript";
                    var experience1 = 15;

                    var user2 = "Kane";
                    var skill2 = "JavaScript";
                    var experience2 = 5;

                    function myInfoTag(strings, userExp, experienceExp, skillExp) {
                        var str0 = strings[0]; // "Mr/Ms. "
                        var str1 = strings[1]; // " is a/an "
                        var str2 = strings[2]; // "in"

                        var expertiseStr;
                        if (experienceExp > 10) {
                          expertiseStr = "expert developer";
                        } else if (skillExp > 5 && skillExp <= 10) {
                          expertiseStr = "senior developer";
                        } else {
                          expertiseStr = "junior developer";
                        }

                        return `${str0}${userExp}${str1}${expertiseStr}${str2}${skillExp}`;
                    }

                    var output1 = myInfoTag`Mr/Ms. ${user1} is a/an ${experience1} in ${skill1}`;
                    var output2 = myInfoTag`Mr/Ms. ${user2} is a/an ${experience2} in ${skill2}`;

                    console.log(output1); // Mr/Ms. John is a/an expert developer in JavaScript
                    console.log(output2); // Mr/Ms. Kane is a/an junior developer in JavaScript
                </pre>

                <p>Подробнее модно почитать на <a href="https://habr.com/ru/companies/ruvds/articles/511590/"
                                                  target="_blank">Habr</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment312">
            <div class="engJSTheory">What are raw strings</div>
            <div class="ruJSTheory">Что такое String.raw()</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">ES6 provides a raw strings feature using the String.raw() method which is
                    used to
                    get
                    the raw string form
                    of template strings. This feature allows you to access the raw strings as they were entered,
                    without
                    processing escape sequences. For example, the usage would be as below:</p>
                <p class="ruJSTheory">ES6 предоставляет функцию необработанных строк с использованием метода
                    String.raw(),
                    который используется
                    для получения необработанной строковой формы строк шаблона. Эта функция позволяет получить
                    доступ к
                    необработанным строкам в том виде, в котором они были введены, без обработки
                    escape-последовательностей.
                    Например, использование будет таким, как показано ниже:</p>

                <pre>
                    let calculationString = String.raw`The sum of numbers is \n${
                        1 + 2 + 3 + 4
                    }!`;
                    console.log(calculationString); // The sum of numbers is \n10!
                </pre>

                <p class="engJSTheory">If you don't use raw strings, the newline character sequence will be
                    processed by
                    displaying the output
                    in multiple lines:</p>
                <p class="ruJSTheory">Если вы не используете необработанные строки, последовательность символов
                    новой
                    строки
                    будет обработана
                    путем отображения вывода в нескольких строках:</p>

                <pre>
                    let calculationString = `The sum of numbers is \n${1 + 2 + 3 + 4}!`;
                    console.log(calculationString);
                    // The sum of numbers is
                    // 10!
                </pre>

                <p class="engJSTheory">Also, the raw property is available on the first argument to the tag
                    function:</p>
                <p class="ruJSTheory">Кроме того, свойство raw доступно для первого аргумента функции тега:</p>

                <pre>
                    function tag(strings) {
                        console.log(strings.raw[0]);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment313">
            <div class="engJSTheory">What is destructuring assignment</div>
            <div class="ruJSTheory">Что такое деструктуризация присваивания</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The destructuring assignment is a JavaScript expression that makes it
                    possible to
                    unpack values from
                    arrays or properties from objects into distinct variables. Let's get the month values from an
                    array
                    using destructuring assignment:</p>
                <p class="ruJSTheory">Присвоение деструктуризации — это выражение JavaScript, которое позволяет
                    распаковывать значения из
                    массивов или свойства объектов в отдельные переменные. Давайте получим значения месяца из
                    массива,
                    используя деструктурирующее присваивание.</p>

                <pre>
                    let [one, two, three] = ["JAN", "FEB", "MARCH"];

                    console.log(one); // "JAN"
                    console.log(two); // "FEB"
                    console.log(three); // "MARCH"
                </pre>

                <p class="engJSTheory">and you can get user properties of an object using destructuring
                    assignment:</p>
                <p class="ruJSTheory">и вы можете получить пользовательские свойства объекта, используя назначение
                    деструктуризации:</p>

                <pre>
                    let { name, age } = { name: "John", age: 32 };

                    console.log(name); // John
                    console.log(age); // 32
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment314">
            <div class="engJSTheory">What are default values in destructuring assignment</div>
            <div class="ruJSTheory">Значения по умолчанию при назначении деструктуризации</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A variable can be assigned a default value when the value unpacked from the
                    array
                    or
                    object is undefined
                    during destructuring assignment. It helps to avoid setting default values separately for each
                    assignment. Let's take an example for both arrays and object use cases:</p>
                <p class="ruJSTheory">Переменной может быть присвоено значение по умолчанию, если значение,
                    распакованное из
                    массива или
                    объекта, не определено во время деструктурирующего присваивания. Это помогает избежать установки
                    значений по умолчанию отдельно для каждого назначения. Давайте рассмотрим пример как для
                    массивов,
                    так и
                    для случаев использования объектов:</p>
                <p class="engJSTheory">Arrays destructuring:</p>
                <p class="ruJSTheory">Деструктуризация массивов:</p>

                <pre>
                    var x, y, z;

                    [x = 2, y = 4, z = 6] = [10];
                    console.log(x); // 10
                    console.log(y); // 4
                    console.log(z); // 6
                </pre>

                <p class="engJSTheory">Objects destructuring:</p>
                <p class="ruJSTheory">Деструктуризация объектов:</p>

                <pre>
                    let { x = 2, y = 4, z = 6 } = { x: 10 };

                    console.log(x); // 10
                    console.log(y); // 4
                    console.log(z); // 6
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment315">
            <div class="engJSTheory">How do you swap variables in destructuring assignment</div>
            <div class="ruJSTheory">Как поменять местами переменные при деструктурировании присваивания</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you don't use destructuring assignment, swapping two values requires a
                    temporary
                    variable. Whereas
                    using a destructuring feature, two variable values can be swapped in one destructuring
                    expression.
                    Let's
                    swap two number variables in array destructuring assignment:</p>
                <p class="ruJSTheory">Если вы не используете деструктурирующее присваивание, для замены двух
                    значений
                    потребуется временная
                    переменная. При использовании функции деструктуризации два значения переменных можно поменять
                    местами в
                    одном выражении деструктуризации. Давайте поменяем местами две числовые переменные в
                    присваивании
                    деструктуризации массива:</p>

                <pre>
                    var x = 10, y = 20;

                    [x, y] = [y, x];
                    console.log(x); // 20
                    console.log(y); // 10
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment316">
            <div class="engJSTheory">What are enhanced object literals</div>
            <div class="ruJSTheory">Что такое расширенные литералы объектов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Object literals make it easy to quickly create objects with properties inside
                    the
                    curly braces. For
                    example, it provides shorter syntax for common object property definition as below.</p>
                <p class="ruJSTheory">Литералы объектов позволяют легко и быстро создавать объекты со свойствами
                    внутри
                    фигурных скобок.
                    Например, он обеспечивает более короткий синтаксис для определения общих свойств объекта, как
                    показано
                    ниже.</p>

                <pre>
                    //ES6
                    var x = 10, y = 20;
                    obj = { x, y };
                    console.log(obj); // {x: 10, y:20}
                    //ES5
                    var x = 10, y = 20;
                    obj = { x: x, y: y };
                    console.log(obj); // {x: 10, y:20}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment317">
            <div class="engJSTheory">What are dynamic imports</div>
            <div class="ruJSTheory">Что такое динамический импорт</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The dynamic imports using import() function syntax allows us to load modules
                    on
                    demand by using promises
                    or the async/await syntax. Currently this feature is in stage4 proposal. The main advantage of
                    dynamic
                    imports is reduction of our bundle's sizes, the size/payload response of our requests and
                    overall
                    improvements in the user experience. The syntax of dynamic imports would be as below:</p>
                <p class="ruJSTheory">Динамический импорт с использованием синтаксиса функции import() позволяет нам
                    загружать модули по
                    требованию, используя обещания или синтаксис async/await. В настоящее время эта функция
                    находится в
                    стадии предложения 4. Основным преимуществом динамического импорта является уменьшение размеров
                    нашего
                    пакета, ответа на размер/полезную нагрузку наших запросов и общее улучшение пользовательского
                    опыта.
                    Синтаксис динамического импорта будет выглядеть следующим образом:</p>

                <pre>
                    import("./Module").then((Module) => Module.method());
                </pre>

                <p>Подробнее можно почитать на <a
                        href="https://learn.javascript.ru/modules-dynamic-imports?ysclid=lp37e3suuq686556051"
                        target="_blank">learn.javascript.ru</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment318">
            <div class="engJSTheory">What are the use cases for dynamic imports</div>
            <div class="ruJSTheory">Каковы варианты использования динамического импорта</div>
        </h3>

        <section>
            <div>
                <ol>
                    <li>
                        <div class="engJSTheory">Import a module on-demand or conditionally. For example, if you want to
                            load a polyfill on legacy browser:
                        </div>
                        <div class="ruJSTheory">Импортируйте модуль по требованию или условно. Например, если вы хотите
                            загрузить полифилл в устаревшем браузере:
                        </div>
                        <pre>
                            if (isLegacyBrowser()) {
                                import(···)
                                  .then(···);
                            }
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Compute the module specifier at runtime. For example, you can use
                            it
                            for
                            internationalization:
                        </div>
                        <div class="ruJSTheory">Вычислите спецификатор модуля во время выполнения. Например, вы
                            можете
                            использовать его для интернационализации:
                        </div>
                        <pre>
                            import(`messages_${getLocale()}.js`).then(···);
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Import a module from within a regular script instead a module.
                        </div>
                        <div class="ruJSTheory">Импортируйте модуль из обычного скрипта вместо модуля.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment319">
            <div class="engJSTheory">What are typed arrays</div>
            <div class="ruJSTheory">Что такое типизированные массивы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Typed arrays are array-like objects from ECMAScript 6 API for handling binary
                    data.
                    JavaScript provides 8
                    Typed array types:</p>
                <p class="ruJSTheory">Типизированные массивы — это подобные массиву объекты из API ECMAScript 6 для
                    обработки двоичных данных.
                    JavaScript предоставляет 8 типов типизированных массивов:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Int8Array: An array of 8-bit signed integers</div>
                        <div class="ruJSTheory">Int8Array: массив 8-битных целых чисел со знаком.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Int16Array: An array of 16-bit signed integers</div>
                        <div class="ruJSTheory">Int16Array: массив 16-битных целых чисел со знаком.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Int32Array: An array of 32-bit signed integers</div>
                        <div class="ruJSTheory">Int32Array: массив 32-битных целых чисел со знаком.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Uint8Array: An array of 8-bit unsigned integers</div>
                        <div class="ruJSTheory">Uint8Array: массив 8-битных целых чисел без знака.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Uint16Array: массив 16-битных целых чисел без знака.</div>
                        <div class="ruJSTheory">Uint16Array: массив 16-битных целых чисел без знака.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Uint32Array: An array of 32-bit unsigned integers</div>
                        <div class="ruJSTheory">Uint32Array: массив 32-битных целых чисел без знака.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Float32Array: An array of 32-bit floating point numbers</div>
                        <div class="ruJSTheory">Float32Array: An array of 32-bit floating point numbers</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Float64Array: An array of 64-bit floating point numbers</div>
                        <div class="ruJSTheory">Float64Array: массив 64-битных чисел с плавающей запятой.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment320">
            <div class="engJSTheory">What are the advantages of module loaders</div>
            <div class="ruJSTheory">В чем преимущества загрузчиков модулей</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The module loaders provides the below features:</p>
                <p class="ruJSTheory">Загрузчики модулей предоставляют следующие функции:</p>

                <ol>
                    <li>Динамическая загрузка (Dynamic loading)</li>
                    <li>Изоляция состояния (State isolation)</li>
                    <li>Глобальная изоляция пространства имен (Global namespace isolation)</li>
                    <li>Хуки компиляции (Compilation hooks)</li>
                    <li>Вложенная виртуализация (Nested virtualization)</li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment321">
            <div class="engJSTheory">What is collation</div>
            <div class="ruJSTheory">Что такое параметры сортировки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Collation is used for sorting a set of strings and searching within a set of
                    strings.
                    It is parameterized
                    by locale and aware of Unicode. Let's take comparison and sorting features:</p>
                <p class="ruJSTheory">Параметры сортировки используются для сортировки набора строк и поиска внутри
                    набора
                    строк. Он
                    параметризуется локалью и поддерживает Unicode. Давайте возьмем функции сравнения и
                    сортировки:</p>

                <ol>
                    <li>
                        Comparison(сравнение):
                        <pre>
                            let list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
                            let l10nDE = new Intl.Collator("de");
                            let l10nSV = new Intl.Collator("sv");
                            console.log(l10nDE.compare("ä", "z") === -1); // true
                            console.log(l10nSV.compare("ä", "z") === +1); // true
                        </pre>
                    </li>
                    <li>
                        Sorting(сортировка):
                        <pre>
                            let list = ["ä", "a", "z"]; // In German,  "ä" sorts with "a" Whereas in Swedish, "ä" sorts after "z"
                            let l10nDE = new Intl.Collator("de");
                            let l10nSV = new Intl.Collator("sv");
                            console.log(list.sort(l10nDE.compare)); // [ "a", "ä", "z" ]
                            console.log(list.sort(l10nSV.compare)); // [ "a", "z", "ä" ]
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment322">
            <div class="engJSTheory">What is for...of statement</div>
            <div class="ruJSTheory">Что такое цикл for...of</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The for...of statement creates a loop iterating over iterable objects or
                    elements
                    such as built-in
                    String, Array, Array-like objects (like arguments or NodeList), TypedArray, Map, Set, and
                    user-defined
                    iterables. The basic usage of for...of statement on arrays would be as below:</p>
                <p class="ruJSTheory">Оператор for...of создает цикл, перебирающий повторяемые объекты или элементы,
                    такие
                    как встроенные
                    String, Array, объекты, подобные массиву (например, аргументы или NodeList), TypedArray, Map,
                    Set и
                    определяемые пользователем итерации. Основное использование оператора for...of для массивов
                    будет
                    таким,
                    как показано ниже:</p>

                <pre>
                    let arrayIterable = [10, 20, 30, 40, 50];

                    for (let value of arrayIterable) {
                        value++;
                        console.log(value); // 11 21 31 41 51
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment323">
            <div class="engJSTheory">What is the output of below spread operator array</div>
            <div class="ruJSTheory">Каков вывод массива операторов распространения ниже?</div>
        </h3>

        <section>
            <div>
            <pre>
                [..."John Resig"];
            </pre>

                <p class="engJSTheory">The output of the array is ['J', 'o', 'h', 'n', '', 'R', 'e', 's', 'i', 'g']
                    Explanation: The string is
                    an iterable type and the spread operator within an array maps every character of an iterable to
                    one
                    element. Hence, each character of a string becomes an element within an Array.</p>
                <p class="ruJSTheory">Выходные данные массива: ['J', 'o', 'h', 'n', '', 'R', 'e', 's', 'i', 'g']
                    Объяснение:
                    Строка является
                    итерируемым типом, и оператор spread внутри массива сопоставляет каждый символ итерируемого
                    объекта
                    с одним элементом. Следовательно, каждый символ строки становится элементом массива.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment324">
            <div class="engJSTheory">Is PostMessage secure</div>
            <div class="ruJSTheory">Безопасно ли использовать PostMessage</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, postMessages can be considered very secure as long as the
                    programmer/developer
                    is careful about
                    checking the origin and source of an arriving message. But if you try to send/receive a message
                    without
                    verifying its source will create cross-site scripting attacks.</p>
                <p class="ruJSTheory">Да, postMessages можно считать очень безопасным, если программист/разработчик
                    внимательно проверяет
                    происхождение и источник приходящего сообщения. Но если вы попытаетесь отправить/получить
                    сообщение
                    без
                    проверки его источника, это приведет к атакам с использованием межсайтовых сценариев.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment325">
            <div class="engJSTheory">What are the problems with postmessage target origin as wildcard</div>
            <div class="ruJSTheory">Какие существуют проблемы с целевым происхождением postmessage в качестве
                wildcard?
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The second argument of postMessage method specifies which origin is allowed
                    to
                    receive the message. If
                    you use the wildcard “*” as an argument then any origin is allowed to receive the message. In
                    this
                    case,
                    there is no way for the sender window to know if the target window is at the target origin when
                    sending
                    the message. If the target window has been navigated to another origin, the other origin would
                    receive
                    the data. Hence, this may lead to XSS vulnerabilities.</p>
                <p class="ruJSTheory">Второй аргумент метода postMessage указывает, какому источнику разрешено
                    получать
                    сообщение. Если вы
                    используете подстановочный знак «*» в качестве аргумента, то любой источник может получить
                    сообщение. В
                    этом случае окно отправителя не может узнать, находится ли целевое окно в целевом источнике при
                    отправке
                    сообщения. Если целевое окно было перенаправлено к другому источнику, другой источник получит
                    данные.
                    Следовательно, это может привести к уязвимостям XSS.</p>

                <pre>
                    targetWindow.postMessage(message, "*");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment326">
            <div class="engJSTheory">How do you avoid receiving postMessages from attackers</div>
            <div class="ruJSTheory">Как избежать получения postMessage от злоумышленников</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Since the listener listens for any message, an attacker can trick the
                    application
                    by
                    sending a message
                    from the attacker’s origin, which gives an impression that the receiver received the message
                    from
                    the
                    actual sender’s window. You can avoid this issue by validating the origin of the message on the
                    receiver's end using the “message.origin” attribute. For examples, let's check the sender's
                    origin
                    <a href="http://www.some-sender.com" target="_blank">http://www.some-sender.com</a> on receiver
                    side
                    www.some-receiver.com:</p>
                <p class="ruJSTheory">Поскольку прослушиватель прослушивает любое сообщение, злоумышленник может
                    обмануть
                    приложение, отправив
                    сообщение из источника злоумышленника, что создает впечатление, что получатель получил сообщение
                    из
                    фактического окна отправителя. Вы можете избежать этой проблемы, проверив происхождение
                    сообщения на
                    стороне получателя с помощью атрибута «message.origin». Для примера давайте проверим
                    происхождение
                    отправителя <a href="http://www.some-sender.com" target="_blank">http://www.some-sender.com</a>
                    на
                    стороне получателя
                    www.some-receiver.com:</p>

                <pre>
                    //Listener on http://www.some-receiver.com/
                    window.addEventListener("message", function(message){
                        if(/^http://www\.some-sender\.com$/.test(message.origin)){
                            console.log('You received the data from valid sender', message.data);
                        }
                    });
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment327">
            <div class="engJSTheory">Can I avoid using postMessages completely</div>
            <div class="ruJSTheory">Можно ли полностью избежать использования postMessage?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You cannot avoid using postMessages completely(or 100%). Even though your
                    application
                    doesn’t use
                    postMessage considering the risks, a lot of third party scripts use postMessage to communicate
                    with
                    the
                    third party service. So your application might be using postMessage without your knowledge.</p>
                <p class="ruJSTheory">Вы не можете избежать использования postMessages полностью (или на 100%).
                    Несмотря
                    на
                    то, что ваше
                    приложение не использует postMessage, учитывая риски, многие сторонние скрипты используют
                    postMessage
                    для связи со сторонним сервисом. Таким образом, ваше приложение может использовать postMessage
                    без
                    вашего ведома.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment328">
            <div class="engJSTheory">Is postMessages synchronous</div>
            <div class="ruJSTheory">Синхронен ли postMessages?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The postMessages are synchronous in IE8 browser but they are asynchronous in
                    IE9
                    and
                    all other modern
                    browsers (i.e, IE9+, Firefox, Chrome, Safari).Due to this asynchronous behaviour, we use a
                    callback
                    mechanism when the postMessage is returned.</p>
                <p class="ruJSTheory">Сообщения postMessage синхронны в браузере IE8, но они асинхронны в IE9 и всех
                    других
                    современных
                    браузерах (например, IE9+, Firefox, Chrome, Safari). Из-за такого асинхронного поведения мы
                    используем
                    механизм обратного вызова при возврате сообщения postMessage.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment329">
            <div class="engJSTheory">What paradigm is Javascript</div>
            <div class="ruJSTheory">Какая парадигма представляет собой Javascript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript is a multi-paradigm language, supporting imperative/procedural
                    programming, Object-Oriented
                    Programming and functional programming. JavaScript supports Object-Oriented Programming with
                    prototypical inheritance.</p>
                <p class="ruJSTheory">JavaScript — это мультипарадигмальный язык, поддерживающий
                    императивное/процедурное
                    программирование,
                    объектно-ориентированное программирование и функциональное программирование. JavaScript
                    поддерживает
                    объектно-ориентированное программирование с прототипным наследованием.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment330">
            <div class="engJSTheory">What is the difference between internal and external javascript</div>
            <div class="ruJSTheory">В чем разница между внутренним и внешним JavaScript</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Internal JavaScript: It is the source code within the script tag. <br>
                    External JavaScript: The source code is
                    stored in an external file(stored with .js extension) and referred with in the tag.</p>
                <p class="ruJSTheory">Внутренний JavaScript: это исходный код внутри тега скрипта. <br>
                    Внешний JavaScript: исходный код хранится во внешнем файле (с расширением .js) и упоминается в
                    теге.
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment331">
            <div class="engJSTheory">Is JavaScript faster than server side script</div>
            <div class="ruJSTheory">JavaScript быстрее, чем серверный скрипт?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, JavaScript is faster than server side scripts. Because JavaScript is a
                    client-side script it does
                    not require any web server’s help for its computation or calculation. So JavaScript is always
                    faster
                    than any server-side script like ASP, PHP, etc.</p>
                <p class="ruJSTheory">Да, JavaScript быстрее, чем серверные скрипты. Поскольку JavaScript является
                    клиентским скриптом, для
                    его вычислений не требуется помощь какого-либо веб-сервера. Таким образом, JavaScript всегда
                    быстрее,
                    чем любой серверный скрипт, такой как ASP, PHP и т. д.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment332">
            <div class="engJSTheory">How do you get the status of a checkbox</div>
            <div class="ruJSTheory">Как узнать статус checkbox инпута</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can apply the checked property on the selected checkbox in the DOM. If
                    the
                    value
                    is true it means the
                    checkbox is checked, otherwise it is unchecked. For example, the below HTML checkbox element can
                    be
                    access using javascript as below:</p>
                <p class="ruJSTheory">Вы можете применить проверенное свойство к выбранному checkbox инпуту в DOM.
                    Если
                    значение истинно, это означает,
                    что флажок установлен, в противном случае он снят. Например, к приведенному ниже элементу
                    checkbox
                    HTML
                    можно получить доступ с помощью JavaScript, как показано ниже:</p>

                <pre>
                    < input type="checkbox" id="checkboxname" value="Agree" /> Agree the conditions< br />

                    console.log(document.getElementById(‘checkboxname’).checked); // true or false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment333">
            <div class="engJSTheory">What is the purpose of double tilde operator</div>
            <div class="ruJSTheory">Какова цель оператора двойной тильды</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The double tilde operator(~~) is known as double NOT bitwise operator. This
                    operator
                    is a slightly quicker substitute for Math.floor().</p>
                <p class="ruJSTheory">Оператор двойной тильды (~~) известен как побитовый оператор двойного НЕ. Этот
                    оператор является немного более быстрой заменой Math.floor().</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment334">
            <div class="engJSTheory">How do you convert character to ASCII code</div>
            <div class="ruJSTheory">Как преобразовать символ в код ASCII</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use the String.prototype.charCodeAt() method to convert string
                    characters
                    to
                    ASCII numbers. For
                    example, let's find ASCII code for the first letter of 'ABC' string:</p>
                <p class="ruJSTheory">Вы можете использовать метод String.prototype.charCodeAt() для преобразования
                    строковых символов в числа
                    ASCII. Например, давайте найдем код ASCII для первой буквы строки ABC:</p>

                <pre>
                    "ABC".charCodeAt(0); // returns 65
                </pre>

                <p class="engJSTheory">Whereas String.fromCharCode() method converts numbers to equal ASCII
                    characters.</p>
                <p class="ruJSTheory">Тогда как метод String.fromCharCode() преобразует числа в эквивалентные
                    символы
                    ASCII.</p>

                <pre>
                    String.fromCharCode(65, 66, 67); // returns 'ABC'
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment335">
            <div class="engJSTheory">What is ArrayBuffer</div>
            <div class="ruJSTheory">Что такое ArrayBuffer</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An ArrayBuffer object is used to represent a generic, fixed-length raw binary
                    data
                    buffer. You can create
                    it as below:</p>
                <p class="ruJSTheory">Объект ArrayBuffer используется для представления универсального буфера
                    необработанных
                    двоичных данных
                    фиксированной длины. Вы можете создать его, как показано ниже:</p>

                <pre>
                    let buffer = new ArrayBuffer(16); // create a buffer of length 16
                    alert(buffer.byteLength); // 16
                </pre>

                <p class="engJSTheory">To manipulate an ArrayBuffer, we need to use a “view” object.</p>
                <p class="ruJSTheory">Чтобы манипулировать ArrayBuffer, нам нужно использовать объект “view”.</p>

                <pre>
                    //Create a DataView referring to the buffer
                    let view = new DataView(buffer);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment336">
            <div class="engJSTheory">What is the output of below string expression</div>
            <div class="ruJSTheory">Каков вывод приведенного ниже строкового выражения</div>
        </h3>

        <section>
            <div>
                <pre>
                    console.log("Welcome to JS world"[0]);
                </pre>

                <p class="engJSTheory">The output of the above expression is "W". Explanation: The bracket notation
                    with
                    specific index on a
                    string returns the character at a specific location. Hence, it returns the character "W" of the
                    string.
                    Since this is not supported in IE7 and below versions, you may need to use the .charAt() method
                    to
                    get
                    the desired result.</p>
                <p class="ruJSTheory">Результатом приведенного выше выражения является "W". Объяснение: Обозначение
                    скобок с
                    определенным
                    индексом в строке возвращает символ в определенном месте. Следовательно, он возвращает символ
                    «W»
                    строки. Поскольку это не поддерживается в версиях IE7 и ниже, вам может потребоваться
                    использовать
                    метод
                    .charAt() для получения желаемого результата.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment337">
            <div class="engJSTheory">What is the purpose of Error object</div>
            <div class="ruJSTheory">Какова цель объекта Error</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Error constructor creates an error object and the instances of error
                    objects
                    are
                    thrown when runtime
                    errors occur. The Error object can also be used as a base object for user-defined exceptions.
                    The
                    syntax
                    of error object would be as below:</p>
                <p class="ruJSTheory">Конструктор Error создает объект ошибки, и экземпляры объектов Error создаются
                    при
                    возникновении ошибок
                    во время выполнения. Объект Error также можно использовать в качестве базового объекта для
                    определяемых
                    пользователем исключений. Синтаксис объекта Error будет выглядеть следующим образом:</p>

                <pre>
                    new Error([message[, fileName[, lineNumber]]])
                </pre>

                <p class="engJSTheory">You can throw user defined exceptions or errors using Error object in
                    try...catch
                    block as below:</p>
                <p class="ruJSTheory">Вы можете создавать определенные пользователем исключения или ошибки,
                    используя
                    объект
                    Error в блоке try...catch, как показано ниже:</p>

                <pre>
                    try {
                        if (withdraw > balance)
                            throw new Error("Oops! You don't have enough balance");
                    } catch (err) {
                        console.log(err.name + ": " + err.message);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment338">
            <div class="engJSTheory">What is the purpose of EvalError object</div>
            <div class="ruJSTheory">Какова цель объекта EvalError</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The EvalError object indicates an error regarding the global eval() function.
                    Even
                    though this exception
                    is not thrown by JavaScript anymore, the EvalError object remains for compatibility. The syntax
                    of
                    this
                    expression would be as below:</p>
                <p class="ruJSTheory">Объект EvalError указывает на ошибку, связанную с глобальной функцией eval().
                    Несмотря
                    на то, что это
                    исключение больше не генерируется JavaScript, объект EvalError остается для совместимости.
                    Синтаксис
                    этого выражения будет таким, как показано ниже:</p>

                <pre>
                    new EvalError([message[, fileName[, lineNumber]]])
                </pre>

                <p class="engJSTheory">You can throw EvalError with in try...catch block as below:</p>
                <p class="ruJSTheory">Вы можете использовать EvalError с помощью блока try...catch, как показано
                    ниже:</p>

                <pre>
                    try {
                        throw new EvalError('Eval function error', 'someFile.js', 100);
                    } catch (e) {
                        console.log(e.message, e.name, e.fileName); // "Eval function error", "EvalError", "someFile.js"
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment339">
            <div class="engJSTheory">What are the list of cases error thrown from non-strict mode to strict mode
            </div>
            <div class="ruJSTheory">Каков список случаев ошибки, возникающей при переходе из нестрогого
                режима(non-strict
                mode) в строгий режим(strict mode)?
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">When you apply 'use strict'; syntax, some of the below cases will throw a
                    SyntaxError
                    before executing the script:</p>
                <p class="ruJSTheory">Когда вы применяете 'use strict'; синтаксис, в некоторых из приведенных ниже
                    случаев
                    перед выполнением сценария будет выдана ошибка SyntaxError:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">When you use Octal syntax:</div>
                        <div class="ruJSTheory">Когда вы используете восьмеричный синтаксис</div>
                        <pre>
                            var n = 022;
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using with statement</div>
                        <div class="ruJSTheory">Использование оператора with</div>
                    </li>
                    <li>
                        <div class="engJSTheory">When you use delete operator on a variable name</div>
                        <div class="ruJSTheory">Когда вы используете оператор delete для имени переменной</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Using eval or arguments as variable or function argument name</div>
                        <div class="ruJSTheory">Использование eval или аргументов в качестве имени аргумента
                            переменной
                            или
                            функции
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">When you use newly reserved keywords</div>
                        <div class="ruJSTheory">Когда вы используете новые зарезервированные ключевые слова</div>
                    </li>
                    <li>
                        <div class="engJSTheory">When you declare a function in a block</div>
                        <div class="ruJSTheory">Когда вы объявляете функцию в блоке</div>
                        <pre>
                            if (someCondition) {
                                function f() {}
                            }
                        </pre>
                    </li>
                </ol>
                <p class="engJSTheory">Hence, the errors from above cases are helpful to avoid errors in
                    development/production environments.</p>
                <p class="ruJSTheory">Следовательно, ошибки из приведенных выше случаев помогают избежать ошибок в
                    средах
                    разработки/производства.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment340">
            <div class="engJSTheory">Do all objects have prototypes</div>
            <div class="ruJSTheory">У всех ли объектов есть прототипы?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">No. All objects have prototypes except for the base object which is created
                    by
                    the
                    user, or an object
                    that is created using the new keyword.</p>
                <p class="ruJSTheory">Нет. У всех объектов есть прототипы, за исключением базового объекта,
                    созданного
                    пользователем, или
                    объекта, созданного с использованием ключевого слова new.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment341">
            <div class="engJSTheory">What is the difference between a parameter and an argument</div>
            <div class="ruJSTheory">В чем разница между параметром и аргументом</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Parameter is the variable name of a function definition whereas an argument
                    represents the value given to
                    a function when it is invoked. Let's explain this with a simple function:</p>
                <p class="ruJSTheory">Параметр — это имя переменной определения функции, тогда как аргумент
                    представляет
                    значение, данное
                    функции при ее вызове. Давайте объясним это с помощью простой функции:</p>

                <pre>
                    function myFunction(parameter1, parameter2, parameter3) {
                        console.log(arguments[0]); // "argument1"
                        console.log(arguments[1]); // "argument2"
                        console.log(arguments[2]); // "argument3"
                    }
                    myFunction("argument1", "argument2", "argument3");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment342">
            <div class="engJSTheory">What is the purpose of some() method in arrays</div>
            <div class="ruJSTheory">Какова цель метода some() в массивах</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The some() method is used to test whether at least one element in the array
                    passes
                    the test implemented
                    by the provided function. The method returns a boolean value. Let's take an example to test for
                    any
                    odd
                    elements:</p>
                <p class="ruJSTheory">Метод some() используется для проверки того, проходит ли хотя бы один элемент
                    массива
                    тест, реализованный
                    предоставленной функцией. Метод возвращает логическое значение. Давайте возьмем пример для
                    проверки
                    любых нечетных элементов:</p>

                <pre>
                    const array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];

                    const odd = (element) => element % 2 !== 0;

                    console.log(array.some(odd)); // true (the odd element exists)
                    // console.log(array.some(el => el % 2 !== 0))
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment343">
            <div class="engJSTheory">How do you combine two or more arrays</div>
            <div class="ruJSTheory">Как объединить два или более массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The concat() method is used to join two or more arrays by returning a new
                    array
                    containing all the
                    elements. The syntax would be as below:</p>
                <p class="ruJSTheory">Метод concat() используется для объединения двух или более массивов путем
                    возврата
                    нового массива,
                    содержащего все элементы. Синтаксис будет таким, как показано ниже:</p>

                <pre>
                    array1.concat(array2, array3, ..., arrayX)
                </pre>

                <p class="engJSTheory">Let's take an example of array's concatenation with veggies and fruits
                    arrays:</p>
                <p class="ruJSTheory">Давайте рассмотрим пример объединения массива с массивами овощей и
                    фруктов:</p>

                <pre>
                    const veggies = ["Tomato", "Carrot", "Cabbage"];
                    const fruits = ["Apple", "Orange", "Pears"];
                    const veggiesAndFruits = veggies.concat(fruits);
                    console.log(veggiesAndFruits); // Tomato, Carrot, Cabbage, Apple, Orange, Pears
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment344">
            <div class="engJSTheory">What is the difference between Shallow and Deep copy</div>
            <div class="ruJSTheory">В чем разница между поверхностной и глубокой копией</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are two ways to copy an object:</p>
                <p class="ruJSTheory">Есть два способа скопировать объект:</p>
                <p class="engJSTheory">Shallow Copy: Shallow copy is a bitwise copy of an object. A new object is
                    created
                    that has an exact copy
                    of the values in the original object. If any of the fields of the object are references to other
                    objects, just the reference addresses are copied i.e., only the memory address is copied.
                    Example:</p>
                <p class="ruJSTheory">Неглубокая копия: Неглубокая копия — это побитовая копия объекта. Создается
                    новый
                    объект, имеющий точную
                    копию значений исходного объекта. Если какое-либо из полей объекта является ссылкой на другие
                    объекты,
                    копируются только адреса ссылок, т. е. копируется только адрес памяти. Пример:</p>

                <pre>
                    const empDetails = {
                        name: "John",
                        age: 25,
                        expertise: "Software Developer",
                    };

                    // to create a duplicate

                    const empDetailsShallowCopy = empDetails; //Shallow copying!
                </pre>

                <p class="engJSTheory">if we change some property value in the duplicate one like this:</p>
                <p class="ruJSTheory">если мы изменим какое-либо значение свойства в дубликате следующим
                    образом:</p>

                <pre>
                    empDetailsShallowCopy.name = "Johnson";
                </pre>

                <p class="engJSTheory">The above statement will also change the name of empDetails, since we have a
                    shallow
                    copy. That means
                    we're losing the original data as well.</p>
                <p class="ruJSTheory">Приведенный выше оператор также изменит имя empDetails, поскольку у нас есть
                    неполная
                    копия. Это
                    означает, что мы также теряем исходные данные.</p>
                <p class="engJSTheory">Deep copy: A deep copy copies all fields, and makes copies of dynamically
                    allocated
                    memory pointed to by
                    the fields. A deep copy occurs when an object is copied along with the objects to which it
                    refers.
                    Example:</p>
                <p class="ruJSTheory">Глубокое копирование: При глубоком копировании копируются все поля и создаются
                    копии
                    динамически
                    выделяемой памяти, на которую указывают поля. Глубокое копирование происходит, когда объект
                    копируется
                    вместе с объектами, на которые он ссылается. Пример:</p>

                <pre>
                    const empDetails = {
                        name: "John",
                        age: 25,
                        expertise: "Software Developer",
                    };

                    //Create a deep copy by using the properties from the original object into new variable

                    const empDetailsDeepCopy = {
                        name: empDetails.name,
                        age: empDetails.age,
                        expertise: empDetails.expertise,
                    };
                </pre>

                <p class="engJSTheory">Now if you change empDetailsDeepCopy.name, it will only affect
                    empDetailsDeepCopy
                    &
                    not empDetails</p>
                <p class="ruJSTheory">Теперь, если вы измените empDetailsDeepCopy.name, это повлияет только на
                    empDetailsDeepCopy, а не на empDetails.</p>
                <p>Так же существует метод <a
                        href="https://learn.javascript.ru/object-copy?ysclid=lp5qqx56pd185065270"
                        target="_blank">Object.assign(dest, [src1, src2, src3...])</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment345">
            <div class="engJSTheory">How do you create specific number of copies of a string</div>
            <div class="ruJSTheory">Как создать определенное количество копий строки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The repeat() method is used to construct and return a new string which
                    contains
                    the
                    specified number of
                    copies of the string on which it was called, concatenated together. Remember that this method
                    has
                    been
                    added to the ECMAScript 2015 specification. Let's take an example of Hello string to repeat it 4
                    times:</p>
                <p class="ruJSTheory">Метод repeat() используется для создания и возврата новой строки, содержащей
                    указанное
                    количество
                    копий строки, из которой он был вызван, объединенных вместе. Помните, что этот метод был
                    добавлен в
                    спецификацию ECMAScript 2015. Давайте возьмем пример строки Hello и повторим ее 4 раза:</p>

                <pre>
                    "Hello".repeat(4); // 'HelloHelloHelloHello'
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment346">
            <div class="engJSTheory">How do you return all matching strings against a regular expression</div>
            <div class="ruJSTheory">Как вернуть все совпадающие строки по регулярному выражению</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The matchAll() method can be used to return an iterator of all results
                    matching a
                    string against a
                    regular expression. For example, the below example returns an array of matching string results
                    against a
                    regular expression:</p>
                <p class="ruJSTheory">Метод matchAll() можно использовать для возврата итератора всех результатов,
                    соответствующих строке
                    регулярному выражению. Например, приведенный ниже пример возвращает массив совпадающих строковых
                    результатов по регулярному выражению:</p>

                <pre>
                    let regexp = /Hello(\d?))/g;
                    let greeting = "Hello1Hello2Hello3";

                    let greetingList = [...greeting.matchAll(regexp)];

                    console.log(greetingList[0]); //Hello1
                    console.log(greetingList[1]); //Hello2
                    console.log(greetingList[2]); //Hello3
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment347">
            <div class="engJSTheory">How do you trim a string at the beginning or ending</div>
            <div class="ruJSTheory">Как обрезать строку в начале или конце?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The trim method of string prototype is used to trim on both sides of a
                    string.
                    But if
                    you want to trim
                    especially at the beginning or ending of the string then you can use trimStart/trimLeft and
                    trimEnd/trimRight methods. Let's see an example of these methods on a greeting message:</p>
                <p class="ruJSTheory">Метод trim() прототипа строки используется для обрезки строки с обеих сторон.
                    Но
                    если
                    вы хотите обрезать
                    особенно начало или конец строки, вы можете использовать методы TrimStart/trimLeft и
                    TrimEnd/TrimRight.
                    Давайте посмотрим пример этих методов в приветственном сообщении:</p>

                <pre>
                    let greeting = " Hello, Goodmorning! ";

                    console.log(greeting); // " Hello, Goodmorning! "
                    console.log(greeting.trimStart()); // "Hello, Goodmorning! "
                    console.log(greeting.trimLeft()); // "Hello, Goodmorning! "

                    console.log(greeting.trimEnd()); // "   Hello, Goodmorning!"
                    console.log(greeting.trimRight()); // "   Hello, Goodmorning!"

                    console.log(greeting.trim()); // "Hello, Goodmorning!"
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment348">
            <div class="engJSTheory">What is the output of below console statement with unary operator</div>
            <div class="ruJSTheory">Каков вывод приведенного ниже оператора консоли с унарным оператором?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Let's take console statement with unary operator as given below:</p>
                <p class="ruJSTheory">Давайте возьмем оператор консоли с унарным оператором, как показано ниже:</p>

                <pre>
                    console.log(+"Hello");
                </pre>

                <p class="engJSTheory">The output of the above console log statement returns NaN. Because the
                    element is
                    prefixed by the unary
                    operator and the JavaScript interpreter will try to convert that element into a number type.
                    Since
                    the
                    conversion fails, the value of the statement results in NaN value.</p>
                <p class="ruJSTheory">Вывод приведенного выше оператора журнала консоли возвращает NaN. Поскольку
                    элемент
                    имеет префикс
                    унарного оператора, и интерпретатор JavaScript попытается преобразовать этот элемент в числовой
                    тип.
                    Поскольку преобразование завершается неудачей, значение оператора приводит к значению NaN.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment349">
            <div class="engJSTheory">Does javascript uses mixins</div>
            <div class="ruJSTheory">Использует ли JavaScript миксины(примеси)?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Mixin is a generic object-oriented programming term - is a class containing
                    methods
                    that can be used by
                    other classes without a need to inherit from it. In JavaScript we can only inherit from a single
                    object.
                    ie. There can be only one [[prototype]] for an object.</p>
                <p class="ruJSTheory">Mixin — это общий термин объектно-ориентированного программирования — это
                    класс,
                    содержащий методы,
                    которые могут использоваться другими классами без необходимости наследования от него. В
                    JavaScript
                    мы
                    можем наследовать только один объект. то есть. У объекта может быть только один
                    [[прототип]].</p>
                <p class="engJSTheory">But sometimes we require to extend more than one, to overcome this we can use
                    Mixin
                    which helps to copy
                    methods to the prototype of another class.</p>
                <p class="ruJSTheory">Но иногда нам требуется расширить более одного класса. Чтобы решить эту
                    проблему,
                    мы
                    можем использовать
                    Mixin, который помогает скопировать методы в прототип другого класса.</p>
                <p class="engJSTheory">Say for instance, we've two classes User and CleanRoom. Suppose we need to
                    add
                    CleanRoom functionality to
                    User, so that user can clean the room at demand. Here's where concept called mixins comes into
                    picture.</p>
                <p class="ruJSTheory">Скажем, у нас есть два класса User и CleanRoom. Предположим, нам нужно
                    добавить
                    функциональность
                    CleanRoom в User, чтобы пользователь мог убирать комнату по требованию. Вот тут-то и появляется
                    концепция миксинов.</p>

                <pre>
                    // mixin
                    let cleanRoomMixin = {
                        cleanRoom() {
                            alert(`Hello ${this.name}, your room is clean now`);
                        },
                        sayBye() {
                            alert(`Bye ${this.name}`);
                        },
                    };

                    // usage:
                    class User {
                        constructor(name) {
                          this.name = name;
                        }
                    }

                    // copy the methods
                    Object.assign(User.prototype, cleanRoomMixin);

                    // now User can clean the room
                    new User("Dude").cleanRoom(); // Hello Dude, your room is clean now!
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment350">
            <div class="engJSTheory">What is a thunk function</div>
            <div class="ruJSTheory">Что такое функция thunk</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A thunk is just a function which delays the evaluation of the value. It
                    doesn’t
                    take
                    any arguments but
                    gives the value whenever you invoke the thunk. i.e, It is used not to execute now but it will be
                    sometime in the future. Let's take a synchronous example:</p>
                <p class="ruJSTheory">Thunk — это просто функция, которая задерживает вычисление значения. Он не
                    принимает
                    никаких аргументов,
                    но возвращает значение всякий раз, когда вы вызываете thunk. т. е. он используется не для
                    выполнения сейчас, а для выполнения когда-нибудь в будущем. Возьмем синхронный пример:</p>

                <pre>
                    const add = (x, y) => x + y;

                    const thunk = () => add(2, 3);

                    thunk(); // 5
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment351">
            <div class="engJSTheory">What are asynchronous thunks</div>
            <div class="ruJSTheory">Что такое асинхронный thunk</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The asynchronous thunks are useful to make network requests. Let's see an
                    example
                    of
                    network requests:</p>
                <p class="ruJSTheory">Асинхронный thunk полезен для выполнения сетевых запросов. Давайте посмотрим
                    пример
                    сетевых запросов:</p>

                <pre>
                    function fetchData(fn) {
                        fetch("https://jsonplaceholder.typicode.com/todos/1")
                          .then((response) => response.json())
                          .then((json) => fn(json));
                    }

                    const asyncThunk = function () {
                        return fetchData(function getData(data) {
                          console.log(data);
                        });
                    };

                    asyncThunk();
                </pre>

                <p class="engJSTheory">The getData function won't be called immediately but it will be invoked only
                    when
                    the
                    data is available
                    from API endpoint. The setTimeout function is also used to make our code asynchronous. The best
                    real
                    time example is redux state management library which uses the asynchronous thunks to delay the
                    actions
                    to dispatch.</p>
                <p class="ruJSTheory">Функция getData не будет вызываться немедленно, а будет вызвана только тогда,
                    когда
                    данные станут
                    доступны из конечной точки API. Функция setTimeout также используется для асинхронности нашего
                    кода.
                    Лучшим примером реального времени является библиотека управления состоянием Redux, которая
                    использует
                    asyncThunk для задержки отправки действий.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment352">
            <div class="engJSTheory">What is the output of below function calls</div>
            <div class="ruJSTheory">Каков результат следующих вызовов функций?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Code snippet:</p>
                <p class="ruJSTheory">Фрагмент кода:</p>

                <pre>
                    const circle = {
                        radius: 20,
                        diameter() {
                          return this.radius * 2;
                        },
                        perimeter: () => 2 * Math.PI * this.radius,
                    };

                    console.log(circle.diameter());
                    console.log(circle.perimeter());
                </pre>

                <p class="engJSTheory">Output:</p>
                <p class="ruJSTheory">Вывод:</p>
                <p class="engJSTheory">The output is 40 and NaN. Remember that diameter is a regular function,
                    whereas
                    the
                    value of perimeter is
                    an arrow function. The this keyword of a regular function(i.e, diameter) refers to the
                    surrounding
                    scope
                    which is a class(i.e, circle object). Whereas this keyword of perimeter function refers to the
                    surrounding scope which is a window object. Since there is no radius property on window objects
                    it
                    returns an undefined value and the multiple of number value returns NaN value.</p>
                <p class="ruJSTheory">Вывод — 40 и NaN. Помните, что diameter — это регулярная функция, тогда как
                    значение
                    perimeter —
                    стрелочная функция. Ключевое слово this обычной функции (т. е. diameter) относится к окружающей
                    области,
                    которая является классом (т. е. объектом circle). Принимая во внимание, что это ключевое слово
                    функции
                    perimeter относится к окружающей области, которая является объектом window. Поскольку у объекта
                    window
                    нет свойства радиуса, оно возвращает undefined значение, а значение, кратное числу, возвращает
                    значение NaN.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment353">
            <div class="engJSTheory">How to remove all line breaks from a string</div>
            <div class="ruJSTheory">Как удалить все разрывы строк из строки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The easiest approach is using regular expressions to detect and replace
                    newlines
                    in
                    the string. In this
                    case, we use replace function along with string to replace with, which in our case is an empty
                    string:</p>
                <p class="ruJSTheory">Самый простой подход — использовать регулярные выражения для обнаружения и
                    замены
                    символов новой строки в
                    строке. В этом случае мы используем функцию replace вместе со строкой для замены, которая в
                    нашем
                    случае
                    является пустой строкой.</p>

                <pre>
                    function remove_linebreaks( var message ) {
                        return message.replace( /[\r\n]+/gm, "" );
                    }
                </pre>

                <p class="engJSTheory">In the above expression, g and m are for global and multiline flags.</p>
                <p class="ruJSTheory">В приведенном выше выражении g и m относятся к глобальным и многострочным
                    флагам.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment354">
            <div class="engJSTheory">What is the difference between reflow and repaint</div>
            <div class="ruJSTheory">В чем разница между reflow и repaint</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A repaint occurs when changes are made which affect the visibility of an
                    element,
                    but
                    not its layout.
                    Examples of this include outline, visibility, or background color. A reflow involves changes
                    that
                    affect
                    the layout of a portion of the page (or the whole page). Resizing the browser window, changing
                    the
                    font,
                    content changing (such as user typing text), using JavaScript methods involving computed styles,
                    adding
                    or removing elements from the DOM, and changing an element's classes are a few of the things
                    that
                    can
                    trigger reflow. Reflow of an element causes the subsequent reflow of all child and ancestor
                    elements
                    as
                    well as any elements following it in the DOM.</p>
                <p class="ruJSTheory">Перерисовка(repaint) происходит, когда вносятся изменения, которые влияют на
                    видимость
                    элемента, но не на его
                    макет. Примеры этого включают контур, видимость или цвет фона. Перекомпоновка(reflow) включает в
                    себя
                    изменения,
                    которые влияют на макет части страницы (или всей страницы). Изменение размера окна браузера,
                    изменение
                    шрифта, изменение содержимого (например, ввод текста пользователем), использование методов
                    JavaScript,
                    включающих вычисляемые стили, добавление или удаление элементов из DOM и изменение классов
                    элементов
                    —
                    вот лишь некоторые из вещей, которые могут вызвать перекомпоновку. Перекомпоновка(reflow)
                    элемента
                    вызывает
                    последующую перекомпоновку всех дочерних и родительских элементов, а также любых элементов,
                    следующих за
                    ним в DOM.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment355">
            <div class="engJSTheory">What happens with negating an array</div>
            <div class="ruJSTheory">Что происходит при отрицании(!) массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Negating an array with ! character will coerce the array into a boolean.
                    Since
                    Arrays
                    are considered to be truthy So negating it will return false.</p>
                <p class="ruJSTheory">Отрицание массива с помощью ! символ преобразует массив в логическое значение.
                    Поскольку массивы считаются правдивыми, отрицание возвращает false.</p>

                <pre>
                    console.log(![]); // false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment356">
            <div class="engJSTheory">What happens if we add two arrays</div>
            <div class="ruJSTheory">Что произойдет, если мы добавим два массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you add two arrays together, it will convert them both to strings and
                    concatenate
                    them. For example, the result of adding arrays would be as below:</p>
                <p class="ruJSTheory">Если вы добавите два массива вместе, они преобразуются в строки и объединятся.
                    Например, результат добавления массивов будет таким, как показано ниже:</p>

                <pre>
                    console.log(["a"] + ["b"]); // "ab"
                    console.log([] + []); // ""
                    console.log(![] + []); // "false", because ![] returns false.
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment357">
            <div class="engJSTheory">What is the output of prepend additive operator on falsy values</div>
            <div class="ruJSTheory">Каков результат операции добавления аддитивного оператора(+) к ложным значениям?
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you prepend the additive(+) operator on falsy values(null, undefined, NaN,
                    false,
                    ""), the falsy value
                    converts to a number value zero. Let's display them on browser console as below:</p>
                <p class="ruJSTheory">Если вы добавляете оператор добавления (+) к ложным значениям (нуль,
                    undefined,
                    NaN,
                    false, ""),
                    ложное значение преобразуется в нулевое числовое значение. Давайте отобразим их в консоли
                    браузера,
                    как
                    показано ниже:</p>

                <pre>
                    console.log(+null); // 0
                    console.log(+undefined); // NaN
                    console.log(+false); // 0
                    console.log(+NaN); // NaN
                    console.log(+""); // 0
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment358">
            <div class="engJSTheory">How do you create self string using special characters</div>
            <div class="ruJSTheory">Как создать собственную строку, используя специальные символы</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The self string can be formed with the combination of []()!+ characters. You
                    need
                    to
                    remember the below
                    conventions to achieve this pattern:</p>
                <p class="ruJSTheory">Собственная строка может быть сформирована из комбинации символов []()!+.
                    Чтобы
                    достичь этого шаблона,
                    вам необходимо запомнить следующие паттерны:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Since Arrays are truthful values, negating the arrays will produce
                            false:
                            ![] === false
                        </div>
                        <div class="ruJSTheory">Поскольку массивы являются истинными значениями, отрицание массивов
                            приведет
                            к ложному
                            результату: ![] === false
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">As per JavaScript coercion rules, the addition of arrays together
                            will
                            toString them: [] + []
                            === ""
                        </div>
                        <div class="ruJSTheory">Согласно правилам приведения JavaScript, сложение массивов приведет
                            к их
                            типу string: [] + []
                            === ""
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Prepend an array with + operator will convert an array to false,
                            the
                            negation will make it true
                            and finally converting the result will produce value '1': +(!(+[])) === 1
                        </div>
                        <div class="ruJSTheory">Добавление массива в начало с помощью оператора + преобразует массив
                            в
                            false, отрицание сделает
                            его истинным, и, наконец, преобразование результата даст значение '1': +(!(+[])) === 1
                        </div>
                    </li>
                </ol>

                <p class="engJSTheory">By applying the above rules, we can derive below conditions:</p>
                <p class="ruJSTheory">Применяя приведенные выше правила, мы можем получить следующие условия:</p>

                <pre>
                    (![] + [] === "false" + !+[]) === 1;
                </pre>

                <p class="engJSTheory">Now the character pattern would be created as below:</p>
                <p class="ruJSTheory">Теперь образец символа будет создан, как показано ниже:</p>

                <pre>
                          s               e               l               f
                    ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^

                    (![] + [])[3] + (![] + [])[4] + (![] + [])[2] + (![] + [])[0]
                    ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^   ^^^^^^^^^^^^^
                    (![] + [])[+!+[]+!+[]+!+[]] +
                    (![] + [])[+!+[]+!+[]+!+[]+!+[]] +
                    (![] + [])[+!+[]+!+[]] +
                    (![] + [])[+[]]
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

                    (![]+[])[+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]+!+[]+!+[]]+(![]+[])[+!+[]+!+[]]+(![]+[])[+[]]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment359">
            <div class="engJSTheory">How do you remove falsy values from an array</div>
            <div class="ruJSTheory">Как удалить ложные значения из массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can apply the filter method on the array by passing Boolean as a
                    parameter.
                    This
                    way it removes all falsy values(0, undefined, null, false and "") from the array:</p>
                <p class="ruJSTheory">Вы можете применить метод filter() к массиву, передав логическое значение в
                    качестве
                    параметра. Таким образом, он удаляет из массива все ложные значения (0, undefined, null, false и
                    ""):</p>

                <pre>
                    const myArray = [false, null, 1, 5, undefined];
                    myArray.filter(Boolean); // [1, 5] // is same as myArray.filter(x => x);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment360">
            <div class="engJSTheory">How do you get unique values of an array</div>
            <div class="ruJSTheory">Как получить уникальные значения массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can get unique values of an array with the combination of Set and rest
                    expression/spread (...) syntax.</p>
                <p class="ruJSTheory">Вы можете получить уникальные значения массива с помощью комбинации синтаксиса
                    Set
                    и
                    rest/spread выражения (...).</p>

                <pre>
                    console.log([...new Set([1, 2, 4, 4, 3])]); // [1, 2, 4, 3]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment361">
            <div class="engJSTheory">What is destructuring aliases</div>
            <div class="ruJSTheory">Что такое деструктуризация псевдонимов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Sometimes you would like to have a destructured variable with a different
                    name
                    than
                    the property name. In
                    that case, you'll use a : newName to specify a name for the variable. This process is called
                    destructuring aliases.</p>
                <p class="ruJSTheory">Иногда вам может понадобиться деструктурированная переменная с именем,
                    отличным от
                    имени свойства. В этом
                    случае вы будете использовать "value : newName", чтобы указать имя переменной. Этот процесс
                    называется
                    деструктуризацией псевдонимов.</p>

                <pre>
                    const obj = { x: 1 };
                    // Grabs obj.x as { otherName }
                    const { x: otherName } = obj;
                    console.log(otherName) // 1
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment362">
            <div class="engJSTheory">How do you map the array values without using map method</div>
            <div class="ruJSTheory">Напишите полифил метода map для массивов(Как мэппизировать значения массива без
                использования map метода)
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can map the array values without using the map method by just using the
                    from
                    method of Array. Let's
                    map city names from Countries array:</p>
                <p class="ruJSTheory">Вы можете сопоставить(мэппизировать) значения массива без использования метода
                    map,
                    просто используя
                    метод Array.from(). Давайте сопоставим названия городов из массива Countries:</p>

                <pre>
                    const countries = [
                        { name: "India", capital: "Delhi" },
                        { name: "US", capital: "Washington" },
                        { name: "Russia", capital: "Moscow" },
                        { name: "Singapore", capital: "Singapore" },
                        { name: "China", capital: "Beijing" },
                        { name: "France", capital: "Paris" },
                    ];

                    const cityNames = Array.from(countries, ({ capital }) => capital);
                    console.log(cityNames); // ['Delhi, 'Washington', 'Moscow', 'Singapore', 'Beijing', 'Paris']
                </pre>

                <p>Подробнее про Array.from() можно почитать на <a
                        href="https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/from"
                        target="_blank">MDN</a>
                </p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment363">
            <div class="engJSTheory">How do you empty an array</div>
            <div class="ruJSTheory">Как очистить массив</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can empty an array quickly by setting the array length to zero:</p>
                <p class="ruJSTheory">Вы можете быстро очистить массив, установив длину массива равной нулю.</p>

                <pre>
                    let cities = ["Singapore", "Delhi", "London"];
                    cities.length = 0; // cities becomes []
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment364">
            <div class="engJSTheory">How do you rounding numbers to certain decimals</div>
            <div class="ruJSTheory">Как округлить числа до определенных десятичных знаков?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can round numbers to a certain number of decimals using toFixed method
                    from
                    native javascript:</p>
                <p class="ruJSTheory">Вы можете округлять числа до определенного количества десятичных знаков,
                    используя
                    метод toFixed из встроенного JavaScript.</p>

                <pre>
                    let pie = 3.141592653;
                    pie = pie.toFixed(3); // 3.142
                </pre>

                <p>Math.round() округляет до ближайшего ЦЕЛОГО числа!!!</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment365">
            <div class="engJSTheory">What is the easiest way to convert an array to an object</div>
            <div class="ruJSTheory">Как проще всего преобразовать массив в объект?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can convert an array to an object with the same data using spread(...)
                    operator.</p>
                <p class="ruJSTheory">Вы можете преобразовать массив в объект с теми же данными, используя оператор
                    spread(...).</p>

                <pre>
                    let  fruits = ["banana", "apple", "orange", "watermelon"];
                    let fruitsObject = { ...fruits };
                    console.log(fruitsObject); // {0: "banana", 1: "apple", 2: "orange", 3: "watermelon"}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment366">
            <div class="engJSTheory">How do you create an array with some data</div>
            <div class="ruJSTheory">Как создать массив с данными</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can create an array with some data or an array with the same values using
                    fill
                    method.</p>
                <p class="ruJSTheory">Вы можете создать массив с данными или массив с теми же значениями, используя
                    метод
                    fill.</p>

                <pre>
                    let newArray = new Array(5).fill("0");
                    console.log(newArray); // ["0", "0", "0", "0", "0"]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment367">
            <div class="engJSTheory">What are the placeholders from console object</div>
            <div class="ruJSTheory">Что такое заполнители(placeholders) из объекта console</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of placeholders available from console object:</p>
                <p class="ruJSTheory">Ниже приведен список заполнителей(placeholders), доступных из объекта
                    console.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">%o — It takes an object</div>
                        <div class="ruJSTheory">%o — принимает объект</div>
                    </li>
                    <li>
                        <div class="engJSTheory">%s — It takes a string</div>
                        <div class="ruJSTheory">%s — принимает строку</div>
                    </li>
                    <li>
                        <div class="engJSTheory">%d — It is used for a decimal or integer These placeholders can be
                            represented in the console.log as below
                        </div>
                        <div class="ruJSTheory">%d — используется для десятичных или целых чисел. Эти заполнители
                            могут
                            быть
                            представлены в console.log, как показано ниже.
                        </div>
                        <pre>
                            const user = { name: "John", id: 1, city: "Delhi" };
                            console.log(
                                "Hello %s, your details %o are available in the object form",
                                "John",
                                user
                            ); // Hello John, your details {name: "John", id: 1, city: "Delhi"} are available in object
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment368">
            <div class="engJSTheory">Is it possible to add CSS to console messages</div>
            <div class="ruJSTheory">Можно ли добавить CSS в сообщения консоли?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, you can apply CSS styles to console messages similar to html text on the
                    web
                    page.</p>
                <p class="ruJSTheory">Да, вы можете применять стили CSS к сообщениям консоли, похожим на текст HTML
                    на
                    веб-странице.</p>

                <pre>
                    console.log(
                        "%c The text has blue color, with large font and red background",
                        "color: blue; font-size: x-large; background: red"
                    );
                </pre>

                <p class="engJSTheory">The text will be displayed as below:</p>
                <p class="ruJSTheory">Текст будет отображаться, как показано ниже:</p>

                <img src="./images/console-css.png" alt="console-css" width="644">

                <p class="engJSTheory">Note: All CSS styles can be applied to console messages.</p>
                <p class="ruJSTheory">Примечание: К сообщениям консоли можно применять все стили CSS.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment369">
            <div class="engJSTheory">What is the purpose of dir method of console object</div>
            <div class="ruJSTheory">Какова цель метода dir объекта console</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The console.dir() is used to display an interactive list of the properties of
                    the
                    specified JavaScript object as JSON.</p>
                <p class="ruJSTheory">console.dir() используется для отображения интерактивного списка свойств
                    указанного
                    объекта JavaScript в формате JSON.</p>

                <pre>
                    const user = { name: "John", id: 1, city: "Delhi" };
                    console.dir(user);
                </pre>

                <p class="engJSTheory">The user object displayed in JSON representation:</p>
                <p class="ruJSTheory">Объект user, отображаемый в представлении JSON:</p>

                <img src="./images/console-dir.png" alt="console-dir" width="644">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment370">
            <div class="engJSTheory">Is it possible to debug HTML elements in console</div>
            <div class="ruJSTheory">Можно ли отлаживать HTML-элементы в консоли?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Yes, it is possible to get and debug HTML elements in the console just like
                    inspecting elements.</p>
                <p class="ruJSTheory">Да, HTML-элементы можно получать и отлаживать в консоли точно так же, как и
                    при
                    проверке элементов.</p>

                <pre>
                    const element = document.getElementsByTagName("body")[0];
                    console.log(element);
                </pre>

                <p class="engJSTheory">It prints the HTML element in the console:</p>
                <p class="ruJSTheory">Элемент HTML печатается в консоли:</p>

                <img src="./images/console-html.png" alt="console-html" width="644">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment371">
            <div class="engJSTheory">How do you display data in a tabular format using console object</div>
            <div class="ruJSTheory">Как отображать данные в табличном формате с помощью объекта console?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The console.table() is used to display data in the console in a tabular
                    format to
                    visualize complex arrays or objects:</p>
                <p class="ruJSTheory">console.table() используется для отображения данных в консоли в табличном
                    формате
                    для
                    визуализации сложных массивов или объектов:</p>

                <pre>
                    const users = [
                        { name: "John", id: 1, city: "Delhi" },
                        { name: "Max", id: 2, city: "London" },
                        { name: "Rod", id: 3, city: "Paris" },
                    ];
                    console.table(users);
                </pre>

                <p class="engJSTheory">The data visualized in a table format:</p>
                <p class="ruJSTheory">Данные визуализируются в виде таблицы:</p>

                <img src="./images/console-table.png" alt="console-table" width="644">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment372">
            <div class="engJSTheory">How do you verify that an argument is a Number or not</div>
            <div class="ruJSTheory">Как проверить, является ли аргумент числом или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The combination of IsNaN and isFinite methods are used to confirm whether an
                    argument
                    is a number or not.</p>
                <p class="ruJSTheory">Комбинация методов IsNaN и isFinite используется для подтверждения того,
                    является
                    ли
                    аргумент числом или нет.</p>

                <pre>
                    function isNumber(n) {
                        return !isNaN(parseFloat(n)) && isFinite(n);
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment373">
            <div class="engJSTheory">How do you create copy to clipboard button</div>
            <div class="ruJSTheory">Как создать кнопку "Копировать в буфер обмена"</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You need to select the content(using .select() method) of the input element
                    and
                    execute the copy command
                    with execCommand (i.e, execCommand('copy')). You can also execute other system commands like cut
                    and
                    paste:</p>
                <p class="ruJSTheory">Вам необходимо выбрать содержимое (с помощью метода .select()) входного
                    элемента и
                    выполнить команду
                    копирования с помощью execCommand (т. е. execCommand('copy')). Вы также можете выполнять другие
                    системные команды, такие как cut и paste:</p>
                <p>DEPRECATED!!!</p>
                <pre>
                    document.querySelector("#copy-button").onclick = function () {
                        // Select the content
                        document.querySelector("#copy-input").select();
                        // Copy to the clipboard
                        document.execCommand("copy");
                    };
                </pre>

                <p>Подробнее об execCommand можно почитать на <a
                        href="https://developer.mozilla.org/ru/docs/Web/API/Document/execCommand"
                        target="_blank">MDN</a>
                </p>
                <p>На данный момент существует "navigator.clipboard.writeText(someText).then()"</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment374">
            <div class="engJSTheory">What is the shortcut to get timestamp</div>
            <div class="ruJSTheory">Какой ярлык позволяет получить текущую дату</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use new Date().getTime() to get the current timestamp. There is an
                    alternative shortcut to get
                    the value.</p>
                <p class="ruJSTheory">Вы можете использовать new Date().getTime(), чтобы получить текущую дату.
                    Существует
                    альтернативный способ получить значение.</p>

                <pre>
                    console.log(+new Date());
                    console.log(Date.now());
                </pre>
            </div>
        </section>


        <h3 id="JSbasicsForEmployment375">
            <div class="engJSTheory">How do you flattening multi dimensional arrays</div>
            <div class="ruJSTheory">Как вы выравниваете многомерные массивы?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Flattening bi-dimensional arrays is trivial with Spread operator.</p>
                <p class="ruJSTheory">Сглаживание двумерных массивов с помощью оператора Spread выполняется
                    тривиально.</p>

                <pre>
                    const biDimensionalArr = [11, [22, 33], [44, 55], [66, 77], 88, 99];
                    const flattenArr = [].concat(...biDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
                </pre>

                <p class="engJSTheory">But you can make it work with multi-dimensional arrays by recursive
                    calls:</p>
                <p class="ruJSTheory">Но вы можете конвертировать многомерные массивы с помощью рекурсивных
                    вызовов:</p>

                <pre>
                    function flattenMultiArray(arr) {
                        const flattened = [].concat(...arr);
                        return flattened.some((item) => Array.isArray(item))
                           ? flattenMultiArray(flattened)
                           : flattened;
                    }
                    const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
                    const flatArr = flattenMultiArray(multiDimensionalArr); // [11, 22, 33, 44, 55, 66, 77, 88, 99]

                        //или так
                        function flatFunc(arr) {
                            let flattedArr = [];
                            arr.forEach(item => {
                                if (Array.isArray(item)) {
                                    flattedArr = flattedArr.concat(flatFunc(item));
                                } else {
                                    flattedArr.push(item);
                                }
                            })
                            return flattedArr;
                        }
                </pre>

                <p class="engJSTheory">Also you can use the flat method of Array:</p>
                <p class="ruJSTheory">Также вы можете использовать метод Array.flat():</p>

                <pre>
                    const arr = [1, [2, 3], 4, 5, [6, 7]];
                    const fllattenArr = arr.flat(); // [1, 2, 3, 4, 5, 6, 7]

                    // And for multiDemensional arrays
                    const multiDimensionalArr = [11, [22, 33], [44, [55, 66, [77, [88]], 99]]];
                    const oneStepFlat = multiDimensionalArr.flat(1); // [11, 22, 33, 44, [55, 66, [77, [88]], 99]]
                    const towStep = multiDimensionalArr.flat(2); // [11, 22, 33, 44, 55, 66, [77, [88]], 99]
                    const fullyFlatArray = multiDimensionalArr.flat(Infinity); // [11, 22, 33, 44, 55, 66, 77, 88, 99]
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment376">
            <div class="engJSTheory">What is the easiest multi condition checking</div>
            <div class="ruJSTheory">Какая самая простая проверка нескольких условий?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use indexOf to compare input with multiple values instead of checking
                    each
                    value as one
                    condition:</p>
                <p class="ruJSTheory">Вы можете использовать indexOf для сравнения входных данных с несколькими
                    значениями
                    вместо проверки
                    каждого значения как одного условия.</p>

                <pre>
                    // Verbose approach
                    if (
                        input === "first" ||
                        input === 1 ||
                        input === "second" ||
                        input === 2
                    ) {
                        someFunction();
                    }

                    // Shortcut
                    if (["first", 1, "second", 2].indexOf(input) !== -1) {
                        someFunction();
                    }
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment377">
            <div class="engJSTheory">How do you capture browser back button</div>
            <div class="ruJSTheory">Как активировать кнопку возврата браузера(не щелкая по ней в самом браузере)
            </div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The beforeunload event is triggered when the window, the document and its
                    resources
                    are about to be
                    unloaded. This event is helpful to warn users about losing the current data and detect back
                    button
                    event.</p>
                <p class="ruJSTheory">Событие beforeunload срабатывает, когда window, document и его ресурсы
                    собираются
                    выгрузиться. Это
                    событие
                    полезно для предупреждения пользователей о потере текущих данных и обнаружения события кнопки
                    «Назад».</p>

                <pre>
                    window.addEventListener('beforeunload', () => {
                        console.log('Clicked browser back button');
                    });
                </pre>

                <p class="engJSTheory">You can also use popstate event to detect the browser back button. Note: The
                    history
                    entry has been
                    activated using history.pushState method.</p>
                <p class="ruJSTheory">Вы также можете использовать событие popstate для обнаружения кнопки возврата
                    браузера. Примечание:
                    Запись истории была активирована с помощью метода History.pushState.</p>

                <pre>
                    window.addEventListener('popstate', () => {
                        console.log('Clicked browser back button');
                        box.style.backgroundColor = 'white';
                    });

                    const box = document.getElementById('div');

                    box.addEventListener('click', () => {
                        box.style.backgroundColor = 'blue';
                        window.history.pushState({}, null, null);
                    });
                </pre>

                <p class="engJSTheory">In the preceeding code, When the box element clicked, its background color
                    appears in
                    blue color and changed to while color upon clicking the browser back button using `popstate`
                    event
                    handler.
                    The `state` property of `popstate` contains the copy of history entry's state object.</p>
                <p class="ruJSTheory">В приведенном выше коде при щелчке по элементу поля цвет его фона отображается
                    синим цветом
                    и меняется на цвет while при нажатии кнопки возврата браузера с использованием обработчика
                    событий
                    popstate.
                    Свойство `state` `popstate` содержит копию состояния объекта записи истории.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment378">
            <div class="engJSTheory">How do you disable right click in the web page</div>
            <div class="ruJSTheory">Как отключить щелчок правой кнопкой мыши на веб-странице</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The right click on the page can be disabled by returning false from the
                    oncontextmenu
                    attribute on the body element.</p>
                <p class="ruJSTheory">Щелчок правой кнопкой мыши на странице можно отключить, вернув false из
                    атрибута
                    oncontextmenu элемента body.</p>

                <pre>
                    < body oncontextmenu="return false;">< /body>
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment379">
            <div class="engJSTheory">What are wrapper objects</div>
            <div class="ruJSTheory">Что такое объекты-обертки</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Primitive Values like string,number and boolean don't have properties and
                    methods
                    but
                    they are
                    temporarily converted or coerced to an object(Wrapper object) when you try to perform actions on
                    them.
                    For example, if you apply toUpperCase() method on a primitive string value, it does not throw an
                    error
                    but returns uppercase of the string.</p>
                <p class="ruJSTheory">Примитивные значения, такие как строка, число и логическое значение, не имеют
                    свойств
                    и методов, но они
                    временно преобразуются или принуждаются к объекту (объекту-оболочке), когда вы пытаетесь
                    выполнить
                    над
                    ними действия. Например, если вы примените метод toUpperCase() к примитивному строковому
                    значению,
                    он не
                    выдаст ошибку, а вернет строку в верхнем регистре.</p>

                <pre>
                    let name = "john";

                    console.log(name.toUpperCase()); // Behind the scenes treated as console.log(new String(name).toUpperCase());
                </pre>

                <p class="engJSTheory">i.e, Every primitive except null and undefined have Wrapper Objects and the
                    list
                    of
                    wrapper objects are
                    String,Number,Boolean,Symbol and BigInt.</p>
                <p class="ruJSTheory">Т.е. каждый примитив, кроме null и undefined, имеет объекты-оболочки, а список
                    объектов-оболочек представляет собой String, Number, Boolean, Symbol and BigInt.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment380">
            <div class="engJSTheory">What is AJAX</div>
            <div class="ruJSTheory">Что такое AJAX(асинхронный JS и XML)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">AJAX stands for Asynchronous JavaScript and XML and it is a group of related
                    technologies(HTML, CSS,
                    JavaScript, XMLHttpRequest API etc) used to display data asynchronously. i.e. We can send data
                    to
                    the
                    server and get data from the server without reloading the web page.</p>
                <p class="ruJSTheory">AJAX означает асинхронный JavaScript и XML и представляет собой группу
                    связанных
                    технологий (HTML, CSS,
                    JavaScript, XMLHttpRequest API и т. д.), используемых для асинхронного отображения данных. т. е.
                    мы
                    можем отправлять данные на сервер и получать данные с сервера без перезагрузки веб-страницы.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment381">
            <div class="engJSTheory">What are the different ways to deal with Asynchronous Code</div>
            <div class="ruJSTheory">Какие есть способы работы с асинхронным кодом</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of different ways to deal with Asynchronous code:</p>
                <p class="ruJSTheory">Ниже приведен список различных способов работы с асинхронным кодом:</p>
                <ol>
                    <li>Callbacks</li>
                    <li>Promises</li>
                    <li>Async/await</li>
                    <li>
                        <div class="engJSTheory">Third-party libraries such as async.js, bluebird etc</div>
                        <div class="ruJSTheory">Сторонние библиотеки, такие как async.js, bluebird и т. д.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment382">
            <div class="engJSTheory">How to cancel a fetch request</div>
            <div class="ruJSTheory">Как отменить fetch запрос</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Until a few days back, One shortcoming of native promises is no direct way to
                    cancel
                    a fetch request. But
                    the new AbortController from js specification allows you to use a signal to abort one or
                    multiple
                    fetch
                    calls. The basic flow of cancelling a fetch request would be as below:</p>
                <p class="ruJSTheory">Еще несколько дней назад одним из недостатков встроенных промисов было
                    отсутствие
                    прямого способа
                    отменить fetch запрос. Но новый AbortController из спецификации js позволяет вам использовать
                    { signal } для прерывания одного или нескольких fetch вызовов. Основной процесс отмены fetch
                    запроса
                    будет выглядеть следующим образом:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Create an AbortController instance</div>
                        <div class="ruJSTheory">Создайте экземпляр AbortController</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Get the signal property of an instance and pass the signal as a
                            fetch
                            option for signal
                        </div>
                        <div class="ruJSTheory">Получите свойство signal экземпляра и передайте его в качестве опции
                            выборки
                            для signal.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Call the AbortController's abort property to cancel all fetches
                            that
                            use
                            that signal For
                            example, let's pass the same signal to multiple fetch calls will cancel all requests
                            with
                            that
                            signal:
                        </div>
                        <div class="ruJSTheory">Вызовите свойство abort из AbortController, чтобы отменить все
                            выборки,
                            использующие этот signal.
                            Например, давайте передадим один и тот же signal нескольким fetch вызовам, которые
                            отменят
                            все
                            запросы с этим signal.
                        </div>
                    </li>
                </ol>

                <pre>
                    const controller = new AbortController();
                    const { signal } = controller;

                    fetch("http://localhost:8000", { signal })
                       .then((response) => {
                         console.log(`Request 1 is complete!`);
                       })
                       .catch((e) => {
                         if (e.name === "AbortError") {
                           // We know it's been canceled!
                         }
                       });

                    fetch("http://localhost:8000", { signal })
                       .then((response) => {
                         console.log(`Request 2 is complete!`);
                       })
                       .catch((e) => {
                         if (e.name === "AbortError") {
                           // We know it's been canceled!
                         }
                       });

                    // Wait 2 seconds to abort both requests
                    setTimeout(() => controller.abort(), 2000);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment383">
            <div class="engJSTheory">What is web speech API</div>
            <div class="ruJSTheory">Что такое web speech API</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Web speech API is used to enable modern browsers recognize and synthesize
                    speech(i.e,
                    voice data into web
                    apps). This API has been introduced by W3C Community in the year 2012. It has two main
                    parts:</p>
                <p class="ruJSTheory">Web speech API используется для того, чтобы современные браузеры могли
                    распознавать и
                    синтезировать речь
                    (т. е. голосовые данные в веб-приложениях). Этот API был представлен сообществом W3C в 2012
                    году. Он
                    состоит из двух основных частей:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">SpeechRecognition (Asynchronous Speech Recognition or
                            Speech-to-Text):
                            It
                            provides the ability
                            to recognize voice context from an audio input and respond accordingly. This is accessed
                            by
                            the
                            SpeechRecognition interface. The below example shows on how to use this API to get text
                            from
                            speech:
                        </div>
                        <div class="ruJSTheory">SpeechRecognition (асинхронное распознавание речи или преобразование
                            речи в
                            текст): оно
                            обеспечивает возможность распознавать голосовой контекст из аудиовхода и реагировать
                            соответствующим образом. Доступ к нему осуществляется через интерфейс SpeechRecognition.
                            В
                            приведенном ниже примере показано, как использовать этот API для получения текста из
                            речи.
                        </div>
                        <pre>
                            window.SpeechRecognition =
                               window.webkitSpeechRecognition || window.SpeechRecognition; // webkitSpeechRecognition for Chrome and SpeechRecognition for FF
                            const recognition = new window.SpeechRecognition();
                            recognition.onresult = (event) => {
                                // SpeechRecognitionEvent type
                                const speechToText = event.results[0][0].transcript;
                                console.log(speechToText);
                            };
                            recognition.start();
                        </pre>
                        <p class="engJSTheory">In this API, browser is going to ask you for permission to use your
                            microphone.</p>
                        <p class="ruJSTheory">В этом API браузер запросит у вас разрешение на использование
                            микрофона.</p>
                    </li>
                    <li>
                        <div class="engJSTheory">SpeechSynthesis (Text-to-Speech): It provides the ability to
                            recognize
                            voice context from an
                            audio input and respond. This is accessed by the SpeechSynthesis interface. For example,
                            the
                            below code is used to get voice/speech from text:
                        </div>
                        <div class="ruJSTheory">SpeechSynthesis (преобразование текста в речь): обеспечивает
                            возможность
                            распознавать голосовой
                            контекст из аудиовхода и реагировать. Доступ к нему осуществляется через интерфейс
                            SpeechSynthesis. Например, приведенный ниже код используется для получения голоса/речи
                            из
                            текста:
                        </div>
                        <pre>
                            if ("speechSynthesis" in window) {
                                let speech = new SpeechSynthesisUtterance("Hello World!");
                                speech.lang = "en-US";
                                window.speechSynthesis.speak(speech);
                            }
                        </pre>
                        <p class="engJSTheory">The above examples can be tested on chrome(33+) browser's developer
                            console.
                            Note: This API is
                            still a working draft and only available in Chrome and Firefox browsers(ofcourse Chrome
                            only
                            implemented the specification).</p>
                        <p class="ruJSTheory">Приведенные выше примеры можно протестировать в консоли разработчика
                            браузера
                            Chrome (33+).
                            Примечание. Этот API все еще является рабочим проектом и доступен только в браузерах
                            Chrome
                            и
                            Firefox (конечно, Chrome реализовал только эту спецификацию).</p>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment384">
            <div class="engJSTheory">What is minimum timeout throttling</div>
            <div class="ruJSTheory">Что такое регулирование минимального таймаута(minimum timeout throttling)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Both browser and NodeJS javascript environments throttles with a minimum
                    delay
                    that
                    is greater than 0ms.
                    That means even though setting a delay of 0ms will not happen instantaneously. Browsers: They
                    have a
                    minimum delay of 4ms. This throttle occurs when successive calls are triggered due to callback
                    nesting(certain depth) or after a certain number of successive intervals. Note: The older
                    browsers
                    have
                    a minimum delay of 10ms. Nodejs: They have a minimum delay of 1ms. This throttle happens when
                    the
                    delay
                    is larger than 2147483647 or less than 1. The best example to explain this timeout throttling
                    behavior
                    is the order of below code snippet.</p>
                <p class="ruJSTheory">И браузер, и среда JavaScript NodeJS регулируют минимальную задержку,
                    превышающую
                    0
                    мс. Это означает, что
                    установка задержки в 0 мс не произойдет мгновенно. Браузеры: у них минимальная задержка 4 мс.
                    Это
                    регулирование происходит, когда запускаются последовательные вызовы из-за вложенности обратных
                    вызовов
                    (определенной глубины) или после определенного количества последовательных интервалов.
                    Примечание. В
                    старых браузерах минимальная задержка составляет 10 мс. Nodejs: у них минимальная задержка 1 мс.
                    Это
                    регулирование происходит, когда задержка превышает 2147483647 или меньше 1. Лучшим примером,
                    объясняющим
                    такое поведение регулирования тайм-аута, является приведенный ниже фрагмент кода.</p>

                <pre>
                    function runMeFirst() {
                        console.log("My script is initialized");
                    }
                    setTimeout(runMeFirst, 0);
                    console.log("Script loaded");

                    //and the output would be in(вывод в консоли будет в следующей последовательности)

                    Script loaded
                    My script is initialized
                </pre>

                <p class="engJSTheory">If you don't use setTimeout, the order of logs will be sequential.</p>
                <p class="ruJSTheory">Если вы не используете setTimeout, порядок будет последовательным.</p>

                <pre>
                    function runMeFirst() {
                        console.log("My script is initialized");
                    }
                    runMeFirst();
                    console.log("Script loaded");

                    //output(вывод в консоли)

                    My script is initialized
                    Script loaded
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment385">
            <div class="engJSTheory">How do you implement zero timeout in modern browsers</div>
            <div class="ruJSTheory">Как реализовать нулевой таймаут в современных браузерах</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can't use setTimeout(fn, 0) to execute the code immediately due to
                    minimum
                    delay
                    of greater than 0ms.
                    But you can use window.postMessage() to achieve this behavior.</p>
                <p class="ruJSTheory">Вы не можете использовать setTimeout(fn, 0) для немедленного выполнения кода
                    из-за
                    минимальной задержки
                    более 0 мс. Но вы можете использовать window.postMessage() для достижения такого поведения.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment386">
            <div class="engJSTheory">What are tasks in event loop</div>
            <div class="ruJSTheory">Что такое задачи в цикле событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A task is any javascript code/program which is scheduled to be run by the
                    standard
                    mechanisms such as
                    initially starting to run a program, run an event callback, or an interval or timeout being
                    fired.
                    All
                    these tasks are scheduled on a task queue. Below are the list of use cases to add tasks to the
                    task
                    queue:</p>
                <p class="ruJSTheory">Задача — это любой код/программа Javascript, запуск которого запланирован с
                    помощью
                    стандартных
                    механизмов, таких как первоначальный запуск программы, запуск обратного вызова события или
                    запуск
                    интервала или тайм-аута. Все эти задачи планируются в очереди задач. Ниже приведен список
                    вариантов
                    использования для добавления задач в очередь задач.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">When a new javascript program is executed directly from console or
                            running
                            by the < script>
                            element, the task will be added to the task queue.
                        </div>
                        <div class="ruJSTheory">Когда новая программа javascript запускается непосредственно из
                            консоли
                            или
                            с помощью элемента
                            < script>, задача будет добавлена в очередь задач.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">When an event fires, the event callback added to task queue</div>
                        <div class="ruJSTheory">При возникновении события, обратный вызов события добавляется в
                            очередь
                            задач.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">When a setTimeout or setInterval is reached, the corresponding
                            callback
                            added to task queue
                        </div>
                        <div class="ruJSTheory">При достижении setTimeout или setInterval соответствующий обратный
                            вызов
                            добавляется в очередь
                            задач.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment387">
            <div class="engJSTheory">What is microtask</div>
            <div class="ruJSTheory">Что такое микрозадача</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Microtask is the javascript code which needs to be executed immediately after
                    the
                    currently executing
                    task/microtask is completed. They are kind of blocking in nature. i.e, The main thread will be
                    blocked
                    until the microtask queue is empty. The main sources of microtasks are Promise.resolve,
                    Promise.reject,
                    MutationObservers, IntersectionObservers etc</p>
                <p class="ruJSTheory">Микрозадача — это код JavaScript, который необходимо выполнить сразу после
                    завершения
                    текущей
                    задачи/микрозадачи. Они носят своего рода блокирующий характер. т. е. основной поток будет
                    заблокирован
                    до тех пор, пока очередь микрозадач не станет пустой. Основными источниками микрозадач являются
                    Promise.resolve, Promise.reject, MutationObservers, IntersectionObservers и т. д.</p>
                <p class="engJSTheory">Note: All of these microtasks are processed in the same turn of the event
                    loop.</p>
                <p class="ruJSTheory">Примечание: Все эти микрозадачи обрабатываются в одном и том же цикле
                    событий.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment388">
            <div class="engJSTheory">What are different event loops</div>
            <div class="ruJSTheory">Что такое разные циклы событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In JavaScript, there are multiple event loops that can be used depending on
                    the
                    context of your
                    application. The most common event loops are:</p>
                <p class="ruJSTheory">В JavaScript существует несколько циклов событий, которые можно использовать в
                    зависимости от контекста
                    вашего приложения. Наиболее распространенные циклы событий:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The Browser Event Loop</div>
                        <div class="ruJSTheory">Цикл событий браузера</div>
                    </li>
                    <li>
                        <div class="engJSTheory">The Node.js Event Loop</div>
                        <div class="ruJSTheory">Цикл событий Node.js</div>
                    </li>
                </ol>

                <p class="engJSTheory">Browser Event Loop: The Browser Event Loop is used in client-side JavaScript
                    applications and is
                    responsible for handling events that occur within the browser environment, such as user
                    interactions
                    (clicks, keypresses, etc.), HTTP requests, and other asynchronous actions.</p>
                <p class="ruJSTheory">Цикл событий браузера: цикл событий браузера используется в клиентских
                    приложениях
                    JavaScript и
                    отвечает за обработку событий, происходящих в среде браузера, таких как взаимодействие с
                    пользователем
                    (клики, нажатия клавиш и т. д.), HTTP-запросы и другие асинхронные действия.</p>
                <p class="engJSTheory">The Node.js Event Loop is used in server-side JavaScript applications and is
                    responsible for handling
                    events that occur within the Node.js runtime environment, such as file I/O, network I/O, and
                    other
                    asynchronous actions.</p>
                <p class="ruJSTheory">Цикл событий Node.js используется в серверных приложениях JavaScript и
                    отвечает за
                    обработку событий,
                    происходящих в среде выполнения Node.js, таких как файловый ввод-вывод, сетевой ввод-вывод и
                    другие
                    асинхронные действия.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment389">
            <div class="engJSTheory">What is the purpose of queueMicrotask</div>
            <div class="ruJSTheory"> Какова цель queueMicrotask</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The queueMicrotask function is used to schedule a microtask, which is a
                    function
                    that
                    will be executed
                    asynchronously in the microtask queue. The purpose of queueMicrotask is to ensure that a
                    function is
                    executed after the current task has finished, but before the browser performs any rendering or
                    handles
                    user events.</p>
                <p class="ruJSTheory">Функция queueMicrotask используется для планирования микрозадачи, которая
                    представляет
                    собой функцию,
                    которая будет выполняться асинхронно в очереди микрозадач. Цель queueMicrotask — гарантировать
                    выполнение
                    функции после завершения текущей задачи, но до того, как браузер выполнит какой-либо рендеринг
                    или
                    обработает пользовательские события.</p>

                <pre>
                    //queueMicrotask example

                    console.log("Start"); //1

                    queueMicrotask(() => {
                        console.log("Inside microtask"); // 3
                    });

                    console.log("End"); //2
                </pre>

                <p class="engJSTheory">By using queueMicrotask, you can ensure that certain tasks or callbacks are
                    executed
                    at the earliest
                    opportunity during the JavaScript event loop, making it useful for performing work that needs to
                    be
                    done
                    asynchronously but with higher priority than regular setTimeout or setInterval callbacks.</p>
                <p class="ruJSTheory">Используя queueMicrotask, вы можете гарантировать, что определенные задачи или
                    обратные вызовы будут
                    выполняться при первой возможности во время цикла событий JavaScript, что делает его полезным
                    для
                    выполнения работы, которую необходимо выполнять асинхронно, но с более высоким приоритетом, чем
                    обычные
                    обратные вызовы setTimeout или setInterval.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment390">
            <div class="engJSTheory">How do you use javascript libraries in typescript file</div>
            <div class="ruJSTheory">Как использовать библиотеки JavaScript в typescript файле?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is known that not all JavaScript libraries or frameworks have TypeScript
                    declaration files. But if you
                    still want to use libraries or frameworks in our TypeScript files without getting compilation
                    errors,
                    the only solution is declare keyword along with a variable declaration. For example, let's
                    imagine
                    you
                    have a library called customLibrary that doesn’t have a TypeScript declaration and have a
                    namespace
                    called customLibrary in the global namespace. You can use this library in typescript code as
                    below:</p>
                <p class="ruJSTheory">Известно, что не все библиотеки или фреймворки JavaScript имеют файлы
                    объявлений
                    TypeScript. Но если вы
                    по-прежнему хотите использовать библиотеки или платформы в наших файлах TypeScript, не получая
                    ошибок
                    компиляции, единственным решением является объявление ключевого слова вместе с объявлением
                    переменной.
                    Например, предположим, что у вас есть библиотека customLibrary, которая не имеет объявления
                    TypeScript и
                    имеет пространство имен customLibrary в глобальном пространстве имен. Вы можете использовать эту
                    библиотеку в typescript коде, как показано ниже:</p>

                <pre>
                    declare var customLibrary;
                </pre>

                <p class="engJSTheory">In the runtime, typescript will provide the type to the customLibrary
                    variable as
                    any
                    type. The another
                    alternative without using declare keyword is below:</p>
                <p class="ruJSTheory">Во время выполнения typescript предоставит тип переменной customLibrary как
                    тип
                    any.
                    Другая альтернатива
                    без использования ключевого слова объявления приведена ниже.</p>

                <pre>
                    let customLibrary: any;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment391">
            <div class="engJSTheory">What are the differences between promises and observables</div>
            <div class="ruJSTheory">В чем разница между promise и observable</div>
        </h3>

        <section>
            <div>
                <p>Что вообще такое observable можно почитать на <a href="https://habr.com/ru/articles/568064/"
                                                                    target="_blank">Habr</a></p>
                <p class="engJSTheory">Some of the major difference in a tabular form:</p>
                <p class="ruJSTheory">Некоторые основные различия в табличной форме:</p>
                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Promises</td>
                        <td>observables</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">Emits only a single value at a time</div>
                            <div class="ruJSTheory">Выдает только одно значение за раз</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Emits multiple values over a period of time(stream of values
                                ranging
                                from 0 to multiple)
                            </div>
                            <div class="ruJSTheory">Выдает несколько значений за определенный период времени (поток
                                значений
                                от 0 до
                                нескольких)
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Eager in nature; they are going to be called immediately</div>
                            <div class="ruJSTheory">Вызов происходит немедленно</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Lazy in nature; they require subscription to be invoked</div>
                            <div class="ruJSTheory">Для вызова необходима подписка</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Promise is always asynchronous even though it resolved
                                immediately
                            </div>
                            <div class="ruJSTheory">Промис всегда асинхронен, даже если он выполняется немедленно.
                            </div>
                        </td>
                        <td>
                            <div class="engJSTheory">Observable can be either synchronous or asynchronous</div>
                            <div class="ruJSTheory">Observable может быть синхронным или асинхронным.</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Doesn't provide any operators</div>
                            <div class="ruJSTheory">Не предоставляет никаких операторов</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Provides operators such as map, forEach, filter, reduce, retry,
                                and
                                retryWhen etc
                            </div>
                            <div class="ruJSTheory">Предоставляет такие операторы, как map, forEach, filter, reduce,
                                retry,
                                and retryWhen и т.д.
                            </div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Cannot be canceled</div>
                            <div class="ruJSTheory">Не может быть отменено</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Canceled by using unsubscribe() method</div>
                            <div class="ruJSTheory">Отменяется с помощью метода unsubscribe()</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment392">
            <div class="engJSTheory">What is heap</div>
            <div class="ruJSTheory">Что такое heap</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Heap(Or memory heap) is the memory location where objects are stored when we
                    define
                    variables. i.e, This
                    is the place where all the memory allocations and de-allocation take place. Both heap and
                    call-stack
                    are
                    two containers of JS runtime. Whenever runtime comes across variables and function declarations
                    in
                    the
                    code it stores them in the Heap.</p>
                <p class="ruJSTheory">Куча (или куча памяти) — это ячейка памяти, в которой хранятся объекты, когда
                    мы
                    определяем переменные.
                    т. е. это место, где происходят все выделения и освобождение памяти. И куча, и стек вызовов
                    представляют
                    собой два контейнера среды выполнения JS. Всякий раз, когда среда выполнения встречает в коде
                    переменные
                    и объявления функций, она сохраняет их в куче.</p>

                <img src="./images/heap.png" alt="heap">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment393">
            <div class="engJSTheory">What is an event table</div>
            <div class="ruJSTheory">Что такое таблица событий</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Event Table is a data structure that stores and keeps track of all the events
                    which
                    will be executed
                    asynchronously like after some time interval or after the resolution of some API requests. i.e
                    Whenever
                    you call a setTimeout function or invoke async operation, it is added to the Event Table. It
                    doesn't
                    not
                    execute functions on it’s own. The main purpose of the event table is to keep track of events
                    and
                    send
                    them to the Event Queue as shown in the below diagram.</p>
                <p class="ruJSTheory">Таблица событий — это структура данных, которая хранит и отслеживает все
                    события,
                    которые будут
                    выполняться асинхронно, например, через определенный интервал времени или после разрешения
                    некоторых
                    запросов API. То есть всякий раз, когда вы вызываете функцию setTimeout или вызываете
                    асинхронную
                    операцию, она добавляется в таблицу событий. Он не выполняет функции сам по себе. Основная цель
                    таблицы
                    событий — отслеживать события и отправлять их в очередь событий, как показано на диаграмме
                    ниже:</p>

                <img src="./images/event-table.png" alt="event-table">
            </div>
        </section>

        <h3 id="JSbasicsForEmployment394">
            <div class="engJSTheory">What is a microTask queue</div>
            <div class="ruJSTheory">Что такое очередь микрозадач</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Microtask Queue is the new queue where all the tasks initiated by promise
                    objects
                    get
                    processed before
                    the callback queue. The microtasks queue are processed before the next rendering and painting
                    jobs.
                    But
                    if these microtasks are running for a long time then it leads to visual degradation.</p>
                <p class="ruJSTheory">Очередь микрозадач — это новая очередь, в которой все задачи, инициированные
                    объектами
                    обещаний,
                    обрабатываются до очереди обратного вызова. Очередь микрозадач обрабатывается перед следующими
                    заданиями
                    рендеринга и рисования. Но если эти микрозадачи выполняются долго, то это приводит к ухудшению
                    зрения.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment395">
            <div class="engJSTheory">What is the difference between shim and polyfill</div>
            <div class="ruJSTheory">В чем разница между шиммом и полифиллом</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A shim is a library that brings a new API to an older environment, using only
                    the
                    means of that
                    environment. It isn't necessarily restricted to a web application. For example, es5-shim.js is
                    used
                    to
                    emulate ES5 features on older browsers (mainly pre IE9). Whereas polyfill is a piece of code (or
                    plugin)
                    that provides the technology that you, the developer, expect the browser to provide natively. In
                    a
                    simple sentence, A polyfill is a shim for a browser API.</p>
                <p class="ruJSTheory">shim — это библиотека, которая переносит новый API в старую среду, используя
                    только
                    средства этой
                    среды. Это не обязательно ограничивается веб-приложением. Например, es5-shim.js используется для
                    эмуляции функций ES5 в старых браузерах (в основном до IE9). Принимая во внимание, что полифилл
                    —
                    это
                    фрагмент кода (или плагин), который предоставляет технологию, которую вы, разработчик, ожидаете
                    от
                    браузера изначально. Проще говоря, полифилл — это оболочка для API браузера.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment396">
            <div class="engJSTheory">How do you detect primitive or non primitive value type</div>
            <div class="ruJSTheory">Как определить примитивный или не примитивный тип значения</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">In JavaScript, primitive types include boolean, string, number, BigInt, null,
                    Symbol
                    and undefined.
                    Whereas non-primitive types include the Objects. But you can easily identify them with the below
                    function:</p>
                <p class="ruJSTheory">В JavaScript к примитивным типам относятся логические значения, строки, числа,
                    BigInt,
                    null, символ и
                    неопределенные. В то время как непримитивные типы включают Objects. Но вы можете легко
                    идентифицировать
                    их с помощью функции ниже:</p>

                <pre>
                    let myPrimitive = 30;
                    let myNonPrimitive = {};
                    function isPrimitive(val) {
                        return Object(val) !== val;
                    }

                    isPrimitive(myPrimitive);
                    isPrimitive(myNonPrimitive);
                </pre>

                <p class="engJSTheory">If the value is a primitive data type, the Object constructor creates a new
                    wrapper
                    object for the value.
                    But If the value is a non-primitive data type (an object), the Object constructor will give the
                    same
                    object.</p>
                <p class="ruJSTheory">Если значение является примитивным типом данных, конструктор Object создает
                    новый
                    объект-оболочку для
                    значения. Но если значение является непримитивным типом данных (объектом), конструктор объекта
                    предоставит тот же объект.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment397">
            <div class="engJSTheory">What is babel</div>
            <div class="ruJSTheory">Что такое babel</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Babel is a JavaScript transpiler to convert ECMAScript 2015+ code into a
                    backwards
                    compatible version of
                    JavaScript in current and older browsers or environments. Some of the main features are listed
                    below:</p>
                <p class="ruJSTheory">Babel — это транспилятор JavaScript для преобразования кода ECMAScript 2015+ в
                    обратно
                    совместимую версию
                    JavaScript в текущих и старых браузерах или средах. Некоторые из основных функций перечислены
                    ниже:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Transform syntax</div>
                        <div class="ruJSTheory">Синтаксис преобразования</div>
                    </li>
                    <li>
                        <div class="engJSTheory"> Polyfill features that are missing in your target environment
                            (using
                            @babel/polyfill)
                        </div>
                        <div class="ruJSTheory">Функции Polyfill, отсутствующие в вашей целевой среде (с
                            использованием
                            @babel/polyfill).
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Source code transformations (or codemods)</div>
                        <div class="ruJSTheory">Преобразования исходного кода (или модификации кода)</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment398">
            <div class="engJSTheory">Is Node.js completely single threaded</div>
            <div class="ruJSTheory">Является ли Node.js полностью однопоточным?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Node is a single thread, but some of the functions included in the Node.js
                    standard
                    library(e.g, fs
                    module functions) are not single threaded. i.e, Their logic runs outside of the Node.js single
                    thread to
                    improve the speed and performance of a program.</p>
                <p class="ruJSTheory">Node — это однопоточный процесс, но некоторые функции, включенные в
                    стандартную
                    библиотеку Node.js
                    (например, функции модуля fs), не являются однопоточными. т. е. их логика работает за пределами
                    одного
                    потока Node.js, чтобы повысить скорость и производительность программы.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment399">
            <div class="engJSTheory">What are the common use cases of observables</div>
            <div class="ruJSTheory">Каковы распространенные случаи использования observable</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Some of the most common use cases of observables are web sockets with push
                    notifications, user input
                    changes, repeating intervals, etc</p>
                <p class="ruJSTheory">Некоторые из наиболее распространенных случаев использования observable — это
                    веб-сокеты с
                    push-уведомлениями, изменения пользовательского ввода, повторение интервалов и т. д.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment400">
            <div class="engJSTheory">What is RxJS</div>
            <div class="ruJSTheory">Что такое RxJS</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">RxJS (Reactive Extensions for JavaScript) is a library for implementing
                    reactive
                    programming using
                    observables that makes it easier to compose asynchronous or callback-based code. It also
                    provides
                    utility functions for creating and working with observables.</p>
                <p class="ruJSTheory">RxJS (Reactive Extensions for JavaScript(дословно: Реактивные расширения для
                    JavaScript)) — это
                    библиотека для реализации реактивного программирования с
                    использованием observables, которая упрощает составление асинхронного кода или кода на основе
                    обратного
                    вызова. Он также предоставляет служебные функции для создания observables и работы с ними.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment401">
            <div class="engJSTheory">What is the difference between Function constructor and function declaration
            </div>
            <div class="ruJSTheory">В чем разница между конструктором функции и объявлением функции</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The functions which are created with Function constructor do not create
                    closures
                    to
                    their creation
                    contexts but they are always created in the global scope. i.e, the function can access its own
                    local
                    variables and global scope variables only. Whereas function declarations can access outer
                    function
                    variables(closures) too.</p>
                <p class="ruJSTheory">Функции, созданные с помощью конструктора функций, не создают замыканий для
                    контекстов
                    своего создания,
                    но они всегда создаются в глобальной области видимости. т. е. функция может обращаться только к
                    своим
                    собственным локальным переменным и переменным глобальной области видимости. В то время как
                    объявления
                    функций также могут получать доступ к внешним переменным функции (замыканиям).</p>
                <p class="engJSTheory">Let's see this difference with an example:</p>
                <p class="ruJSTheory">Давайте посмотрим на эту разницу на примере:</p>

                <pre>
                    // Function Constructor:

                    var a = 100;
                    function createFunction() {
                        var a = 200;
                        return new Function("return a;");
                    }
                    console.log(createFunction()()); // 100

                    // Function declaration:

                    var a = 100;
                    function createFunction() {
                        var a = 200;
                        return function func() {
                          return a;
                        };
                    }
                    console.log(createFunction()()); // 200
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment402">
            <div class="engJSTheory">What is a Short circuit condition</div>
            <div class="ruJSTheory">Что такое короткое замыкание</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Short circuit conditions are meant for condensed way of writing simple if
                    statements.
                    Let's demonstrate
                    the scenario using an example. If you would like to login to a portal with an authentication
                    condition,
                    the expression would be as below:</p>
                <p class="ruJSTheory">Условия короткого замыкания предназначены для сокращенного написания простых
                    операторов if.
                    Продемонстрируем сценарий на примере. Если вы хотите войти на портал с условием аутентификации,
                    выражение будет таким, как показано ниже:</p>

                <pre>
                    if (authenticate) {
                        loginToPorta();
                    }
                </pre>

                <p class="engJSTheory">Since the javascript logical operators evaluated from left to right, the
                    above
                    expression can be
                    simplified using && logical operator:</p>
                <p class="ruJSTheory">Поскольку логические операторы JavaScript оцениваются слева направо,
                    приведенное
                    выше
                    выражение можно
                    упростить с помощью логического оператора &&(оператора короткого замыкания):</p>

                <pre>
                    authenticate && loginToPorta();
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment403">
            <div class="engJSTheory">What is the easiest way to resize an array</div>
            <div class="ruJSTheory">Как проще всего изменить размер массива</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The length property of an array is useful to resize or empty an array
                    quickly.
                    Let's
                    apply length
                    property on number array to resize the number of elements from 5 to 2:</p>
                <p class="ruJSTheory">Свойство length массива полезно для быстрого изменения размера или очистки
                    массива.
                    Давайте применим
                    свойство длины к числовому массиву, чтобы изменить размер количества элементов с 5 до 2.</p>

                <pre>
                    const array = [1, 2, 3, 4, 5];
                    console.log(array.length); // 5

                    array.length = 2;
                    console.log(array.length); // 2
                    console.log(array); // [1,2]
                </pre>

                <p class="engJSTheory">and the array can be emptied too:</p>
                <p class="ruJSTheory">массив также можно очистить:</p>

                <pre>
                    const array = [1, 2, 3, 4, 5];
                    array.length = 0;
                    console.log(array.length); // 0
                    console.log(array); // []
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment404">
            <div class="engJSTheory">What is an observable</div>
            <div class="ruJSTheory">Что такое observable</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An Observable is basically a function that can return a stream of values
                    either
                    synchronously or
                    asynchronously to an observer over time. The consumer can get the value by calling subscribe()
                    method.
                    Let's look at a simple example of an Observable:</p>
                <p class="ruJSTheory">Observable – это, по сути, функция, которая может возвращать
                    наблюдателю(observer)
                    поток значений синхронно или
                    асинхронно с течением времени. Потребитель(consumer) может получить значение, вызвав метод
                    subscribe().
                    Давайте посмотрим на простой пример Observable:</p>

                <pre>
                    import { Observable } from "rxjs";

                    const observable = new Observable((observer) => {
                        setTimeout(() => {
                          observer.next("Message from a Observable!");
                        }, 3000);
                    });

                    observable.subscribe((value) => console.log(value));
                </pre>

                <img src="./images/observables.png" alt="observables" width="644">

                <p class="engJSTheory">Note: Observables are not part of the JavaScript language yet but they are
                    being
                    proposed to be added to the language.</p>
                <p class="ruJSTheory">Примечание: Observables пока не являются частью языка JavaScript, но их
                    предлагается
                    добавить в язык.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment405">
            <div class="engJSTheory">What is the difference between function and class declarations</div>
            <div class="ruJSTheory">В чем разница между объявлениями функций и классов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The main difference between function declarations and class declarations is
                    hoisting.
                    The function
                    declarations are hoisted but not class declarations:</p>
                <p class="ruJSTheory">Основное различие между объявлениями функций и объявлениями классов — это
                    подъем(hoisting). Объявления
                    функций
                    поднимаются, a объявления классов - нет.</p>

                <pre>
                    Classes:

                    const user = new User(); // ReferenceError

                    class User {}

                    //Constructor Function:

                    const user = new User(); // No error

                    function User() {}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment406">
            <div class="engJSTheory">What is an async function</div>
            <div class="ruJSTheory">Что такое асинхронная функция</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An async function is a function declared with the async keyword which enables
                    asynchronous, promise-based
                    behavior to be written in a cleaner style by avoiding promise chains. These functions can
                    contain
                    zero
                    or more await expressions.</p>
                <p class="ruJSTheory">Асинхронная функция — это функция, объявленная с ключевым словом async,
                    которая
                    позволяет писать
                    асинхронное поведение на основе промисов в более чистом стиле, избегая цепочек промисов. Эти
                    функции
                    могут содержать ноль или более выражений «await».</p>
                <p class="engJSTheory">Let's take a below async function example:</p>
                <p class="ruJSTheory">Давайте возьмем приведенный ниже пример асинхронной функции:</p>

                <pre>
                    async function logger() {
                        let data = await fetch("http://someapi.com/users"); // pause until fetch returns
                        console.log(data);
                    }
                    logger();
                </pre>

                <p class="engJSTheory">It is basically syntax sugar over ES2015 promises and generators.</p>
                <p class="ruJSTheory">По сути, это синтаксический сахар над промисами и генераторами ES2015.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment407">
            <div class="engJSTheory">How do you prevent promises swallowing errors</div>
            <div class="ruJSTheory">Как предотвратить ошибки, связанные с проглатыванием промисов?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">While using asynchronous code, JavaScript’s ES6 promises can make your life a
                    lot
                    easier without having
                    callback pyramids and error handling on every second line. But Promises have some pitfalls and
                    the
                    biggest one is swallowing errors by default.</p>
                <p class="ruJSTheory">При использовании асинхронного кода промисов ES6 JavaScript могут значительно
                    облегчить вашу жизнь без
                    пирамид обратных вызовов и обработки ошибок в каждой второй строке. Но у промисов есть некоторые
                    подводные камни, и самый большой из них — это проглатывание ошибок по умолчанию.</p>
                <p class="engJSTheory">Let's say you expect to print an error to the console for all the below
                    cases:</p>
                <p class="ruJSTheory">Допустим, вы ожидаете вывести в консоль ошибку во всех следующих случаях:</p>

                <pre>
                    Promise.resolve("promised value").then(function () {
                        throw new Error("error");
                    });

                    Promise.reject("error value").catch(function () {
                        throw new Error("error");
                    });

                    new Promise(function (resolve, reject) {
                        throw new Error("error");
                    });
                </pre>

                <p class="engJSTheory">But there are many modern JavaScript environments that won't print any
                    errors.
                    You
                    can fix this problem
                    in different ways:</p>
                <p class="ruJSTheory">Но существует множество современных сред JavaScript, которые не выводят
                    никаких
                    ошибок. Эту проблему
                    можно решить разными способами:</p>
                <ol>
                    <li>
                        <div class="engJSTheory">Add catch block at the end of each chain: You can add catch block
                            to
                            the
                            end of each of your
                            promise chains
                        </div>
                        <div class="ruJSTheory">Добавьте блок catch в конец каждой цепочки: вы можете добавить блок
                            catch в
                            конец каждой
                            цепочки обещаний.
                        </div>
                        <pre>
                            Promise.resolve("promised value")
                               .then(function () {
                                 throw new Error("error");
                               })
                               .catch(function (error) {
                                 console.error(error.stack);
                               });
                        </pre>
                        <p class="engJSTheory">But it is quite difficult to type for each promise chain and verbose
                            too.</p>
                        <p class="ruJSTheory">Но печатать для каждой цепочки обещаний довольно сложно, да и
                            многословно.</p>
                    </li>
                    <li>
                        <div class="engJSTheory">Add done method: You can replace first solution's then and catch
                            blocks
                            with done method
                        </div>
                        <div class="ruJSTheory">Добавить метод Done: вы можете заменить блоки "then" и "catch"
                            первого
                            решения методом Done.
                        </div>
                        <pre>
                            Promise.resolve("promised value").done(function () {
                                throw new Error("error");
                            });
                        </pre>
                        <div class="engJSTheory">Let's say you want to fetch data using HTTP and later perform
                            processing on
                            the resulting data
                            asynchronously. You can write done block as below:
                        </div>
                        <div class="ruJSTheory">Допустим, вы хотите получить данные с помощью HTTP, а затем
                            выполнить
                            асинхронную обработку
                            полученных данных. Вы можете написать готовый блок, как показано ниже:
                        </div>
                        <pre>
                            getDataFromHttp()
                               .then(function (result) {
                                 return processDataAsync(result);
                               })
                               .done(function (processed) {
                                 displayData(processed);
                               });
                        </pre>
                        <div class="engJSTheory">In future, if the processing library API changed to synchronous
                            then
                            you
                            can remove done block
                            as below:
                        </div>
                        <div class="ruJSTheory">В будущем, если API библиотеки обработки изменится на синхронный, вы
                            можете
                            удалить блок
                            "done", как показано ниже:
                        </div>
                        <pre>
                            getDataFromHttp().then(function (result) {
                                return displayData(processDataAsync(result));
                            });
                        </pre>
                        <div class="engJSTheory">and then you forgot to add done block to then block leads to silent
                            errors.
                        </div>
                        <div class="ruJSTheory">и если вы забыли добавить блок "done" к блоку "then", то это
                            приводит к
                            скрытым ошибкам.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Extend ES6 Promises by Bluebird: Bluebird extends the ES6 Promises
                            API
                            to
                            avoid the issue in
                            the second solution. This library has a “default” onRejection handler which will print
                            all
                            errors from rejected Promises to stderr. After installation, you can process unhandled
                            rejections:
                        </div>
                        <div class="ruJSTheory">Расширение промисов ES6 с помощью Bluebird: Bluebird расширяет API
                            промисов
                            ES6, чтобы избежать
                            проблемы во втором решении. Эта библиотека имеет обработчик onRejection “default”,
                            который
                            выводит все ошибки из отклоненных промисов в stderr. После установки вы можете
                            обрабатывать
                            необработанные отклонения
                        </div>
                        <pre>
                            Promise.onPossiblyUnhandledRejection(function (error) {
                                throw error;
                            });
                        </pre>
                        <div class="engJSTheory">and discard a rejection, just handle it with an empty catch</div>
                        <div class="ruJSTheory">и отбросить отказ, просто обработайте его пустым catch</div>
                        <pre>
                            Promise.reject("error value").catch(function () {});
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment408">
            <div class="engJSTheory">What is deno</div>
            <div class="ruJSTheory">Что такое deno</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Deno is a simple, modern and secure runtime for JavaScript and TypeScript
                    that
                    uses
                    V8 JavaScript engine
                    and the Rust programming language.</p>
                <p class="ruJSTheory">Deno — это простая, современная и безопасная среда выполнения для JavaScript и
                    TypeScript, использующая
                    движок JavaScript V8 и язык программирования Rust.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment409">
            <div class="engJSTheory">How do you make an object iterable in javascript</div>
            <div class="ruJSTheory">Как сделать объект итерируемым в JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">By default, plain objects are not iterable. But you can make the object
                    iterable
                    by
                    defining a
                    Symbol.iterator property on it.</p>
                <p class="ruJSTheory">По умолчанию простые объекты не являются итерируемыми. Но вы можете сделать
                    объект
                    итерируемым, определив
                    для него свойство Symbol.iterator.</p>
                <p class="engJSTheory">Let's demonstrate this with an example:</p>
                <p class="ruJSTheory">Продемонстрируем это на примере:</p>

                <pre>
                    const collection = {
                       one: 1,
                       two: 2,
                       three: 3,
                       [Symbol.iterator]() {
                          const values = Object.keys(this);
                          let i = 0;
                          return {
                             next: () => {
                                return {
                                   value: this[values[i++]],
                                   done: i > values.length,
                                };
                             },
                          };
                       },
                    };

                    const iterator = collection[Symbol.iterator]();

                    console.log(iterator.next()); // → {value: 1, done: false}
                    console.log(iterator.next()); // → {value: 2, done: false}
                    console.log(iterator.next()); // → {value: 3, done: false}
                    console.log(iterator.next()); // → {value: undefined, done: true}
                </pre>

                <p class="engJSTheory">The above process can be simplified using a generator function:</p>
                <p class="ruJSTheory">Вышеописанный процесс можно упростить, используя функцию генератора:</p>

                <pre>
                    const collection = {
                        one: 1,
                        two: 2,
                        three: 3,
                        [Symbol.iterator]: function* () {
                            for (let key in this) {
                                yield this[key];
                            }
                        },
                    };
                    const iterator = collection[Symbol.iterator]();
                    console.log(iterator.next()); // {value: 1, done: false}
                    console.log(iterator.next()); // {value: 2, done: false}
                    console.log(iterator.next()); // {value: 3, done: false}
                    console.log(iterator.next()); // {value: undefined, done: true}
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment410">
            <div class="engJSTheory">What is a Proper Tail Call</div>
            <div class="ruJSTheory">Что такое правильный хвостовой вызов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">First, we should know about tail call before talking about "Proper Tail
                    Call". A
                    tail
                    call is a
                    subroutine or function call performed as the final action of a calling function. Whereas Proper
                    tail
                    call(PTC) is a technique where the program or code will not create additional stack frames for a
                    recursion when the function call is a tail call.</p>
                <p class="ruJSTheory">Во-первых, мы должны знать о хвостовом вызове, прежде чем говорить о
                    "правильном
                    хвостовом вызове".
                    Хвостовой вызов — это вызов подпрограммы или функции, выполняемый как последнее действие
                    вызывающей
                    функции. Принимая во внимание, что правильный хвостовой вызов (PTC) — это метод, при котором
                    программа
                    или код не будут создавать дополнительные кадры стека для рекурсии, когда вызов функции является
                    хвостовым вызовом.</p>
                <p class="engJSTheory">For example, the below classic or head recursion of factorial function relies
                    on
                    stack for each step.
                    Each step need to be processed upto n * factorial(n - 1)</p>
                <p class="ruJSTheory">Например, приведенная ниже классическая или головная рекурсия функции
                    факториала
                    использует стек для
                    каждого шага. Каждый шаг должен быть обработан до n * factorial(n - 1).</p>

                <pre>
                    function factorial(n) {
                        if (n === 0) {
                          return 1;
                        }
                        return n * factorial(n - 1);
                    }
                    console.log(factorial(5)); //120
                </pre>

                <p class="engJSTheory">But if you use Tail recursion functions, they keep passing all the necessary
                    data
                    it
                    needs down the recursion without relying on the stack.</p>
                <p class="ruJSTheory">Но если вы используете функции хвостовой рекурсии, они продолжают передавать
                    все
                    необходимые данные по рекурсии, не полагаясь на стек.</p>

                <pre>
                    function factorial(n, acc = 1) {
                        if (n === 0) {
                          return acc;
                        }
                        return factorial(n - 1, n * acc);
                    }
                    console.log(factorial(5)); //120
                </pre>

                <p class="engJSTheory">The above pattern returns the same output as the first one. But the
                    accumulator
                    keeps
                    track of total as
                    an argument without using stack memory on recursive calls.</p>
                <p class="ruJSTheory">Приведенный выше шаблон возвращает тот же результат, что и первый. Но
                    аккумулятор
                    отслеживает сумму в
                    качестве аргумента, не используя память стека при рекурсивных вызовах.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment411">
            <div class="engJSTheory">How do you check an object is a promise or not</div>
            <div class="ruJSTheory">Как проверить, является ли объект промисом или нет?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">If you don't know if a value is a promise or not, wrapping the value as
                    Promise.resolve(value) which returns a promise:</p>
                <p class="ruJSTheory">Если вы не знаете, является ли значение промисом или нет, оберните значение
                    как
                    Promise.resolve(value), которое возвращает промис.</p>

                <pre>
                    function isPromise(object) {
                        if (Promise && Promise.resolve) {
                          return Promise.resolve(object) == object;
                        } else {
                          throw "Promise not supported in your environment";
                        }
                    }

                    var i = 1;
                    var promise = new Promise(function (resolve, reject) {
                        resolve();
                    });

                    console.log(isPromise(i)); // false
                    console.log(isPromise(promise)); // true
                </pre>

                <p class="engJSTheory">Another way is to check for .then() handler type:</p>
                <p class="ruJSTheory">Другой способ — проверить тип обработчика .then().</p>

                <pre>
                    function isPromise(value) {
                        return Boolean(value && typeof value.then === "function");
                    }
                    var i = 1;
                    var promise = new Promise(function (resolve, reject) {
                        resolve();
                    });

                    console.log(isPromise(i)); // false
                    console.log(isPromise(promise)); // true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment412">
            <div class="engJSTheory">How to detect if a function is called as constructor</div>
            <div class="ruJSTheory">Как определить, вызывается ли функция как конструктор</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can use new.target pseudo-property to detect whether a function was
                    called as
                    a
                    constructor(using the
                    new operator) or as a regular function call.</p>
                <p class="ruJSTheory">Вы можете использовать псевдосвойство new.target, чтобы определить, была ли
                    функция
                    вызвана как
                    конструктор (с использованием оператора new) или как обычный вызов функции.</p>

                <ol>
                    <li>
                        <div class="engJSTheory">If a constructor or function invoked using the new operator,
                            new.target
                            returns a reference to the constructor or function.
                        </div>
                        <div class="ruJSTheory">Если конструктор или функция вызывается с помощью оператора new,
                            new.target
                            возвращает ссылку на конструктор или функцию.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">For function calls, new.target is undefined.</div>
                        <div class="ruJSTheory">Для вызовов функций new.target - undefined.</div>
                        <pre>
                            function Myfunc() {
                                if (new.target) {
                                  console.log("called with new");
                                } else {
                                  console.log("not called with new");
                                }
                            }

                            new Myfunc(); // called with new
                            Myfunc(); // not called with new
                            Myfunc.call({}); // not called with new
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment413">
            <div class="engJSTheory">What are the differences between arguments object and rest parameter</div>
            <div class="ruJSTheory">Каковы различия между объектом аргументов и параметром rest</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are three main differences between arguments object and rest
                    parameters:</p>
                <p class="ruJSTheory">Существует три основных различия между объектом аргументов и остальными
                    параметрами:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">The arguments object is an array-like but not an array. Whereas the
                            rest
                            parameters are array
                            instances.
                        </div>
                        <div class="ruJSTheory">Объект аргументов похож на массив, но не является массивом. Тогда
                            как
                            остальные параметры
                            являются экземплярами массива.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">The arguments object does not support methods such as sort, map,
                            forEach,
                            or pop. Whereas these
                            methods can be used in rest parameters.
                        </div>
                        <div class="ruJSTheory">Объект аргументов не поддерживает такие методы, как sort, map,
                            forEach
                            или
                            pop. Тогда как эти
                            методы можно использовать в остальных параметрах.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">The rest parameters are only the ones that haven’t been given a
                            separate
                            name, while the
                            arguments object contains all arguments passed to the function
                        </div>
                        <div class="ruJSTheory">Rest параметры — это только те, которым не присвоено отдельное имя,
                            а
                            объект
                            аргументов
                            содержит все аргументы, переданные в функцию.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment414">
            <div class="engJSTheory">What are the differences between spread operator and rest parameter</div>
            <div class="ruJSTheory">В чем разница между spread оператором и rest параметром</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Rest parameter collects all remaining elements into an array. Whereas Spread
                    operator
                    allows iterables(
                    arrays / objects / strings ) to be expanded into single arguments/elements. i.e, Rest parameter
                    is
                    opposite to the spread operator.</p>
                <p class="ruJSTheory">Параметр Rest собирает все оставшиеся элементы в массив. В то время как
                    оператор
                    Spread позволяет
                    разделять итерируемые элементы (массивы/объекты/строки) на отдельне аргументы/элементы. т. е.
                    параметр
                    Rest противоположен оператору spread.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment415">
            <div class="engJSTheory">What are the different kinds of generators</div>
            <div class="ruJSTheory">Какие существуют виды генераторов</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are five kinds of generators:</p>
                <p class="ruJSTheory">Существует пять видов генераторов:</p>

                <ol>
                    <li>
                        <div>Объявление функции генератора(Generator function declaration):</div>
                        <pre>
                            function* myGenFunc() {
                                yield 1;
                                yield 2;
                                yield 3;
                            }
                            const genObj = myGenFunc();
                        </pre>
                    </li>
                    <li>
                        <div>Выражения генераторной функции(Generator function expressions):</div>
                        <pre>
                            const myGenFunc = function* () {
                                yield 1;
                                yield 2;
                                yield 3;
                            };
                            const genObj = myGenFunc();
                        </pre>
                    </li>
                    <li>
                        <div>Определения методов генератора в объектных литералах(Generator method definitions in
                            object
                            literals):
                        </div>
                        <pre>
                            const myObj = {
                                *myGeneratorMethod() {
                                  yield 1;
                                  yield 2;
                                  yield 3;
                                },
                            };
                            const genObj = myObj.myGeneratorMethod();
                        </pre>
                    </li>
                    <li>
                        <div>Определения методов генератора в классе(Generator method definitions in class):</div>
                        <pre>
                            class MyClass {
                                *myGeneratorMethod() {
                                  yield 1;
                                  yield 2;
                                  yield 3;
                                }
                            }
                            const myObject = new MyClass();
                            const genObj = myObject.myGeneratorMethod();
                        </pre>
                    </li>
                    <li>
                        <div>Генератор как вычисляемое свойство:(Generator as a computed property):</div>
                        <pre>
                            const SomeObj = {
                                *[Symbol.iterator]() {
                                  yield 1;
                                  yield 2;
                                  yield 3;
                                },
                            };

                            console.log(Array.from(SomeObj)); // [ 1, 2, 3 ]
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment416">
            <div class="engJSTheory">What are the built-in iterables</div>
            <div class="ruJSTheory">Какие есть встроенные итерируемые сущности</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Below are the list of built-in iterables in javascript:</p>
                <p class="ruJSTheory">Ниже приведен список встроенных итераций в JavaScript:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Arrays and TypedArrays</div>
                        <div class="ruJSTheory">Массивы и типизированные массивы</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Strings: Iterate over each character or Unicode code-points</div>
                        <div class="ruJSTheory">Строки: перебор каждого символа или кодовых точек Юникода.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Maps: iterate over its key-value pairs</div>
                        <div class="ruJSTheory">Maps: перебор пары ключ-значение.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Sets: iterates over their elements</div>
                        <div class="ruJSTheory">Sets: перебор их элементов.</div>
                    </li>
                    <li>
                        <div class="engJSTheory">arguments: An array-like special variable in functions</div>
                        <div class="ruJSTheory">аргументы: специальная переменная, подобная массиву, в функциях.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">DOM collection such as NodeList</div>
                        <div class="ruJSTheory">Коллекция DOM, такая как NodeList.</div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment417">
            <div class="engJSTheory">What are the differences between for...of and for...in statements</div>
            <div class="ruJSTheory">В чем разница между операторами for...of и for...in</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Both for...in and for...of statements iterate over js data structures. The
                    only
                    difference is over what
                    they iterate:</p>
                <p class="ruJSTheory">Операторы for...in и for...of перебирают структуры данных js. Единственная
                    разница
                    заключается в том, что
                    они итерируют:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">for..in iterates over all enumerable property keys of an object
                        </div>
                        <div class="ruJSTheory">for..in перебирает все перечислимые ключи свойств объекта</div>
                    </li>
                    <li>
                        <div class="engJSTheory">for..of iterates over the values of an iterable object.</div>
                        <div class="ruJSTheory">for..of перебирает значения итерируемого объекта.</div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's explain this difference with an example:</p>
                <p class="ruJSTheory">Поясним эту разницу на примере:</p>

                <pre>
                    let arr = ["a", "b", "c"];

                    arr.newProp = "newValue";

                    // key are the property keys
                    for (let key in arr) {
                        console.log(key); // 0, 1, 2 & newValue
                    }

                    // value are the property values
                    for (let value of arr) {
                        console.log(value); // a, b, c
                    }
                </pre>

                <p class="engJSTheory">Since for..in loop iterates over the keys of the object, the first loop logs
                    0,
                    1, 2
                    and newProp while
                    iterating over the array object. The for..of loop iterates over the values of a arr data
                    structure
                    and
                    logs a, b, c in the console.</p>
                <p class="ruJSTheory">Поскольку цикл for..in перебирает ключи объекта, первый цикл регистрирует 0,
                    1, 2
                    и
                    newProp при переборе
                    объекта массива. Цикл for..of перебирает значения структуры данных arr и записывает a, b, c в
                    консоль.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment418">
            <div class="engJSTheory">How do you define instance and non-instance properties</div>
            <div class="ruJSTheory">Как вы определяете свойства экземпляра и неэкземпляра</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The Instance properties must be defined inside of class methods. For example,
                    name
                    and age properties defined inside constructor as below:</p>
                <p class="ruJSTheory">Свойства экземпляра должны быть определены внутри методов класса. Например,
                    свойства
                    name и age, определенные внутри конструктора, как показано ниже:</p>

                <pre>
                    class Person {
                        constructor(name, age) {
                          this.name = name;
                          this.age = age;
                        }
                    }
                </pre>

                <p class="engJSTheory">But Static(class) and prototype data properties must be defined outside of
                    the
                    ClassBody declaration. Let's assign the age value for Person class as below:</p>
                <p class="ruJSTheory">Но свойства данных Static(class) и прототипа должны быть определены вне
                    объявления
                    ClassBody. Давайте присвоим значение возраста для класса Person, как показано ниже:</p>

                <pre>
                    Person.staticAge = 30;
                    Person.prototype.prototypeAge = 40;
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment419">
            <div class="engJSTheory">What is the difference between isNaN and Number.isNaN?</div>
            <div class="ruJSTheory">В чем разница между isNaN и Number.isNaN?</div>
        </h3>

        <section>
            <div>
                <ol>
                    <li>
                        <div class="engJSTheory">isNaN: The global function isNaN converts the argument to a Number
                            and
                            returns true if the resulting value is NaN.
                        </div>
                        <div class="ruJSTheory">isNaN: глобальная функция isNaN преобразует аргумент в число и
                            возвращает
                            true, если результирующее значение равно NaN.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Number.isNaN: This method does not convert the argument. But it
                            returns
                            true when the type is a Number and value is NaN.
                        </div>
                        <div class="ruJSTheory">Number.isNaN: этот метод не преобразует аргумент. Но он возвращает
                            true,
                            если тип — число, а значение — NaN.
                        </div>
                    </li>
                </ol>

                <p class="engJSTheory">Let's see the difference with an example:</p>
                <p class="ruJSTheory">Давайте посмотрим разницу на примере:</p>

                <pre>
                    isNaN(‘hello’);   // true
                    Number.isNaN('hello'); // false
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment420">
            <div class="engJSTheory">How to invoke an IIFE without any extra brackets?</div>
            <div class="ruJSTheory">Как вызвать IIFE без дополнительных скобок?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Immediately Invoked Function Expressions(IIFE) requires a pair of parenthesis
                    to
                    wrap
                    the function which contains set of statements.</p>
                <p class="ruJSTheory">Для выражений с немедленным вызовом функций (IIFE) требуется пара круглых
                    скобок,
                    чтобы обернуть функцию, содержащую набор операторов.</p>

                <pre>
                    (function (dt) {
                        console.log(dt.toLocaleTimeString());
                    })(new Date());
                </pre>

                <p class="engJSTheory">Since both IIFE and void operator discard the result of an expression, you
                    can
                    avoid
                    the extra brackets using void operator for IIFE as below:</p>
                <p class="ruJSTheory">Поскольку и IIFE, и оператор void отбрасывают результат выражения, вы можете
                    избежать
                    дополнительных скобок, используя оператор void для IIFE, как показано ниже:</p>

                <pre>
                    void (function (dt) {
                        console.log(dt.toLocaleTimeString());
                    })(new Date());
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment421">
            <div class="engJSTheory">Is that possible to use expressions in switch cases?</div>
            <div class="ruJSTheory">Можно ли использовать выражения в switch case цикле?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You might have seen expressions used in switch condition but it is also
                    possible
                    to
                    use for switch cases
                    by assigning true value for the switch condition. Let's see the weather condition based on
                    temparature
                    as an example:</p>
                <p class="ruJSTheory">Возможно, вы видели выражения, используемые в switch condition, но их также
                    можно
                    использовать для
                    switch case, присвоив условию переключения истинное значение. Давайте посмотрим на погодные
                    условия в зависимости от температуры в качестве примера:</p>

                <pre>
                    const weather = (function getWeather(temp) {
                       switch (true) {
                          case temp < 0:
                             return "freezing";
                          case temp < 10:
                             return "cold";
                          case temp < 24:
                             return "cool";
                          default:
                             return "unknown";
                       }
                    })(10);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment422">
            <div class="engJSTheory">What is the easiest way to ignore promise errors?</div>
            <div class="ruJSTheory">Как проще всего игнорировать ошибки промисов?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The easiest and safest way to ignore promise errors is void that error. This
                    approach
                    is ESLint friendly too.</p>
                <p class="ruJSTheory">Самый простой и безопасный способ игнорировать ошибки промисов — аннулировать
                    эту
                    ошибку. Этот подход также дружелюбен к ESLint.</p>

                <pre>
                    await promise.catch((e) => void e);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment423">
            <div class="engJSTheory">How do style the console output using CSS?</div>
            <div class="ruJSTheory">Как оформить вывод консоли с помощью CSS?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">You can add CSS styling to the console output using the CSS format content
                    specifier
                    %c. The console
                    string message can be appended after the specifier and CSS style in another argument. Let's
                    print
                    the
                    red the color text using console.log and CSS specifier as below:</p>
                <p class="ruJSTheory">Вы можете добавить стиль CSS к выводу консоли, используя спецификатор
                    содержимого
                    формата CSS %c.
                    Строковое сообщение консоли можно добавить после спецификатора и стиля CSS в другом аргументе.
                    Давайте
                    напечатаем текст красного цвета, используя console.log и спецификатор CSS, как показано
                    ниже:</p>

                <pre>
                    console.log("%cThis is a red text", "color:red");
                </pre>

                <p class="engJSTheory">It is also possible to add more styles for the content. For example, the
                    font-size
                    can be modified for the above text:</p>
                <p class="ruJSTheory">Также возможно добавить больше стилей для контента. Например, размер шрифта
                    можно
                    изменить для приведенного выше текста.</p>

                <pre>
                    console.log(
                        "%cThis is a red text with bigger font",
                        "color:red; font-size:20px"
                    );
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment424">
            <div class="engJSTheory">What is nullish coalescing operator (??)?</div>
            <div class="ruJSTheory">Что такое нулевой оператор слияния (??)?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is a logical operator that returns its right-hand side operand when its
                    left-hand
                    side operand is null
                    or undefined, and otherwise returns its left-hand side operand. This can be contrasted with the
                    logical
                    OR (||) operator, which returns the right-hand side operand if the left operand is any falsy
                    value,
                    not
                    only null or undefined.</p>
                <p class="ruJSTheory">Это логический оператор, который возвращает свой правый операнд, когда его
                    левый
                    операнд имеет значение
                    null или undefined, и в противном случае возвращает свой левый операнд. Это можно
                    противопоставить
                    логическому оператору ИЛИ (||), который возвращает правый операнд, если левый операнд имеет
                    любое
                    ложное
                    значение, а не null или undefined.</p>

                <pre>
                    console.log(null ?? true); // true
                    console.log(false ?? true); // false
                    console.log(undefined ?? true); // true
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment425">
            <div class="engJSTheory">How do you group and nest console output?</div>
            <div class="ruJSTheory">Как группировать и вкладывать вывод консоли?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The console.group() can be used to group related log messages to be able to
                    easily
                    read the logs and use
                    console.groupEnd()to close the group. Along with this, you can also nest groups which allows to
                    output
                    message in hierarchical manner.</p>
                <p class="ruJSTheory">console.group() можно использовать для группировки связанных сообщений
                    журнала,
                    чтобы
                    можно было легко
                    читать журналы и использовать console.groupEnd() для закрытия группы. Наряду с этим вы также
                    можете
                    вкладывать группы, что позволяет выводить сообщения в иерархическом порядке.</p>
                <p class="engJSTheory">For example, if you’re logging a user’s details:</p>
                <p class="ruJSTheory">Например, если вы регистрируете данные пользователя:</p>

                <pre>
                    console.group("User Details");
                    console.log("name: Sudheer Jonna");
                    console.log("job: Software Developer");

                    // Nested Group
                    console.group("Address");
                    console.log("Street: Commonwealth");
                    console.log("City: Los Angeles");
                    console.log("State: California");

                    // Close nested group
                    console.groupEnd();

                    // Close outer group
                    console.groupEnd();
                </pre>

                <p class="engJSTheory">You can also use console.groupCollapsed() instead of console.group() if you
                    want
                    the
                    groups to be
                    collapsed by default.</p>
                <p class="ruJSTheory">Вы также можете использовать console.groupCollapsed() вместо console.group(),
                    если
                    хотите, чтобы группы
                    по умолчанию были свернуты.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment426">
            <div class="engJSTheory">What is the difference between dense and sparse arrays?</div>
            <div class="ruJSTheory">В чем разница между плотными и разреженными массивами?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An array contains items at each index starting from first(0) to
                    last(array.length
                    -
                    1) is called as Dense
                    array. Whereas if at least one item is missing at any index, the array is called as sparse.</p>
                <p class="ruJSTheory">Массив, содержащий элементы под каждым индексом, начиная с первого (0) до
                    последнего
                    (array.length - 1),
                    называется плотным массивом. А если по какому-либо индексу отсутствует хотя бы один элемент,
                    массив
                    называется разреженным.</p>
                <p class="engJSTheory">Let's see the below two kind of arrays:</p>
                <p class="ruJSTheory">Давайте посмотрим на два типа массивов ниже:</p>

                <pre>
                    const avengers = ["Ironman", "Hulk", "CaptainAmerica"];
                    console.log(avengers[0]); // 'Ironman'
                    console.log(avengers[1]); // 'Hulk'
                    console.log(avengers[2]); // 'CaptainAmerica'
                    console.log(avengers.length); // 3

                    const justiceLeague = ["Superman", "Aquaman", , "Batman"];
                    console.log(justiceLeague[0]); // 'Superman'
                    console.log(justiceLeague[1]); // 'Aquaman'
                    console.log(justiceLeague[2]); // undefined
                    console.log(justiceLeague[3]); // 'Batman'
                    console.log(justiceLeague.length); // 4
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment427">
            <div class="engJSTheory">What are the different ways to create sparse arrays?</div>
            <div class="ruJSTheory">Какие существуют способы создания разреженных массивов?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">There are 4 different ways to create sparse arrays in JavaScript:</p>
                <p class="ruJSTheory">Существует 4 различных способа создания разреженных массивов в JavaScript:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Array literal: Omit a value when using the array literal</div>
                        <div class="ruJSTheory">Литерал массива: пропустите значение при использовании литерала
                            массива.
                        </div>
                        <pre>
                            const justiceLeague = ["Superman", "Aquaman", , "Batman"];
                            console.log(justiceLeague); // ['Superman', 'Aquaman', empty ,'Batman']
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Array() constructor: Invoking Array(length) or new Array(length)
                        </div>
                        <div class="ruJSTheory">Конструктор Array(): вызов Array(length) или нового Array(length)
                        </div>
                        <pre>
                            const array = Array(3);
                            console.log(array); // [empty, empty ,empty]
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Delete operator: Using delete array[index] operator on the array
                        </div>
                        <div class="ruJSTheory">Оператор delete: использование оператора delete array[index] в
                            массиве.
                        </div>
                        <pre>
                            const justiceLeague = ["Superman", "Aquaman", "Batman"];
                            delete justiceLeague[1];
                            console.log(justiceLeague); // ['Superman', empty, ,'Batman']
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Increase length property: Increasing length property of an array
                        </div>
                        <div class="ruJSTheory">Увеличение свойства length: увеличение свойства length массива.
                        </div>
                        <pre>
                            const justiceLeague = ["Superman", "Aquaman", "Batman"];
                            justiceLeague.length = 5;
                            console.log(justiceLeague); // ['Superman', 'Aquaman', 'Batman', empty, empty]
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment428">
            <div class="engJSTheory">What is the difference between setTimeout, setImmediate and process.nextTick?
            </div>
            <div class="ruJSTheory">В чем разница между setTimeout, setImmediate и process.nextTick?</div>
        </h3>

        <section>
            <div>
                <ol>
                    <li>
                        <div class="engJSTheory">Set Timeout: setTimeout() is to schedule execution of a one-time
                            callback
                            after delay
                            milliseconds.
                        </div>
                        <div class="ruJSTheory">Set Timeout: setTimeout() предназначен для планирования выполнения
                            однократного обратного
                            вызова после задержки в миллисекундах.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Set Immediate: The setImmediate function is used to execute a
                            function
                            right after the current
                            event loop finishes.
                        </div>
                        <div class="ruJSTheory">Set Immediate: функция setImmediate используется для выполнения
                            функции
                            сразу после завершения
                            текущего цикла событий.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Process NextTick: If process.nextTick() is called in a given phase,
                            all
                            the
                            callbacks passed to
                            process.nextTick() will be resolved before the event loop continues. This will block the
                            event
                            loop and create I/O Starvation if process.nextTick() is called recursively.
                        </div>
                        <div class="ruJSTheory">Process NextTick: Если на определенной фазе вызывается
                            process.nextTick(),
                            все обратные
                            вызовы, переданные в process.nextTick(), будут разрешены до продолжения цикла обработки
                            событий.
                            Это заблокирует цикл событий и создаст голодание ввода-вывода, если process.nextTick()
                            вызывается рекурсивно.
                        </div>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment429">
            <div class="engJSTheory">How do you reverse an array without modifying original array?</div>
            <div class="ruJSTheory">Как перевернуть массив, не изменяя исходный массив?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The reverse() method reverses the order of the elements in an array but it
                    mutates
                    the original array. Let's take a simple example to demonistrate this case:</p>
                <p class="ruJSTheory">Метод reverse() меняет порядок элементов в массиве, но изменяет исходный
                    массив.
                    Давайте возьмем простой пример, чтобы продемонстрировать этот случай:</p>

                <pre>
                    const originalArray = [1, 2, 3, 4, 5];
                    const newArray = originalArray.reverse();


                    console.log(newArray); // [ 5, 4, 3, 2, 1]
                    console.log(originalArray); // [ 5, 4, 3, 2, 1]
                </pre>

                <p class="engJSTheory">There are few solutions that won't mutate the original array. Let's take a
                    look:</p>
                <p class="ruJSTheory">Есть несколько решений, которые не изменят исходный массив:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Using slice and reverse methods: In this case, just invoke the
                            slice()
                            method on the array to
                            create a shallow copy followed by reverse() method call on the copy:
                        </div>
                        <div class="ruJSTheory">Использование методов slice и reverse. В этом случае просто вызовите
                            метод
                            slice() для
                            массива, чтобы создать неполную копию, а затем вызовите метод reverse() для копии:
                        </div>
                        <pre>
                            const originalArray = [1, 2, 3, 4, 5];
                            const newArray = originalArray.slice().reverse(); //Slice an array gives a new copy

                            console.log(originalArray); // [1, 2, 3, 4, 5]
                            console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using spread and reverse methods: In this case, let's use the
                            spread
                            syntax
                            (...) to create a
                            copy of the array followed by reverse() method call on the copy:
                        </div>
                        <div class="ruJSTheory">Использование методов spread и reverse. В этом случае давайте
                            воспользуемся
                            синтаксисом spread(...) для создания копии массива с последующим вызовом метода
                            reverse()
                            для копии:
                        </div>
                        <pre>
                            const originalArray = [1, 2, 3, 4, 5];
                            const newArray = [...originalArray].reverse();

                            console.log(originalArray); // [1, 2, 3, 4, 5]
                            console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using reduce and spread methods: Here execute a reducer function on
                            an
                            array elements and
                            append the accumulated array on right side using spread syntax:
                        </div>
                        <div class="ruJSTheory">Использование методов reduce и spread: здесь выполните функцию
                            reducer
                            для
                            элементов массива и добавьте накопленный массив справа, используя spread синтаксис:
                        </div>
                        <pre>
                            const originalArray = [1, 2, 3, 4, 5];
                            const newArray = originalArray.reduce((accumulator, value) => {
                                return [value, ...accumulator];
                            }, []);

                            console.log(originalArray); // [1, 2, 3, 4, 5]
                            console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using reduceRight and spread methods: Here execute a right reducer
                            function(i.e. opposite
                            direction of reduce method) on an array elements and append the accumulated array on
                            left
                            side
                            using spread syntax:
                        </div>
                        <div class="ruJSTheory">Использование методов reduceRight и spreadя: здесь выполните функцию
                            right
                            reducer (т.е.
                            направление, противоположное методу reduce) для элементов массива и добавьте
                            накопленный массив с левой стороны, используя spread синтаксис:
                        </div>
                        <pre>
                            const originalArray = [1, 2, 3, 4, 5];
                            const newArray = originalArray.reduceRight((accumulator, value) => {
                                return [...accumulator, value];
                            }, []);

                            console.log(originalArray); // [1, 2, 3, 4, 5]
                            console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Using reduceRight and push methods: Here execute a right reducer
                            function(i.e. opposite
                            direction of reduce method) on an array elements and push the iterated value to the
                            accumulator:
                        </div>
                        <div class="ruJSTheory">Использование методов reduceRight и push: здесь выполняется функция
                            right
                            reducer (т.е.
                            противоположное направлению метода reduce) для элементов массива и помещается
                            итерированное
                            значение в аккумулятор.
                        </div>
                        <pre>
                            const originalArray = [1, 2, 3, 4, 5];
                            const newArray = originalArray.reduceRight((accumulator, value) => {
                                accumulator.push(value);
                                return accumulator;
                            }, []);

                            console.log(originalArray); // [1, 2, 3, 4, 5]
                            console.log(newArray); // [ 5, 4, 3, 2, 1]
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment430">
            <div class="engJSTheory">How do you create custom HTML element?</div>
            <div class="ruJSTheory">Как создать кастомный HTML-элемент?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The creation of custom HTML elements involves two main steps:</p>
                <p class="ruJSTheory">Создание пользовательских элементов HTML включает в себя два основных
                    этапа:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Define your custom HTML element: First you need to define some
                            custom
                            class
                            by extending
                            HTMLElement class. After that define your component properties (styles,text etc) using
                            connectedCallback method. Note: The browser exposes a function called
                            customElements.define
                            inorder to reuse the element.
                        </div>
                        <div class="ruJSTheory">Определите свой собственный элемент HTML. Сначала вам нужно
                            определить
                            некоторый собственный
                            класс, расширив класс HTMLElement. После этого определите свойства вашего компонента
                            (стили,
                            текст и т. д.), используя метод linkedCallback. Примечание. Браузер предоставляет
                            функцию
                            customElements.define для повторного использования элемента.
                        </div>
                        <pre>
                            class CustomElement extends HTMLElement {
                                connectedCallback() {
                                    this.innerHTML = "This is a custom element";
                                }
                            }
                            customElements.define("custom-element", CustomElement);
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Use custome element just like other HTML element: Declare your
                            custom
                            element as a HTML tag.
                        </div>
                        <div class="ruJSTheory">Используйте пользовательский элемент так же, как и другой элемент
                            HTML:
                            объявите свой
                            пользовательский элемент как тег HTML.
                        </div>
                        <pre>
                            &lt;body&gt;
                                &lt;custom-element&gt;
                            &lt;/body&gt;
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment431">
            <div class="engJSTheory">What is global execution context?</div>
            <div class="ruJSTheory">Что такое глобальный контекст выполнения?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The global execution context is the default or first execution context that
                    is
                    created by the JavaScript
                    engine before any code is executed(i.e, when the file first loads in the browser). All the
                    global
                    code
                    that is not inside a function or object will be executed inside this global execution context.
                    Since
                    JS
                    engine is single threaded there will be only one global environment and there will be only one
                    global
                    execution context.</p>
                <p class="ruJSTheory">Глобальный контекст выполнения — это контекст по умолчанию или первый контекст
                    выполнения, который
                    создается движком JavaScript перед выполнением любого кода (т. е. при первой загрузке файла в
                    браузере).
                    Весь глобальный код, который не находится внутри функции или объекта, будет выполняться внутри
                    этого
                    глобального контекста выполнения. Поскольку движок JS является однопоточным, будет только одна
                    глобальная среда и только один глобальный контекст выполнения.</p>
                <p class="engJSTheory">For example, the below code other than code inside any function or object is
                    executed
                    inside the global
                    execution context:</p>
                <p class="ruJSTheory">Например, приведенный ниже код, отличный от кода внутри какой-либо функции или
                    объекта, выполняется
                    внутри глобального контекста выполнения.</p>

                <pre>
                    var x = 10;

                    function A() {
                        console.log("Start function A");

                        function B() {
                            console.log("In function B");
                        }

                        B();
                    }

                    A();

                    console.log("GlobalContext");
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment432">
            <div class="engJSTheory">What is function execution context?</div>
            <div class="ruJSTheory">Что такое контекст выполнения функции?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Whenever a function is invoked, the JavaScript engine creates a different
                    type of
                    Execution Context known
                    as a Function Execution Context (FEC) within the Global Execution Context (GEC) to evaluate and
                    execute
                    the code within that function.</p>
                <p class="ruJSTheory">Всякий раз, когда вызывается функция, механизм JavaScript создает другой тип
                    контекста
                    выполнения,
                    известный как контекст выполнения функции (FEC), внутри глобального контекста выполнения (GEC),
                    чтобы
                    оценить и выполнить код внутри этой функции.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment433">
            <div class="engJSTheory">What is debouncing?</div>
            <div class="ruJSTheory">Что такое debouncing?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Debouncing is a programming pattern that allows delaying execution of some
                    piece
                    of
                    code until a
                    specified time to avoid unnecessary CPU cycles, API calls and improve performance. The debounce
                    function
                    make sure that your code is only triggered once per user input. The common usecases are Search
                    box
                    suggestions, text-field auto-saves, and eliminating double-button clicks.</p>
                <p class="ruJSTheory">Устранение дрожания (дебаунсинг) — это шаблон программирования, который
                    позволяет
                    отложить выполнение
                    некоторого
                    фрагмента кода до определенного времени, чтобы избежать ненужных циклов ЦП, вызовов API и
                    повысить
                    производительность. Функция дебаунсинга гарантирует, что ваш код запускается только один раз для
                    каждого пользовательского ввода. Распространенными вариантами использования являются предложения
                    в
                    окне
                    поиска, автоматическое сохранение текстовых полей и исключение двойных нажатий кнопок.</p>
                <p class="engJSTheory">Let's say you want to show suggestions for a search query, but only after a
                    visitor
                    has finished typing
                    it. So here you write a debounce function where the user keeps writing the characters with in
                    500ms
                    then
                    previous timer cleared out using clearTimeout and reschedule API call/DB query for a new
                    time—300 ms
                    in
                    the future:</p>
                <p class="ruJSTheory">Допустим, вы хотите показывать подсказки по поисковому запросу, но только
                    после
                    того,
                    как посетитель
                    закончил его вводить. Итак, здесь вы пишете дебаунс функцию, в которой пользователь
                    продолжает писать символы в течение 500 мс, после чего предыдущий таймер очищается с помощью
                    ClearTimeout и перепланирует вызов API/запрос к базе данных на новое время — 300 мс в
                    будущем:</p>

                <pre>
                    function debounce(func, timeout = 500) {
                        let timer;
                        return (...args) => {
                          clearTimeout(timer);
                          timer = setTimeout(() => {
                            func.apply(this, args);
                          }, timeout);
                        };
                    }
                    function fetchResults() {
                        console.log("Fetching input suggestions");
                    }
                    const processChange = debounce(() => fetchResults());
                </pre>

                <p class="engJSTheory">The debounce() function can be used on input, button and window events:</p>
                <p class="ruJSTheory">Функцию debounce() можно использовать для событий input, button и window:</p>

                <pre>
                    // Input:

                    < input type="text" onkeyup="processChange()" />

                    // Button:

                    < button onclick="processChange()">Click me< /button>

                    // Windows event:

                    window.addEventListener("scroll", processChange);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment434">
            <div class="engJSTheory">What is throttling</div>
            <div class="ruJSTheory">Что такое троттлинг(throttling)</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Throttling is a technique used to limit the execution of an event handler
                    function,
                    even when this event
                    triggers continuously due to user actions. The common use cases are browser resizing, window
                    scrolling
                    etc.</p>
                <p class="ruJSTheory">Регулирование — это метод, используемый для ограничения выполнения функции
                    обработчика
                    событий, даже если
                    это событие срабатывает постоянно из-за действий пользователя. Распространенными случаями
                    использования
                    являются изменение размера браузера, прокрутка окон и т. д.</p>
                <p class="engJSTheory">The below example creates a throttle function to reduce the number of events
                    for
                    each
                    pixel change and
                    trigger scroll event for each 100ms except for the first event.</p>
                <p class="ruJSTheory">В приведенном ниже примере создается функция регулирования для уменьшения
                    количества
                    событий для каждого
                    изменения пикселя и запуска события прокрутки каждые 100 мс, за исключением первого события.</p>

                <pre>
                    const throttle = (func, limit) => {
                        let inThrottle;
                        return (...args) => {
                          if (!inThrottle) {
                            func.apply(this, args);
                            inThrottle = true;
                            setTimeout(() => (inThrottle = false), limit);
                          }
                        };
                    };
                    window.addEventListener("scroll", () => {
                        throttle(handleScrollAnimation, 100);
                    });
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment435">
            <div class="engJSTheory">What is optional chaining?</div>
            <div class="ruJSTheory">Что такое optional chaining?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">According to MDN official docs, the optional chaining operator (?.) permits
                    reading
                    the value of a
                    property located deep within a chain of connected objects without having to expressly validate
                    that
                    each
                    reference in the chain is valid.</p>
                <p class="ruJSTheory">Согласно официальной документации MDN, необязательный оператор цепочки (?.)
                    позволяет
                    читать значение
                    свойства, расположенного глубоко внутри цепочки связанных объектов, без необходимости явно
                    проверять
                    правильность каждой ссылки в цепочке.</p>
                <p class="engJSTheory">The ?. operator is like the . chaining operator, except that instead of
                    causing
                    an
                    error if a reference
                    is nullish (null or undefined), the expression short-circuits with a return value of undefined.
                    When
                    used with function calls, it returns undefined if the given function does not exist.</p>
                <p class="ruJSTheory">?. оператор похож на . оператор цепочки, за исключением того, что вместо того,
                    чтобы
                    вызывать ошибку,
                    если ссылка имеет нулевое значение (null или undefined), выражение замыкается и возвращает
                    значение undefined. При использовании с вызовами функций он возвращает значение undefined,
                    если данная функция не существует.</p>

                <pre>
                    const adventurer = {
                        name: "Alice",
                        cat: {
                            name: "Dilan",
                        },
                    };

                    const dogName = adventurer.dog?.name;
                    console.log(dogName);
                    // expected output: undefined

                    console.log(adventurer.someNonExistentMethod?.());
                    // expected output: undefined
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment436">
            <div class="engJSTheory">What is an environment record?</div>
            <div class="ruJSTheory">Что такое запись environment record?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">According to ECMAScript specification 262 (9.1): <a
                        href="https://262.ecma-international.org/12.0/#sec-environment-records" target="_blank">Environment
                    Record</a> is a specification type used to define the association of Identifiers to specific
                    variables
                    and functions, based upon the lexical nesting structure of ECMAScript code.</p>
                <p class="ruJSTheory">Согласно спецификации ECMAScript 262 (9.1): <a
                        href="https://262.ecma-international.org/12.0/#sec-environment-records" target="_blank">Environment
                    Record</a> — это тип спецификации, используемый для
                    определения связи идентификаторов с конкретными переменными и функциями на основе лексической
                    структуры
                    вложенности кода ECMAScript.</p>
                <p class="engJSTheory">Usually an Environment Record is associated with some specific syntactic
                    structure of
                    ECMAScript code
                    such as a FunctionDeclaration, a BlockStatement, or a Catch clause of a TryStatement.</p>
                <p class="ruJSTheory">Обычно Environment Record связана с некоторой конкретной синтаксической
                    структурой
                    кода ECMAScript, такой
                    как
                    FunctionDeclaration, BlockStatement или Catch TryStatement.</p>
                <p class="engJSTheory">Each time such code is evaluated, a new Environment Record is created to
                    record
                    the
                    identifier bindings
                    that are created by that code.</p>
                <p class="ruJSTheory">Каждый раз при оценке такого кода создается новая запись среды для записи
                    привязок
                    идентификаторов,
                    созданных этим кодом.</p>
                <p>Немного о environment record можно почитать на <a
                        href="https://risen.dev/ru/posts/js-in-details-part-1/"
                        target="_blank">risen.dev</a></p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment437">
            <div class="engJSTheory">How to verify if a variable is an array?</div>
            <div class="ruJSTheory">Как проверить, является ли переменная массивом?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is possible to check if a variable is an array instance using 3 different
                    ways:</p>
                <p class="ruJSTheory">Проверить, является ли переменная экземпляром массива, можно тремя разными
                    способами:</p>

                <ol>
                    <li>
                        <div class="engJSTheory">Array.isArray() method: The Array.isArray(value) utility function
                            is
                            used
                            to determine whether
                            value is an array or
                            not. This function returns a true boolean value if the variable is an array and a false
                            value if
                            it is not.
                        </div>
                        <div class="ruJSTheory">Метод Array.isArray(): Служебная функция Array.isArray(value)
                            используется
                            для определения
                            того, является ли значение массивом или нет. Эта функция возвращает истинное логическое
                            значение, если переменная является массивом, и ложное значение, если это не так.
                        </div>
                        <pre>
                            const numbers = [1, 2, 3];
                            const user = { name: "John" };
                            Array.isArray(numbers); // true
                            Array.isArray(user); //false
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">instanceof operator: The instanceof operator is used to check the
                            type
                            of
                            an array at run time.
                            It returns true if the type of a variable is an Array other false for other type.
                        </div>
                        <div class="ruJSTheory">Оператор instanceof: оператор instanceof используется для проверки
                            типа
                            массива во время
                            выполнения. Он возвращает true, если тип переменной — массив, или false для другого
                            типа.
                        </div>
                        <pre>
                            const numbers = [1, 2, 3];
                            const user = { name: "John" };
                            console.log(numbers instanceof Array); // true
                            console.log(user instanceof Array); // false
                        </pre>
                    </li>
                    <li>
                        <div class="engJSTheory">Checking constructor type: The constructor property of the variable
                            is
                            used
                            to determine
                            whether the variable Array type or not.
                        </div>
                        <div class="ruJSTheory">Проверка типа конструктора: свойство конструктора переменной
                            используется
                            для определения того,
                            является ли переменная типом Array или нет.
                        </div>
                        <pre>
                            const numbers = [1, 2, 3];
                            const user = { name: "John" };
                            console.log(numbers.constructor === Array); // true
                            console.log(user.constructor === Array); // false
                        </pre>
                    </li>
                </ol>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment438">
            <div class="engJSTheory">What is pass by value and pass by reference?</div>
            <div class="ruJSTheory">Что такое передача по значению и передача по ссылке?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Pass-by-value creates a new space in memory and makes a copy of a value.
                    Primitives
                    such as string,
                    number, boolean etc will actually create a new copy. Hence, updating one value doesn't impact
                    the
                    other
                    value. i.e, The values are independent of each other.</p>
                <p class="ruJSTheory">Передача по значению создает новое пространство в памяти и копирует значение.
                    Примитивы, такие как
                    строка, число, логическое значение и т.д., фактически создают новую копию. Следовательно,
                    обновление
                    одного значения не влияет на другое значение. Т.е. значения независимы друг от друга.</p>

                <pre>
                    let a = 5;
                    let b = a;

                    b++;
                    console.log(a, b); //5, 6
                </pre>

                <p class="engJSTheory">In the above code snippet, the value of a is assigned to b and the variable b
                    has
                    been incremented. Since
                    there is a new space created for variable b, any update on this variable doesn't impact the
                    variable
                    a.</p>
                <p class="ruJSTheory">В приведенном выше фрагменте кода значение a присваивается значению b, а
                    переменная b
                    увеличивается.
                    Поскольку для переменной b создано новое пространство, любое обновление этой переменной не
                    влияет на
                    переменную a.</p>
                <p class="engJSTheory">Pass by reference doesn't create a new space in memory but the new variable
                    adopts a
                    memory address of an
                    initial variable. Non-primitives such as objects, arrays and functions gets the reference of the
                    initiable variable. i.e, updating one value will impact the other variable.</p>
                <p class="ruJSTheory">Передача по ссылке не создает новое пространство в памяти, но новая переменная
                    принимает адрес памяти
                    исходной переменной. Непримитивы, такие как объекты, массивы и функции, получают ссылку на
                    инициализируемую переменную. Т.е. обновление одного значения повлияет на другую переменную.</p>

                <pre>
                    let user1 = {
                        name: "John",
                        age: 27,
                    };
                    let user2 = user1;
                    user2.age = 30;

                    console.log(user1.age, user2.age); // 30, 30
                </pre>

                <p class="engJSTheory">In the above code snippet, updating the age property of one object will
                    impact
                    the
                    other property due to
                    the same reference.</p>
                <p class="ruJSTheory">В приведенном выше фрагменте кода обновление свойства age одного объекта
                    повлияет
                    на
                    другое свойство
                    из-за той же ссылки.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment439">
            <div class="engJSTheory">What are the differences between primitives and non-primitives?</div>
            <div class="ruJSTheory">В чем разница между примитивами и непримитивами?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">JavaScript language has both primitives and non-primitives but there are few
                    differences between them as below:</p>
                <p class="ruJSTheory">В языке JavaScript есть как примитивы, так и непримитивы, но между ними мало
                    различий,
                    как показано ниже:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Primitives</td>
                        <td>Non-primitives</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">These types are predefined</div>
                            <div class="ruJSTheory">Эти типы предопределены</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Created by developer</div>
                            <div class="ruJSTheory">Созданы разработчиком</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">These are immutable</div>
                            <div class="ruJSTheory">Неизменяемые</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Mutable</div>
                            <div class="ruJSTheory">Изменяемые</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Compare by value</div>
                            <div class="ruJSTheory">Сравниваются по значению</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Compare by reference</div>
                            <div class="ruJSTheory">Сравниваются по ссылке</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Stored in Stack</div>
                            <div class="ruJSTheory">Хранятся в стеке</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Stored in heap</div>
                            <div class="ruJSTheory">Хранятся в куче</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Contain certain value</div>
                            <div class="ruJSTheory">Содержат определенное значение</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Can contain NULL too</div>
                            <div class="ruJSTheory">Может также содержать NULL</div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment440">
            <div class="engJSTheory">How do you create your own bind method using either call or apply method?</div>
            <div class="ruJSTheory">Как создать свой собственный метод bind, используя метод call или apply?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The custom bind function needs to be created on Function prototype inorder to
                    use
                    it
                    as other builtin
                    functions. This custom function should return a function similar to original bind method and the
                    implementation of inner function needs to use apply method call.</p>
                <p class="ruJSTheory">Пользовательскую функцию bind необходимо создать на прототипе функции, чтобы
                    использовать ее как
                    другие встроенные функции. Эта пользовательская функция должна возвращать функцию, аналогичную
                    исходному
                    методу bind, а реализация внутренней функции должна использовать вызов метода Apply.</p>
                <p class="engJSTheory">The function which is going to bind using custom myOwnBind method act as the
                    attached
                    function(boundTargetFunction) and argument as the object for apply method call:</p>
                <p class="ruJSTheory">Функция, которая будет выполнять привязку(bind) с использованием специального
                    метода
                    myOwnBind, действует как
                    присоединенная функция (boundTargetFunction), а аргумент — как объект для вызова метода
                    Apply:</p>

                <pre>
                    Function.prototype.myOwnBind = function (whoIsCallingMe) {
                        if (typeof this !== "function") {
                            throw new Error(this + "cannot be bound as it's not callable");
                        }
                        const boundTargetFunction = this;
                        return function () {
                            boundTargetFunction.apply(whoIsCallingMe, arguments);
                        };
                    };
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment441">
            <div class="engJSTheory">What are the differences between pure and impure functions?</div>
            <div class="ruJSTheory">В чем разница между чистыми и нечистыми функциями?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Some of the major differences between pure and impure function are as
                    below:</p>
                <p class="ruJSTheory">Некоторые из основных различий между чистой и нечистой функцией приведены
                    ниже:</p>

                <table class="jsTheoryTable">
                    <thead>
                    <tr>
                        <td>Чистая функция(Pure function)</td>
                        <td>Нечистая функция(Impure function)</td>
                    </tr>
                    </thead>
                    <tbody>
                    <tr>
                        <td>
                            <div class="engJSTheory">It has no side effects</div>
                            <div class="ruJSTheory">Не имеет побочных эффектов</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It causes side effects</div>
                            <div class="ruJSTheory">Вызывает побочные эффекты</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">It is always return the same result</div>
                            <div class="ruJSTheory">Всегда возвращает один и тот же результат</div>
                        </td>
                        <td>
                            <div class="engJSTheory">It returns different result on each call</div>
                            <div class="ruJSTheory">Возвращает разные результаты при каждом вызове</div>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div class="engJSTheory">Easy to read and debug</div>
                            <div class="ruJSTheory">Легко читать и дебажить</div>
                        </td>
                        <td>
                            <div class="engJSTheory">Difficult to read and debug because they are affected by
                                external
                                code
                            </div>
                            <div class="ruJSTheory">Трудно читать и дебажить, поскольку на них влияет внешний код.
                            </div>
                        </td>
                    </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment442">
            <div class="engJSTheory">What is referential transparency?</div>
            <div class="ruJSTheory">Что такое ссылочная прозрачность?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">An expression in javascript that can be replaced by its value without
                    affecting
                    the
                    behaviour of the program is called referential transparency. Pure functions are referentially
                    transparent.</p>
                <p class="ruJSTheory">Выражение в JavaScript, которое можно заменить его значением, не влияя на
                    поведение
                    программы, называется ссылочной прозрачностью. Чистые функции ссылочно прозрачны.</p>

                <pre>
                    const add = (x, y) => x + y;
                    const multiplyBy2 = (x) => x * 2;

                    //Now add (2, 3) can be replaced by 5.

                    multiplyBy2(add(2, 3));
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment443">
            <div class="engJSTheory">What are the possible side-effects in javascript?</div>
            <div class="ruJSTheory">Какие существуют побочные эффекты в JavaScript?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">A side effect is the modification of the state through the invocation of a
                    function
                    or expression. These
                    side effects make our function impure by default. Below are some side effects which make
                    function
                    impure:</p>
                <p class="ruJSTheory">Побочным эффектом является изменение состояния посредством вызова функции или
                    выражения. Эти побочные
                    эффекты по умолчанию делают нашу функцию нечистой. Ниже приведены некоторые побочные эффекты,
                    которые
                    делают функцию нечистой:</p>

                <ul>
                    <li>
                        <div class="engJSTheory">Making an HTTP request. Asynchronous functions such as fetch and
                            promise
                            are impure.
                        </div>
                        <div class="ruJSTheory">Когда делаем HTTP-запрос. Асинхронные функции, такие как fetch и
                            promise,
                            являются нечистыми.
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">DOM manipulations</div>
                        <div class="ruJSTheory">Манипуляции с DOM</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Mutating the input data</div>
                        <div class="ruJSTheory">Мутация input данных</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Printing to a screen or console: For example, console.log() and
                            alert()
                        </div>
                        <div class="ruJSTheory">Печать на экран или консоль: например, console.log() и alert().
                        </div>
                    </li>
                    <li>
                        <div class="engJSTheory">Fetching the current time</div>
                        <div class="ruJSTheory">Получение текущего времени</div>
                    </li>
                    <li>
                        <div class="engJSTheory">Math.random() calls: Modifies the internal state of Math object
                        </div>
                        <div class="ruJSTheory">Вызовы Math.random(): изменяют внутреннее состояние объекта Math.
                        </div>
                    </li>
                </ul>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment444">
            <div class="engJSTheory">What are compose and pipe functions?</div>
            <div class="ruJSTheory">Что такое функции компоновки и конвейера?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">The "compose" and "pipe" are two techniques commonly used in functional
                    programming
                    to simplify complex
                    operations and make code more readable. They are not native to JavaScript and higher-order
                    functions.
                    the compose() applies right to left any number of functions to the output of the previous
                    function.</p>
                <p class="ruJSTheory">"Компоновка"(compose) и "конвейер"(pipe) — это два метода, обычно используемые
                    в
                    функциональном
                    программировании для
                    упрощения сложных операций и повышения читабельности кода. Они не являются родными для
                    JavaScript и
                    функций высшего порядка. compose() применяет справа налево любое количество функций к выводу
                    предыдущей
                    функции.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment445">
            <div class="engJSTheory">What is module pattern?</div>
            <div class="ruJSTheory">Что такое шаблон модуля?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Module pattern is a designed pattern used to wrap a set of variables and
                    functions
                    together in a single
                    scope returned as an object. JavaScript doesn't have access specifiers similar to other
                    languages(Java,
                    Python, etc) to provide private scope. It uses IIFE (Immediately invoked function expression) to
                    allow
                    for private scopes. i.e., a closure that protect variables and methods.</p>
                <p class="ruJSTheory">Шаблон модуля — это разработанный шаблон, используемый для объединения набора
                    переменных и функций в
                    одной области, возвращаемой в виде объекта. В JavaScript нет спецификаторов доступа, подобных
                    другим
                    языкам (Java, Python и т. д.), чтобы обеспечить частную область действия. Он использует IIFE
                    (выражение
                    функции с немедленным вызовом), чтобы разрешить частные области. то есть замыкание, защищающее
                    переменные и методы.</p>
                <p class="engJSTheory">The module pattern looks like below:</p>
                <p class="ruJSTheory">Шаблон модуля выглядит следующим образом:</p>

                <pre>
                    (function () {
                        // Private variables or functions goes here.

                        return {
                          // Return public variables or functions here.
                        };
                    })();
                </pre>

                <p class="engJSTheory">Let's see an example of a module pattern for an employee with private and
                    public
                    access:</p>
                <p class="ruJSTheory">Давайте посмотрим пример шаблона модуля для сотрудника с частным и публичным
                    доступом:</p>

                <pre>
                    const createEmployee = (function () {
                        // Private
                        const name = "John";
                        const department = "Sales";
                        const getEmployeeName = () => name;
                        const getDepartmentName = () => department;

                        // Public
                        return {
                            name,
                            department,
                            getName: () => getEmployeeName(),
                            getDepartment: () => getDepartmentName(),
                        };
                    })();

                    console.log(createEmployee.name);
                    console.log(createEmployee.department);
                    console.log(createEmployee.getName());
                    console.log(createEmployee.getDepartment());
                </pre>

                <p class="engJSTheory">Note: It mimic the concepts of classes with private variables and
                    methods.</p>
                <p class="ruJSTheory">Примечание: Он имитирует концепцию классов с частными переменными и
                    методами.</p>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment446">
            <div class="engJSTheory">What is Function Composition?</div>
            <div class="ruJSTheory">Что такое композиция функций?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">It is an approach where the result of one function is passed on to the next
                    function,
                    which is passed to another until the final function is executed for the final result.</p>
                <p class="ruJSTheory">Это подход, при котором результат одной функции передается следующей функции,
                    которая
                    передается другой до тех пор, пока последняя функция не будет выполнена для окончательного
                    результата.</p>

                <pre>
                    //example
                    const double = (x) => x * 2;
                    const square = (x) => x * x;

                    var output1 = double(2);
                    var output2 = square(output1);
                    console.log(output2);

                    var output_final = square(double(2));
                    console.log(output_final);
                </pre>
            </div>
        </section>

        <h3 id="JSbasicsForEmployment447">
            <div class="engJSTheory">How to use await outside of async function prior to ES2022?</div>
            <div class="ruJSTheory">Как использовать await вне асинхронной функции до ES2022?</div>
        </h3>

        <section>
            <div>
                <p class="engJSTheory">Prior to ES2022, if you attempted to use an await outside of an async
                    function
                    resulted in a SyntaxError.</p>
                <p class="ruJSTheory">До версии ES2022 попытка использовать await вне асинхронной функции приводила
                    к
                    ошибке
                    SyntaxError.</p>

                <pre>
                    await Promise.resolve(console.log("Hello await")); // SyntaxError: await is only valid in async function
                </pre>

                <p class="engJSTheory">But you can fix this issue with an alternative IIFE (Immediately Invoked
                    Function
                    Expression) to get access to the feature.</p>
                <p class="ruJSTheory">Но вы можете решить эту проблему с помощью альтернативного IIFE (выражение
                    немедленно
                    вызываемой функции), чтобы получить доступ к этой функции.</p>

                <pre>
                    (async function () {
                        await Promise.resolve(console.log("Hello await")); // Hello await
                    })();
                </pre>

                <p class="engJSTheory">In ES2022, you can write top-level await without writing any hacks.</p>
                <p class="ruJSTheory">В ES2022 вы можете написать await верхнего уровня без каких-либо хаков.</p>

                <pre>
                    await Promise.resolve(console.log("Hello await")); //Hello await
                </pre>
            </div>
        </section>
    </div>

    <h3 id="JSlesson1">UNIT 1. СТАРТУЕМ И ПИШЕМ ПЕРВУЮ ПРОГРАММУ</h3>


    <p id="out"></p>

    <p class="queryselector1"></p>

    <p id="multiplikation"></p>

    <p id="queryselector2"></p>

    <h4>Hello
        <div><span>everyone</span></div>
    </h4>

    <div class="tree"></div>

    <div class="fraktion"></div>

    <div class="jslink"></div>

    <div class="calc"></div>

    <div class="separ"></div>
    <div class="test-1"></div>
    <div class="test-2"></div>
    <div class="s3"></div>
    <div class="s4"></div>


    <h3 id="JSlesson2">UNIT 2. ОСНОВЫ ВВОДА ДАННЫХ</h3>

    <input aria-label="text input" type="text" id="input-in" value="">
    <button id="clacbutton">клац</button>
    <div class="output"></div>
    <br>

    <input aria-label="text input" type="text" id="name1">
    <input aria-label="text input" type="text" id="secondname1">
    <button id="summbut">Приветствие</button>
    <br>

    <input aria-label="number input" type="number" id="name2">
    <input aria-label="number input" type="number" id="secondname2">
    <button id="summbut1">сложение</button>
    <div class="output1"></div>
    <br>

    <input aria-label="text input" type="text" id="seven" value="77">
    <br>
    <input aria-label="text input" type="text" id="borderinput">
    <br>
    <input aria-label="number input" type="number" id="name3">
    <input aria-label="number input" type="number" id="secondname3">
    <button id="summbut2">сложение</button>
    <div class="output2"></div>
    <br>
    <input aria-label="text input" type="text" id="textinput">
    <button id="parsebutt">парс</button>
    <br>
    <input aria-label="text input" type="text" id="name4" value="имя">
    <input aria-label="text input" type="text" id="secondname4" value="фамилия">
    <input aria-label="number input" type="number" id="userage" value="возраст">
    <input aria-label="text input" type="text" id="userjob" value="профессия">
    <button id="submitbut">отправить</button>
    <div class="output3"></div>

    <hr>

    <h3 id="JSlesson3">UNIT 3. ОПЕРАТОР IF, ELSE, SWITCH CASE - ВЫБОР В JAVASCRIPT</h3>

    <label for="age1butt">Enter age:</label>
    <input aria-label="text input" type="text" class="age1">
    <button id="age1butt">ok</button>

    <ol>
        <li>
            <p>При нажатии кнопки b-1 срабатывает функция f1. Функция должна прочитать содержимое i-1 и сравнить его
                с числом 4 (сравнение ==). Результат сравнения - true или false выведите в out-1.</p>
            <input aria-label="number input" type="number" id="i-1">
            <button id="b-1">клацай</button>
            <div class="out-1"></div>
        </li>
        <li>
            <p>Даны две переменные a21 и a22. При нажатии кнопки b-2, запускается функция f2. Функция должна
                сравнить переменные с помощью if else и вывести в out-2 число, которое больше.
                Вариант равенства переменных не рассматриваем.</p>
            <input aria-label="number input" type="number" id="a-21">
            <input aria-label="number input" type="number" id="a-22">
            <button id="b-2">клацай</button>
            <div class="out-2">Большее:</div>
        </li>
        <li>
            <p>Даны 2 input - i-31 и i-32, оба - input[type=number]. При нажатии кнопки b-3 срабатывает функция f3.
                Функция должна прочитать содержимое i-31 и i-32 в переменные и сравнить их, вывести в out-3 большее
                число.
                Проведите самостоятельный тест работы, введите пары чисел 4 и 9, 9 и 22, 5 и 111.</p>
            <input aria-label="number input" type="number" id="i-31">
            <input aria-label="number input" type="number" id="i-32">
            <button id="b-3">клацай</button>
            <div class="out-3">Большее:</div>

        </li>
        <li>
            <p>Создайте на странице input[type=number] с классом i-4, куда пользователь может ввести год своего
                рождения. Есть кнопка b-4 которая запускает функцию f4.
                Функция должна вывести в .out-4 число 1 если пользователю больше или равно 18 лет, и 0 если
                меньше.</p>
            <label>birthdate: </label>
            <input aria-label="number input" type="number" id="i-4">
            <button id="b-4">клацай</button>
            <div class="out-4">1- эдалт, 0- малолетка</div>
        </li>
        <li>
            <p>Создайте на странице input[type=number] с классом i-5, куда пользователь может ввести число. Есть
                кнопка b-5 которая запускает функцию f5.
                Функция должна вывести в .out-5 символ m если число меньше нуля, 0 если число равно нулю и 1 если
                больше.</p>
            <input aria-label="number input" type="number" id="i-5">
            <button id="b-5">клацай</button>
            <div class="out-5">больше, равно или меньше нуля(m/0/1)</div>
        </li>
        <li>
            <p>Создайте на странице input[type=number] с классом i-6, куда пользователь может ввести число. Есть
                кнопка b-6 которая запускает функцию f6.
                Функция должна вывести в .out-6 слово even если число четное и odd если нечетное. Для проверки
                четности используется целочисленный остаток от деления на 2 (оператор %).
                Если остаток равен нулю - четное, нет - нечетное.</p>
            <input aria-label="number input" type="number" id="i-6">
            <button id="b-6">клацай</button>
            <div class="out-6">четное(even) нечетное(odd)</div>
        </li>
        <li>
            <p>Даны 2 input - i-71 и i-72, оба - input[type=number]. При нажатии кнопки b-7 срабатывает функция f7.
                Функция должна число из i-71 возвести в степень i-72, вывести результат в out-7.
                Для возведения в степень можно использовать **, или Math.pow.</p>
            <input aria-label="number input" type="number" id="i-7">
            <input aria-label="number input" type="number" id="o-7">
            <button id="b-7">клац</button>
            <div class="out-7">результат возведения в степень</div>
        </li>
        <li>
            <p>Дан select s-8, который содержит 3 значения: 1, 2, 3. Дана кнопка b-8. При ее нажатии срабатывает
                функция f8.
                Функция должна получить выбранное в select число, потом с помощью switch case сравнить его
                поочередно с ‘1’, ‘2’, ‘3’.
                И если число выбрано - 1, то вывести в out-8 строку one, если 2 - two, если 3 - three.</p>
            <select aria-label="selector" id="s-8">
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
            </select>
            <button id="b-8">клац</button>
            <div class="out-8">совершенный выбор</div>
        </li>
        <li>
            <p>Создайте на странице input[type=number] с классом i-9, куда пользователь может ввести номер квартиры.
                Есть кнопка b-9 которая запускает функцию f9.
                Функция должна вывести в .out-9 номер подъезда, в котором находится квартира.</p>
            <ul>
                <li>если от 1 до 32 - то вывести цифру 1</li>
                <li>если от 33 до 43 - то вывести 2</li>
                <li>если от 44 до 64 - то 3.</li>
                <li>В противном случае, вывести 0.</li>
            </ul>

            <br>

            <input aria-label="number input" type="number" id="i-9">
            <button id="b-9">клацай</button>
            <div class="out-9">номер подъезда</div>
        </li>
        <li>
            <p>Дан select s-100. По нажатию кнопки, выведите value выбранного option в out-10.</p>
            <label>Номер квартиры:</label>
            <select aria-label="selector" id="s-10">
                <option value="1">1-32</option>
                <option value="2">33-43</option>
                <option value="3">44-64</option>
            </select>
            <button id="b-10">клац</button>
            <div class="out-10">номер подъезда:</div>
        </li>
        <li>
            <p>Дан select s-110. По изменению состояния select (событие onchange) выведите value выбранного option в
                out-11.</p>
            <label>Номер квартиры:</label>
            <select aria-label="selector" id="s-11">
                <option value="1">1-32</option>
                <option value="2">33-43</option>
                <option value="3">44-64</option>
            </select>
            <div class="out-11">номер подъезда:</div>
        </li>
        <li>
            <p>Дан input i-120. По нажатию кнопки получите значение из input в переменную, а затем выведите в out-12
                typeof полученной переменной.</p>
            <input aria-label="text input" type="text" id="i-12">
            <button id="b-12">клацай</button>
            <div class="out-12">тип текста</div>
        </li>
        <li>
            <p>Дан input i-130. В отличие от предыдущего задания - input type number. По нажатию кнопки получите
                значение из input в переменную, а затем выведите в out-13 typeof полученной переменной.
                Typeof позволяет определить тип данных. Если вы правильно все сделали - то удивительно, но тип
                данных будет string! Подумайте почему так?</p>
            <input aria-label="number input" type="number" id="i-13">
            <button id="b-13">клацай</button>
            <div class="out-13">тип текста</div>
        </li>
        <li>
            <p>Дан input-141 и input-142, type=number. Дан select s-143, который содержит две операции - +, -, *, /
                . Дана кнопка b-14, при нажатии на которую срабатывает функция f14.
                Функция выводит в out-14 результат операций выбранной в 3-м select к числам введенным в первом и
                втором input. Например выбрано 1 13 +, нужно вывести результат операции 1+13 т.е. 14.</p>
            <input aria-label="number input" type="number" id="i-14">
            <input aria-label="number input" type="number" id="o-14">
            <label>тип операции</label>
            <select aria-label="selector" id="s-14">
                <option value="+">+</option>
                <option value="-">-</option>
                <option value="*">*</option>
                <option value="/">/</option>
            </select>
            <button id="b-14">клацай</button>
            <div class="out-14">результат:</div>
        </li>
        <li>
            <p>Дан select s-151 и s-152, каждый из которых содержит 1 и 0. Дан select s-153, который содержит две
                операции - && и || . Дана кнопка b-15, при нажатии на которую срабатывает функция f15.
                Функция выводит в out-15 результат логических операций выбранных в 3 select к числам выбранным в
                первом и втором select. Например выбрано 1 1 &&, нужно вывести результат операции 1&&1 т.е. 1 или
                0.</p>
            <select aria-label="selector" id="s-15">
                <option value="1">1</option>
                <option value="0">0</option>
            </select>
            <select aria-label="selector" id="o-15">
                <option value="1">1</option>
                <option value="0">0</option>
            </select>
            <select aria-label="selector" id="z-15">
                <option value="&&">&&</option>
                <option value="||">||</option>
            </select>
            <button id="b-15">клацай</button>
            <div class="out-15">результат:</div>
        </li>
    </ol>

    <h3 id="JSlesson4">UNIT 4. РАБОТАЕМ С ФОРМАМИ: INPUT, RANGE, TEXTAREA, CHECKBOX...</h3>

    <input aria-label="password input" type="password" id="inpas" placeholder="type = 'password'">
    <button id="butinpas">accept</button>
    <div class="showinpas">password</div>
    <br>

    <input aria-label="color input" type='color' id="incol">
    <button id="butincol">accept</button>
    <div class="showincol">color id</div>
    <br>

    <input aria-label="date input" type='date' id="indate">
    <button id="butindate">accept</button>
    <div class="showindate">date</div>
    <br>

    <input aria-label="range input" type='range' id="inrange" min="0" max="200" value="50">
    <div class="showinrange">range</div>
    <br>

    <input type="checkbox" id="incheckbox" value="hallo"><label for="incheckbox">click checkbox</label>
    <button id="butcheckbox">accept</button>
    <div class="showcheckbox">checkbox</div>
    <br>

    <form id="formexamp" action="">
        <textarea aria-label="textarea" name="" id="textarea" cols="30" rows="10"></textarea>
        <input aria-label="text input" type="text" id="inptextform">
        <button id="butform">push</button>
        <div class="showform">результат</div>
    </form>

    <ol>
        <li>
            <p>Создайте button - при нажатии на него выводите alert с номером задачи.</p>
            <button id="buttinp1">Алерт: номер задачи</button>
        </li>
        <li>
            <p>Создайте input type=button - при нажатии на него выводите alert с номером задачи. Номер задачи просто
                пропишите вручную.</p>
            <input type="button" id="buttinp2" value="Алерт: номер задачи">
        </li>
        <li>
            <p>Создайте p - при нажатии на него выводите alert с номером задачи.</p>
            <p class="pinp3">Алерт: номер задачи</p>
        </li>
        <li>
            <p>Создайте input(checkbox) и button - при нажатии на кнопку выводите true если checkbox выбран и false
                если не выбран.</p>
            <input aria-label="checkbox input" type="checkbox" id="checkinp4">
            <button id="buttinp4">чекай</button>
            <div class="outinp4">out-4</div>
        </li>
        <li>
            <p>Создайте input(checkbox).i-5 и button.b-5. Для checkbox добавьте value="task-5" - при нажатии на
                кнопку b-5 выводите value checkbox если checkbox выбран и false если не выбран.
                Вывод везде в задачах, где не указано другое, осуществляется в div.out-номер задачи. В данном случае
                div.out-5.</p>
            <input aria-label="checkbox input" type="checkbox" id="checkinp5" value="task-5">
            <button id="buttinp5">чекай</button>
            <div class="outinp5">out-5</div>
        </li>
        <li>
            <p>Создайте input(hidden) и button - при нажатии на кнопку выводите value из input в div</p>
            <input type="hidden" id="checkinp6" value="8987">
            <button id="buttinp6">чекай</button>
            <div class="outinp6">out-6</div>
        </li>
        <li>
            <p>Создайте input(password) и button - при нажатии на кнопку выводите в div.outinp71 value прописанное в
                input.
                В div.outinp72 выводите 1 если длина пароля больше или равна 6 или 0 если меньше. Для подсчета
                количества символов в строке используйте length.</p>
            <input aria-label="password input" type="password" id="checkinp7">
            <button id="buttinp7">чекай</button>
            <div class="outinp71">пароль:</div>
            <div class="outinp72">0/1</div>
        </li>
        <li>
            <p>Создайте div и button. При нажатии кнопки создавайте внутри div элемент input и кнопку (innerHTML).
                Добавьте на созданную кнопку событие клик и запуск функции. Функция должна в out(2) выводить value
                созданного input.</p>
            <button id="buttinp81">создай инпут</button>
            <div class="outinp81"></div>
        </li>
        <li>
            <p>Создайте один input(radio) и button - при нажатии на button если radio выбран (активен, checked)
                выводите в div - value прописанное в input, либо 0 если не активен.</p>
            <input aria-label="radio input" type="radio" id="radioinp9" value="6572">
            <button id="buttinp9">чекай</button>
            <div class="outinp9">out-9</div>
        </li>
        <li>
            <p>Создайте input(color) и button - при нажатии на кнопку окрашивайте div выбранным цветом (имеется
                ввиду .style.background).</p>
            <input aria-label="color input" type="color" id="colorinp10">
            <button id="buttinp10">крась</button>
            <div class="outinp10">красить здесь</div>
        </li>
        <li>
            <p>Создайте input(color).colorinp111 и input(color).colorinp112- два элемента и button - при нажатии на
                кнопку присвойте цвет из первого input в value второго.</p>
            <input aria-label="color input" type="color" id="colorinp111">
            <input aria-label="color input" type="color" id="colorinp112">
            <button id="buttinp11">крась</button>
        </li>
        <li>
            <p>Создайте input(date) и button - при нажатии на кнопку выводите в div выбранную в input дату.</p>
            <input aria-label="date input" type="date" id="dateinp12">
            <button id="buttinp12">внести время</button>
            <div class="outinp12">время</div>
        </li>
        <li>
            <p>Создайте input(range). При изменении положения ползунка input выводите значение в out. Для события
                используйте oninput.</p>
            <input aria-label="range input" type="range" id="rangeinp13">
            <div class="outinp13">out-13</div>
        </li>
        <li>
            <p>Создайте text-area и button - при нажатии на кнопку выводите в out-14 текст введенный в text-area</p>
            <textarea aria-label="textarea14" id="textarea14"></textarea>
            <button id="buttinp14">клац</button>
            <div class="outinp14">out-14</div>
        </li>
        <li>
            <p>Создайте text-area input и button - при нажатии на кнопку выводите текст из input в textarea и на
                страницу в out-15.</p>
            <textarea aria-label="select15" id="textarea15"></textarea>
            <input aria-label="textinp15" type="text" id="textinp15">
            <button id="buttinp15">клац</button>
            <div class="outinp15">out-15</div>
        </li>
        <li>
            <p>Создайте select и button - при нажатии на кнопку выводите в out-16 value выбранного option из
                select16.</p>
            <select aria-label="select16" id="select16">
                <option value="one">1</option>
                <option value="two">2</option>
                <option value="five">5</option>
            </select>
            <button id="buttinp16">клац</button>
            <div class="outinp16">out-16</div>
        </li>
        <li>
            <p>Создайте select. Добавьте ему событие onchange, при наступлении которого запускается функция. Функция
                должна выводить в out-17 value выбранного в select option.</p>
            <select aria-label="select17" id="select17">
                <option value="one">1</option>
                <option value="two">2</option>
                <option value="five">5</option>
            </select>
            <div class="outinp17">out-16</div>
        </li>
        <li>
            <p>Создайте select и input. Добавьте на select событие onchange, при наступлении которого запускается
                функция. Функция должна выводить в input value выбранного в select option.</p>
            <select aria-label="select18" id="select18">
                <option value="one">1</option>
                <option value="two">2</option>
                <option value="five">5</option>
            </select>
            <input aria-label="textinp18" type="text" id="textinp18">
        </li>
        <li>
            <p>Создайте форму. В ней input(text).textinp191 и input(password).passinp192 - и кнопку button. По
                нажатию кнопки выводите значение text и password в out-19 через пробел.
                Обратите внимание на хитрость. Мы, кнопку сейчас повесили за пределами формы. Чуть позже мы
                рассмотрим почему это делали.</p>
            <form action="">
                <input aria-label="textinp191" type="text" id="textinp191">
                <input aria-label="passinp192" type="password" id="passinp192">
            </form>
            <button id="buttinp19">клац</button>
            <div class="outinp19">Task-19</div>
        </li>
        <li>
            <p>Создайте форму. В ней input(text) и input(password) - и кнопку button. По нажатию кнопки выводите
                значение из input text и password в out-20 через пробел. Используйте form.elements.</p>
            <form id="forminp20">
                <input aria-label="username" type="text" name="username">
                <input aria-label="password" type="password" name="password">
            </form>
            <button id="buttinp20">клац</button>
            <div class="outinp20"></div>
        </li>
    </ol>

    <h3 id="JSlesson5">UNIT 5. ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 1)</h3>

    <pre>
        let divfor = document.querySelectorAll('.divfor div');
        console.log(divfor);
        for (let i = 0; i < divfor.length; i = i + 1) {
            console.log(divfor[i]);
            divfor[i].style.background = 'red';
        };

    </pre>

    <div class="divfor">
        <div class="divfor">1</div>
        <div class="divfor">2</div>
        <div class="divfor">3</div>
        <div class="divfor">4</div>
        <div class="divfor">5</div>
    </div>
    <label class='radiodiv'><input type="radio" name="r" value="1" checked>один</label>
    <label class='radiodiv'><input type="radio" name="r" value="2">два</label>
    <label class='radiodiv'><input type="radio" name="r" value="3">три</label>
    <button id="radiobut">push</button>
    <br>
    <div class="divout">вывод цикла</div>

    <hr>

    <h4>Задачи:</h4>

    <ul>
        <li>Кнопка b-1 запускает функцию t1. Функция должна выводить в out-1 строку вида: 1 2 3 4 5 6 7 8 9 ... 49
            50. От 1 до 50 включительно. Разделитель - пробел. Задача решается с помощью цикла.
            <ul>
                <li>
                    <div class="showcycle">решение</div>
                    <button id="cyclebut">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-2 запускает функцию t2. Функция должна выводить в out-2 строку вида: 2 4 6 ... 122. От 2 до 122
            c шагом 2. Разделитель - пробел. Задача решается с помощью цикла.
            <ul>
                <li>
                    <div class="showcycle1">решение</div>
                    <button id="cyclebut1">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-3 запускает функцию t3. Функция должна выводить в out-3 строку вида: 25 24 23 22 ... 7. От 25
            до 7 c шагом 1. Разделитель - пробел. Задача решается с помощью цикла.
            <ul>
                <li>
                    <div class="showcycle2">решение</div>
                    <button id="cyclebut2">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-4 запускает функцию t4. Функция должна выводить в out-4 строку вида: 77_74_71_68_65_62_ ...
            _38_35_. От 77 до 35 c шагом 3. Разделитель - знак подчеркивания. Задача решается с помощью цикла.
            <ul>
                <li>
                    <div class="showcycle3">решение</div>
                    <button id="cyclebut3">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-5 запускает функцию t5. Функция должна выводить в out-5 строку вида: 1_*2_**3_*4_** ... 17_* от
            1 до 17 c шагом 1. Разделитель - знак подчеркивания и звездочка (если число нечетное, и две звездочки
            если четное). Задача решается с помощью цикла.
            <ul>
                <li>
                    <div class="showcycle4">решение</div>
                    <button id="cyclebut4">push</button>
                </li>
            </ul>
        </li>
        <li><p>Кнопка b-6 запускает функцию t6. Функция должна выводить в out-6 строку вида:</p>
            <p>******</p>
            <p>******</p>
            <p>******</p>
            <p>Задача решается с помощью цикла. В каждой итерации цикл выводит 6 звездочек без пробелов и символ
                переноса строки br. Количество строк (итераций, повторений) цикла вводит пользователь в i-6.
            <ul>
                <li>
                    <div class="showcycle5">решение</div>
                    <button id="cyclebut5">push</button>
                </li>
            </ul>
        </li>
        <li>Есть input i-7 куда пользователь может ввести число больше нуля (проверок не делаем, принимаем как
            факт). По нажатию кнопки b-7 должна запускаться функция t7, которая выводит в out-7 числа от введенного
            пользователем до нуля включительно. Разделитель пробел. Если пользователь ввел 4 и нажал кнопку, мы
            получим: 4 3 2 1 0. Задача решается с помощью цикла.
            <ul>
                <li><input aria-label="cyclein" type="number" id="cyclein">
                    <div class="showcycle6">решение</div>
                    <button id="cyclebut6">push</button>
                </li>
            </ul>
        </li>
        <li>Есть input i-81 и i-82 куда пользователь может ввести числа больше нуля (проверок не делаем, принимаем
            как факт). Считаем, что второе число всегда больше первого. По нажатию кнопки b-8 должна запускаться
            функция t8, которая выводит в out-8 числа от первого введенного до второго включительно, с шагом 1.
            Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8. Задача решается
            с помощью цикла.
            <ul>
                <li>
                    <input aria-label="fircyclein" type="number" id="fircyclein">
                    <input aria-label="seccyclein" type="number" id="seccyclein">
                    <div class="showcycle7">решение</div>
                    <button id="cyclebut7">push</button>
                </li>
            </ul>
        </li>
        <li>Есть input i-91 и i-92 куда пользователь может ввести числа. По нажатию кнопки b-9 должна запускаться
            функция t9, которая выводит в out-9 числа от меньшего введенного до большего включительно, с шагом 1.
            Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8. Eсли ввел 8 и 6,
            то получим 6 7 8. Задача решается с помощью цикла. Подсказка - вначале делаем проверку, а потом
            запускаем цикл.
            <ul>
                <li>
                    <input aria-label="fircyclein1" type="number" id="fircyclein1">
                    <input aria-label="seccyclein1" type="number" id="seccyclein1">
                    <div class="showcycle8">решение</div>
                    <button id="cyclebut8">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-10 запускает функцию t10. Функция должна выводить в out-10 четные годы от 1950 до 2000
            включительно. Разделитель - пробел. Задача решается через цикл, а четность - через шаг (равный 2).
            <ul>
                <li>
                    <div class="showcycle9">решение</div>
                    <button id="cyclebut9">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-11 запускает функцию t11. Функция должна: получить все div.div-11 перебрать их с помощью цикла.
            Обращение к div выглядит так elem[i] вывести в out-11 содержимое каждого блока. Разделитель - пробел. В
            результате должно получиться так: one 3 4 two.
            <ul>
                <li>
                    <div class="div-11">one</div>
                    <div class="div-11">3</div>
                    <div class="div-11">4</div>
                    <div class="div-11">two</div>
                    <button id="cyclebut10">push</button>
                    <div class="showcycle10"></div>
                </li>
            </ul>
        </li>
        <li>Кнопка b-12 запускает функцию t12. Функция должна: получить все div.div-12 перебрать их с помощью цикла.
            Обращение к div выглядит так elem[i] применить к каждому elem[i].style.background = ‘orange’
            <ul>
                <li>
                    <div class="div-12">Div 12</div>
                    <div class="div-12">Div 12</div>
                    <div class="div-12">Div 12</div>
                    <button id="cyclebut11">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-13 запускает функцию t13. Функция должна: получить все input.i-13 перебрать их с помощью цикла.
            Обращение к элементу выглядит так elem[i] применить к каждому elem[i].value, причем к value первого
            должно равняться 1, второго - 2, третьего - 3...
            <ul>
                <li>
                    <div class="form-control">
                        <label>Input i-13</label>
                        <input aria-label="Enter some info" type="text" placeholder="Enter some info" class="i-13">
                    </div>
                    <div class="form-control">
                        <label>Input i-13</label>
                        <input aria-label="Enter some info" type="text" placeholder="Enter some info" class="i-13">
                    </div>
                    <div class="form-control">
                        <label>Input i-13</label>
                        <input aria-label="Enter some info" type="text" placeholder="Enter some info" class="i-13">
                    </div>
                    <button id="cyclebut12">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-14 запускает функцию t14 Функция должна:
            получить все input.i-14
            перебрать их с помощью цикла. Обращение к элементу выглядит так elem[i]
            вывести в out-14 value выбранного. Проверить выбран ли элемент можно с помощью elem[i].checked.
            <ul>
                <li>
                    <fieldset>
                        <legend>Input i-14</legend>
                        <div class="form-control">
                            <label><input type="radio" name="i-14" class="i-14" checked value="333">Radio</label>
                        </div>
                        <div class="form-control">
                            <label><input type="radio" name="i-14" class="i-14" value="444">Radio</label>
                        </div>
                        <div class="form-control">
                            <label><input type="radio" name="i-14" class="i-14" value="555">Radio</label>
                        </div>
                    </fieldset>
                    <div class="showcycle13">решение</div>
                    <button id="cyclebut13">push</button>
                </li>
            </ul>
        </li>
        <li>Кнопка b-15 запускает функцию t15 Функция должна выводить следующую последовательность в out-15: 10 0 9
            1 8 2 7 3 6 4 5 5 4 6 3 7 2 8 1 9 0 10 Для вывода использовать цикл.
            <ul>
                <li>
                    <div class="showcycle14">решение</div>
                    <button id="cyclebut14">push</button>
                </li>
            </ul>
        </li>
    </ul>

    <h3 id="JSlesson6">UNIT 6. ВЛОЖЕННЫЕ ЦИКЛЫ В JAVASCRIPT (ЧАСТЬ 2)</h3>

    <div class="outstars"></div>
    <div class="outtable"></div>

    <h4>Задачи:</h4>

    <ol>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку: ***_***_***_ ,где звездочки рисуются с помощью
                внутреннего цикла от 0 до 3, а _ с помощью внешнего.</p>
            <div class="outstars1"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                1
                *_*_*_
                2
                *_*_*_
                3
                *_*_*_
            </pre>
            <p>Решить задачу с помощью вложенных циклов. Внешний цикл выводит цифры и перенос строки br, , второй
                звездочки, знак подчеркивания и знак переноса.</p>
            <div class="outstars2"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                *_*_*_
                *_*_*_
                *_*_*_
                *_*_*_
            </pre>
            <p>Решить задачу с помощью вложенных циклов. Внешний цикл выводит перенос строки br, внутренний -
                звездочки, знак подчеркивания.</p>
            <div class="outstars3"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку: 1_1 2 3 4 5 2_1 2 3 4 5 3_1 2 3 4 5</p>
            <div class="outstars4"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                101010
                101010
                101010
            </pre>
            <p>Внешний цикл выводит перенос строки br. Вложенный цикл от 0 до 6 выводит либо 0 либо 1.</p>
            <div class="outstars5"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                10x01x
                10x01x
                10x01x
            </pre>
            <p>Внешний цикл выводит перенос строки br. Вложенный цикл от 0 до 6 выводит либо 0 либо 1 либо х.</p>
            <div class="outstars6"></div>
        </li>
        <li>
            <p>Внешний цикл выводит перенос строки br. Вложенный цикл запускается от нуля до i и рисует
                звездочку.</p>
            <pre>
                *
                **
                ***
                ****
            </pre>
            <div class="outstars7"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                *****
                ****
                ***
                **
                *
            </pre>
            <p>Внешний цикл выводит перенос строки br. Вложенный цикл рисует звездочки.</p>
            <div class="outstars8"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                1
                1 2
                1 2 3
                1 2 3 4
                1 2 3 4 5
            </pre>
            <p>Внешний цикл выводит перенос строки br. Вложенный цикл рисует цифры</p>
            <div class="outstars9"></div>
        </li>
        <li>
            <p>С помощью вложенных циклов, нарисуйте строку:</p>
            <pre>
                01 02 03 04 05 06 07 08 09 10
                11 12 13 14 15 16 17 18 19 20
                21 22 23 24 25 26 27 28 29 30
                31 32 33 34 35 36 37 38 39 40
                41 42 43 44 45 46 47 48 49 50
            </pre>
            <p>Внешний цикл выводит перенос строки br и запускается от 0 до 6. Вложенный цикл рисует цифры от 0 до
                9. Обратите внимание, что первый ряд - есть ведущий нуль. Здесь все просто - проверили, если число
                меньше 10 - то конкатенируем нуль</p>
            <div class="outstars10"></div>
        </li>
    </ol>

    <h3 id="JSlesson7">UNIT 7. ФУНКЦИИ И ВСЕ О НИХ</h3>

    <ol>
        <li>
            <p>Напишите функцию t1, которая при нажатии кнопки выводит в out-1 переменную a1. let a1 = 8;</p>
            <button id="funcbutt">вывести значение</button>
            <div class="outstars11">1</div>
        </li>
        <li>
            <p>Изменим задачу 1. Сейчас она только выводит переменную в заранее заданный блок. Давайте сделаем так,
                чтобы функция, была более гибкой. Пусть теперь функция t2 возвращает переменную a2. Поскольку
                функция возвращает переменную, то имя функции со скобками (вызов функции) можно встраивать в
                выражения. Обратите внимание, как изменился вызов функции. let a2 = 8;</p>
            <button id="funcbutt1">вывести значение</button>
            <div class="outstars12"></div>
        </li>
        <li>
            <p>Наша предыдущая функция, сильно все еще зависима от внешних переменных. Давайте сделаем ее более
                универсальной. Пусть функция t3 принимает 2 параметра и выводит их произведение. Допишите код
                функции так, чтобы она возвращала произведение двух чисел, переданных ей в качестве параметра a, b.
                Протестируем функцию на двух примерах, с помощью кнопок b3-1 и b3-2.</p>
            <button id="funcbutt2">вывести значение</button>
            <button id="funcbutt3">вывести значение</button>
            <div class="outstars13"></div>
        </li>
        <li>
            <p>Напишите функцию t4 которая принимает ваш год рождения и вычисляет ваш возраст.</p>
            <input aria-label="inputbrthdate" type="number" id="inputbrthdate">
            <button id="funcbutt14">вывести возраст</button>
            <div class="outstars14"></div>
        </li>
        <li>
            <p>Напишите функцию t5, которая принимает ваше имя в качестве параметра и возвращает строку Hello name,
                где name - принятое в качестве параметра имя.</p>
            <button id="funcbutt15">вывести значение</button>
            <div class="outstars15"></div>
        </li>
        <li>
            <p>Напишите функцию, которая принимает 2 числа и возвращает случайное целое число от первого до второго
                принятого параметра.</p>
            <input aria-label="inputnumb" type="number" id="inputnumb">
            <input aria-label="inputnumb1" type="number" id="inputnumb1">
            <button id="funcbutt16">вывести значение</button>
            <div class="outstars16"></div>
        </li>
        <li>
            <p>Напишите функцию, которая возвращает случайный цвет в формате rgb(x,y,z). Где x,y,z - случайные числа
                в диапазоне [0, 255].</p>
            <button id="funcbutt17">вывести значение</button>
            <div class="outstars17">цвет</div>
        </li>
        <li>
            <p>Напишите функцию t8, которая принимает строку в качестве параметра и возвращает результат с
                очищенными пробелами в начале и вконце строки. Т.е. принимает _hello_ (где знак _ символизирует
                пробел), а возвращает hello. Для удаления пробелов - используйте trim.</p>
            <button id="funcbutt18">вывести значение</button>
            <div class="outstars18"></div>
        </li>
        <li>
            <p>Напишите функцию t9, которая принимает число и возвращает true, если число четное, и false если не
                четное.</p>
            <input aria-label="inputnumb2" type="number" id="inputnumb2">
            <button id="funcbutt19">вывести значение</button>
            <div class="outstars19"></div>
        </li>
        <li>
            <p>Создайте функцию t10, которая принимает 2 числа и возвращает большее из них. В случае равенства -
                любое из чисел.</p>
            <input aria-label="inputnumb3" type="number" id="inputnumb3">
            <input aria-label="inputnumb4" type="number" id="inputnumb4">
            <button id="funcbutt20">вывести значение</button>
            <div class="outstars20"></div>
        </li>
    </ol>

    <h3 id="JSlesson8">UNIT 8. ЦИКЛ WHILE, DO WHILE</h3>

    <div class="outstars21"></div>

    <ol>
        <li>
            <p>Кнопка запускает функцию t30. Функция должна выводить в div строку вида: 1 2 3 4 5 6 7 8 9 ... 49 50
                от 1 до 50 включительно. Разделитель - пробел. Задача решается с помощью цикла while.</p>
            <button id="funcbutt21">вывести значение</button>
            <div class="outwhile1"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t31. Функция должна выводить в div строку вида: 2 4 6 ... 122 от 2 до 122 c
                шагом 2. Разделитель - пробел. Задача решается с помощью цикла while.</p>
            <button id="funcbutt22">вывести значение</button>
            <div class="outwhile2"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t32. Функция должна выводить в div строку вида: 25 24 23 22 . . 7 от 25 до 7
                c шагом 1. Разделитель - пробел. Задача решается с помощью цикла while.</p>
            <button id="funcbutt23">вывести значение</button>
            <div class="outwhile3"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t33. Функция должна выводить в div строку вида: 77_74_71_68_65_62_ ...
                _38_35_ от 77 до 35 c шагом 3. Разделитель - знак подчеркивания. Задача решается с помощью цикла
                while.</p>
            <button id="funcbutt24">вывести значение</button>
            <div class="outwhile4"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t34. Функция должна выводить в div строку вида: 1_*2_**3_*4_** ... 17_* от 1
                до 17 c шагом 1. Разделитель - знак подчеркивания и звездочка (если число нечетное, и две звездочки
                если четное). Задача решается с помощью цикла while.</p>
            <button id="funcbutt25">вывести значение</button>
            <div class="outwhile5"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t35. Функция должна выводить в div строку вида:</p>
            <pre>
                ******

                ******

                ******

            </pre>
            <p>Задача решается с помощью цикла. В каждой итерации цикл выводит 6 звездочек без пробелов и символ
                переноса строки br. Количество строк (итераций, повторений) цикла while вводит пользователь в
                input.</p>
            <input aria-label="inputwhile6" type="number" id="inputwhile6">
            <button id="funcbutt26">вывести значение</button>
            <div class="outwhile6"></div>
        </li>
        <li>
            <p>Есть input куда пользователь может ввести число больше нуля (проверок не делаем, принимаем как факт).
                По нажатию кнопки должна запускаться функция t36, которая выводит в div числа от введенного
                пользователем до нуля включительно. Разделитель пробел. Если пользователь ввел 4 и нажал кнопку, мы
                получим: 4 3 2 1 0. Задача решается с помощью цикла while.</p>
            <input aria-label="inputwhile7" type="number" id="inputwhile7">
            <button id="funcbutt27">вывести значение</button>
            <div class="outwhile7"></div>
        </li>
        <li>
            <p>Есть два input куда пользователь может ввести числа больше нуля (проверок не делаем, принимаем как
                факт). Считаем, что второе число всегда больше первого. По нажатию кнопки должна запускаться функция
                t37, которая выводит в div числа от первого введенного до второго включительно, с шагом 1.
                Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим: 4 5 6 7 8. Задача
                решается с помощью цикла while.</p>
            <input aria-label="inputwhile8" type="number" id="inputwhile8">
            <input aria-label="inputwhile9" type="number" id="inputwhile9">
            <button id="funcbutt28">вывести значение</button>
            <div class="outwhile8"></div>
        </li>
        <li>
            <p>Есть два input куда пользователь может ввести числа. По нажатию кнопки должна запускаться функция
                t38, которая выводит в div числа от меньшего введенного до большего включительно, с шагом 1.
                Разделитель пробел. Если пользователь ввел 4 и 8 и нажал кнопку, мы получим:4 5 6 7 8
                если ввел 8 и 6, то получим 6 7 8. Задача решается с помощью цикла. Подсказка - вначале делаем
                проверку, а потом запускаем цикл while.</p>
            <input aria-label="inputwhile10" type="number" id="inputwhile10">
            <input aria-label="inputwhile11" type="number" id="inputwhile11">
            <button id="funcbutt29">вывести значение</button>
            <div class="outwhile9"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t39. Функция должна выводить в div четные годы от 1950 до 2000 включительно.
                Разделитель - пробел. Задача решается через цикл while, а четность - через шаг (равный 2).</p>
            <button id="funcbutt30">вывести значение</button>
            <div class="outwhile10"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t40. Функция должна: получить все div.divt40 перебрать их с помощью цикла
                while. Обращение к div выглядит так elem[i] вывести в div содержимое каждого блока. Разделитель -
                пробел. В результате должно получиться так: one 3 4 two</p>
            <div class="divt40">one</div>
            <div class="divt40">3</div>
            <div class="divt40">4</div>
            <div class="divt40">two</div>
            <button id="funcbutt31">вывести значение</button>
            <div class="outwhile11"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t41. Функция должна: получить все divt41 перебрать их с помощью цикла.
                Обращение к div выглядит так elem[i] применить к каждому elem[i].style.background = ‘orange’</p>
            <div class="divt41">one</div>
            <div class="divt41">3</div>
            <div class="divt41">4</div>
            <div class="divt41">two</div>
            <button id="funcbutt32">окрасить</button>
        </li>
        <li>
            <p>Кнопка запускает функцию t42. Функция должна: получить все input перебрать их с помощью цикла.
                Обращение к элементу выглядит так elem[i] применить к каждому elem[i].value, причем к value первого
                должно равняться 1, второго - 2, третьего - 3...</p>
            <input aria-label="inputwhile13" type="number" class="inputwhile13">
            <input aria-label="inputwhile13" type="number" class="inputwhile13">
            <input aria-label="inputwhile13" type="number" class="inputwhile13">
            <button id="funcbutt33">вывести значение</button>
        </li>
        <li>
            <p>Кнопка запускает функцию t43 Функция должна: получить все input перебрать их с помощью цикла.
                Обращение к элементу выглядит так elem[i] вывести в div value выбранного. Проверить выбран ли
                элемент можно с помощью elem[i].checked.</p>
            <fieldset>
                <legend>Input i-14</legend>
                <div class="form-control">
                    <label><input type="radio" name="i-14" class="radiowhile" checked value="333">Radio</label>
                </div>
                <div class="form-control">
                    <label><input type="radio" name="i-14" class="radiowhile" value="444">Radio</label>
                </div>
                <div class="form-control">
                    <label><input type="radio" name="i-14" class="radiowhile" value="555">Radio</label>
                </div>
            </fieldset>
            <button id="funcbutt34">вывести значение</button>
            <div class="outwhile14"></div>
        </li>
        <li>
            <p>Кнопка запускает функцию t44. Функция должна выводить следующую последовательность в div: 10 0 9 1 8
                2 7 3 6 4 5 5 4 6 3 7 2 8 1 9 0 10.Для вывода использовать цикл.</p>
            <button id="funcbutt35">вывести значение</button>
            <div class="outwhile15"></div>
        </li>
    </ol>


    <h3 id="JSlesson9">UNIT 9. РАБОТАЕМ С DOM</h3>

    <button class="toggle">toggle</button>
    <br>
    <p class="showstyle" data="hello">Test</p>

    <input aria-label="text input" type="text" class="gallons" placeholder="консоль">
    <div>
        <button class="gas" data="1.2">A 92</button>
        <button class="gas" data="1.6">A 95</button>
        <button class="gas" data="1.9">A 98</button>
    </div>
    <br>

    <div class="addtext">Text</div>
    <br>

    <ol>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct1. Функция присваивает блоку outdom ширину 200px,
                высоту 40px.</p>
            <button id="dombut1">Task-1</button>
            <div class="outdom1 bg-red">out-1</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct2, которая присваивает блоку out-2 класс .bg-2.</p>
            <button id="dombut2">Task-2</button>
            <div class="outdom2">out-2</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct3, которая удаляет у блока out-3 класс .bg-3.</p>
            <button id="dombut3">Task-3</button>
            <div class="outdom3 bg-3">out-3</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct4, которая делает toggle класса bg-4 для блока out-4.</p>
            <button id="dombut4">Task-4</button>
            <div class="outdom4">out-4</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct5, которая проверяет наличие класса bg-4 у блока out-4 (да,
                именно bg-4 у out-4 ). Результат - true или false, выводите в out-5.</p>
            <button id="dombut5">Task-5</button>
            <div class="outdom5">out-5</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct6, которая выводит в out-6 количество параграфов с классом
                p-6.</p>
            <p class="p-6">p-6</p>
            <p class="p-6">p-6</p>
            <p class="p-6">p-6</p>
            <p class="p-6">p-6</p>
            <p class="p-6">p-6</p>
            <p class="p-6">p-6</p>
            <button id="dombut6">Task-6</button>
            <div class="outdom6">out-6</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct7, которая присваивает блокам out-7 класс .bg-7. Обратите
                внимание, что данных блоков больше одного, следовательно нужен цикл.</p>
            <button id="dombut7">Task-7</button>
            <div class="outdom7">out-7</div>
            <div class="outdom7">out-7</div>
            <div class="outdom7">out-7</div>
        </li>
        <li>
            <p>По нажатию кнопки запускайте функцию funct8, которая делает toggle блокам out-8 класс .bg-8. Обратите
                внимание, что данных блоков больше одного, следовательно нужен цикл.</p>

            <button id="dombut8">Task-8</button>
            <div class="outdom8 bg-8">out-8</div>
            <div class="outdom8">out-8</div>
            <div class="outdom8 bg-8">out-8</div>
            <div class="outdom8">out-8</div>
        </li>
        <li>
            <p>Усложним предыдущие задачи. С помощью цикла повесьте на блоки out-9 событие клик. По клику должна
                выполняться функция funct9. Функция, должна добавлять класс bg-9 тому out-9 на котором кликнули.</p>
            <div class="outdom9">out-9</div>
            <br>
            <div class="outdom9">out-9</div>
            <br>
            <div class="outdom9">out-9</div>
            <br>
        </li>
        <li>
            <p>Усложним предыдущие задачи. С помощью цикла повесьте на блоки out-10 событие клик. По клику должна
                выполняться функция funct10. Функция, должна делать toggle класса bg-10 тому out-10 на котором
                кликнули.</p>
            <div class="outdom10 bg-10">out-10</div>
            <div class="outdom10">out-10</div>
            <div class="outdom10 bg-10">out-10</div>
            <div class="outdom10">out-10</div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct11. Функция создает через createElement div c текстом
                25 и добавляет его через append в out-11.</p>
            <button id="dombut11">Task-11</button>
            <div class="outdom11">out-11</div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct12. Функция создает через createElement div c текстом
                12 и добавляет ему класс bg-12. Созданный div добавляется в out-12.</p>
            <button id="dombut12">Task-12</button>
            <div class="outdom12">out-12</div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct13. Функция создает через createElement div c текстом
                pushMe и добавляет ему класс bg-13. Также, созданному div добавляется событие onclick, по которому
                выполняется функция funct13_1. Созданный div добавляется в out-13.</p>
            <button id="dombut13">Task-13</button>
            <div class="outdom13"></div>
            <div class="outdom14"></div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct14. Функция создает через createElement div c текстом
                14 и добавляет ему класс bg-14. Созданный div добавляется в out-14 с помощью prepend.</p>
            <button id="dombut14">Task-14</button>
            <div class="outdom14-1 bg-13">
                This is out-14
            </div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct15. Функция создает через createElement div c текстом
                15 и добавляет ему класс bg-15. Созданный div добавляется в out-15 с помощью before.</p>

            <button id="dombut15">Task-15</button>
            <div class="outdom15 bg-9">
                This is out-15
            </div>
        </li>
        <li>
            <p>Добавьте кнопку .b-16, которая запускает функцию funct16. Функция создает через createElement div c
                текстом 16 и добавляет ему класс bg-16. Созданный div добавляется в out-16 с помощью after.</p>
            <button id="dombut16">Task-16</button>
            <div class="outdom16 bg-4">
                This is out-16
            </div>
        </li>
        <li>
            <p>Добавьте кнопку .b-17, которая запускает функцию funct17. Функция создает через createElement div c
                текстом 17 и добавляет ему класс bg-17. Созданный div заменяет out-17 с помощью replaceWith.</p>
            <button id="dombut17">Task-17</button>
            <div class="outdom17 bg-13">
                This is out-17
            </div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct18. Функция с помощью getAttribute получает data-b
                атрибут с параграфа p-18 и выводит в out-18.</p>
            <p class="p-18" data-b="hello">This is p-18</p>
            <button id="dombut18">Task-18</button>
            <div class="outdom18"></div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct19. Функция с помощью getAttribute получает data-b
                атрибут с параграфов p-19 и выводит в out-19 через пробел. Обратите внимание, что элементов p-19
                больше одного.</p>

            <p class="p-19" data-b="3">This is p-19</p>
            <p class="p-19" data-b="14">This is p-19</p>
            <p class="p-19" data-b="15">This is p-19</p>
            <p class="p-19" data-b="92">This is p-19</p>

            <button id="dombut19">Task-19</button>
            <div class="outdom19"></div>
        </li>
        <li>
            <p>Добавьте кнопку, которая запускает функцию funct20. Функция с помощью setAttribute присваивает
                атрибут title="go" в out-20.</p>
            <button id="dombut20">Task-20</button>
            <div class="outdom20">out-20</div>
        </li>
    </ol>

    <h3 id="JSlesson10">UNIT 10. МАССИВЫ В JAVASCRIPT</h3>

    <p>Массив это способ представления данных в связанном виде.</p>
    <p>Длинна массива это индекс последнего элемента +1.</p>

    <p>Массив:</p>
    <div class="outmassive"></div>

    <ol>
        <li>
            <p>Создайте массив содержащий строки, числа, булевы значения. Выведите его в out-1. Вывод - по нажатию
                кнопки.</p>
            <button id="massivebut1">Task-1</button>
            <div class="outmassive1">out-1</div>
        </li>
        <li>
            <p>Создайте массив содержащий строки, числа, булевы значения. Выведите его в div.out-2. Используйте
                шаблон вывода из кода в JS. Вывод - по нажатию кнопки.</p>
            <button id="massivebut2">Task-2</button>
            <div class="outmassive2">out-2</div>
        </li>
        <li>
            <p>Создайте массив "thirdmassive = ['five', 6, true, false]", заполните его любыми значениями. Выведите
                длину массива.</p>
            <button id="massivebut3">Task-3 (длинна массива)</button>
            <div class="outmassive3">out-3</div>
        </li>
        <li>
            <p>Создайте массив "fourthmassive = ['один', 2, 'три', 4, 'пять', 6, 'семь', 8, 'девять', 10];".
                Выведите нулевой, третий, восьмой элемент массива в out-4 через пробел.</p>
            <button id="massivebut4">Task-4</button>
            <div class="outmassive4">out-4</div>
        </li>
        <li>
            <p>Создайте массив "fifthmassive = [10,20,30,40,50,60,70,80,90,100];". Выведите сумму нулевого, второго
                и третьего элементов массива (нуль, второй - и третий это индексы 0, 2, 3)</p>
            <button id="massivebut5">Task-5</button>
            <div class="outmassive5">out-5</div>
        </li>
        <li>
            <p>Создайте массив, который содержит ваше имя, знак зодиака, день рождения и месяц рождения. Выведите
                массив на страницу в out-6. Разделитель - пробел.</p>
            <button id="massivebut6">Task-6</button>
            <div class="outmassive6">out-6</div>
        </li>
        <li>
            <p>Добавьте в массив значения 'vietnam' с индексом 7 , 'turkey' с индексом 6, 'italy' с индексом 5.
                Добавление элементов сделайте в masfunct7. Выведите массив на страницу в .out-7. Разделитель -
                пробел. Обращаю ваше внимание! Это программирование. Поэтому - никаких больших букв и тому
                подобного!!!!</p>
            <button id="massivebut7">Task-7</button>
            <div class="outmassive7">out-7</div>
        </li>
        <li>
            <p>Добавьте в массив третий (индекс 3) элемент равный 3.14, 4 (индекс 4) элемент равный 17, 6 элемент
                (индекс 6) равный 5. Выведите массив в out-8. Разделитель - дефис. В out-8-1 выведите длину
                массива.</p>
            <button id="massivebut8">Task-8</button>
            <div class="outmassive8">out-8</div>
            <div class="outmassive8-1">out-8-1</div>
        </li>
        <li>
            <p>Выведите последний элемент массива. Вывод последнего элемента - реализуйте по индексу. Чтобы
                рассчитать индекс последнего элемента - используйте на длину массива.</p>
            <button id="massivebut9">Task-9</button>
            <div class="outmassive9">out-9</div>
        </li>
        <li>
            <p>Выведите сумму первого (индекс 1) и последнего массива "tenthmassive = [100, 200, 300, 400, 700,
                121];" в блок out-10. Индекс последнего элемента массива не указывайте напрямую, а вычисляйте через
                длину массива.</p>
            <button id="massivebut10">Task-10</button>
            <div class="outmassive10">out-10</div>
        </li>
        <li>
            <p>Напишите функцию, которая меняет местами второй (индекс 2) и четвертый (индекс 4) элемент массива
                "eleventhmassive = [2,3,4,5,6,7];" и выводит его в out-11. Разделитель - пробел.</p>
            <button id="massivebut11">Task-11</button>
            <div class="outmassive11">out-11</div>
        </li>
        <li>
            <p>Напишите функцию masfunct12, которая меняет местами нулевой и последний элемент массива
                "twelfthmassive = ['test', 'west', 'list', 'class', 'best'];" и выводит его в out-12. Разделитель -
                пробел. Последний элемент вычислять через длину массива.</p>
            <button id="massivebut12">Task-12</button>
            <div class="outmassive12">out-12</div>
        </li>
        <li>
            <p>Выведите массив "thirteenthmassive = ['test', 'west', 'list', 'class', 'best'];" в out-13 в формате
                индекс пробел значение пробел.</p>
            <button id="massivebut13">Task-13</button>
            <div class="outmassive13">out-13</div>
        </li>
        <li>
            <p>Используя цикл выведите на страницу массив "fourteenthmassive = [1, 2, 3, 'hello', 66];" в обратном
                порядке. Разделитель - пробел.</p>
            <button id="massivebut14">Task-14</button>
            <div class="outmassive14">out-14</div>
        </li>
        <li>
            <p>Используя цикл выведите на страницу элементы массива "fifteenthmassive = [0, 2, 5, -4, 6, 22, -9,
                -12, 8, 12, 13, 78];", которые больше нуля. Разделитель - пробел.</p>
            <button id="massivebut15">Task-15</button>
            <div class="outmassive15">out-15</div>
        </li>
        <li>
            <p>Выполните перебор массива sixteenthassive. Четные элементы добавьте в массив sixteenthassive_even,
                нечетные в sixteenthassive_odd. Добавление в массив - по индексу, а не +=!!!!!. Протестируйте задачу
                на повторный запуск! Выведите sixteenthassive_odd в out-16-odd, а sixteenthassive_even в
                out-16-even. Разделитель - пробел.</p>
            <button id="massivebut16">Task-16</button>
            <div class="outmassive16-odd">out-16-odd</div>
            <div class="outmassive16-even">out-16-even</div>
        </li>
        <li>
            <p>Используя цикл выведите в out-17 количество элементов "seventeenthmassive = [3, 0, 2, 6, 0, 1, 3, 1,
                9, 0, 2, 0];", значение которых больше 3. Для расчета используйте цикл и переменную счетчик.</p>
            <button id="massivebut17">Task-17</button>
            <div class="outmassive17">out-17</div>
        </li>
        <li>
            <p>Используя цикл выведите в out-18 максимальный элемент массива "eighteenthmassive =
                [15,24,13,78,21,4,45,67];".</p>
            <button id="massivebut18">Task-18</button>
            <div class="outmassive18">out-18</div>
        </li>
        <li>
            <p>Выведите в out-19 индекс минимального элемента в массиве "nineteenthmassive =
                [15,424,313,78,241,4,45,67];" </p>
            <button id="massivebut19">Task-19</button>
            <div class="outmassive19">out-19</div>
        </li>
        <li>
            <p>Выведите в out-20 сумму элементов в массиве "twentiethmassive = [4,5,6,7,8,9,10];"</p>
            <button id="massivebut20">Task-20</button>
            <div class="outmassive20">out-20</div>
        </li>
    </ol>


    <h3 id="JSlesson11">UNIT 11. ДОБАВЛЕНИЕ И УДАЛЕНИЕ ЭЛЕМЕНТОВ В МАССИВЕ, POP, PUSH, SPLICE</h3>

    <p>Метод "elem.push(значение)" позволяет вконец массива добавить элемент значение которого указывается в
        скобках </p>
    <p>Метод "elem.pop(значение)" позволяет в конце массива удалить элемент </p>
    <p>Оператор "delete массив[индекс]" удаляет элемент массива указанного индекса и оставляет пропуск (empty,
        тоесть указанный индекс удаляется) на его месте, при этом длинна массива не изменяется.(якобы этим
        оператором лучше пользоваться как можно меньше)</p>
    <p>Вырезание элементов вместе со смещением индексов производят с помощью метода "elem.splice(startElem,[,
        deleteCount[, item1[, item2[, ...]]]])", а так же с его помощью можно добавить новые элементы на месте
        старых.</p>
    <p>метод elem.shift()/elem.unshift(element1[, ...[, elementN]]) позволяют удалять или добавлять элементы в
        начале массива.</p>

    <ul>
        <li>
            <p>Есть массив massive1 = [33,'best', 66, 'best'], кнопка b-1, input i-1. Напишите функцию f1, которая
                при нажатии читает i-1 и добавляем его в массив. После чего выводит массив в .out-1. Поскольку мы
                будем выводить массив d1 неоднократно, то давайте вывод массива сделаем отдельной функцией, showArr
                - она подготовлена. Изучите ее - это хороший способ оптимизировать код.</p>
            <label for="inpmass1" class="form-control">Input i-1</label>
            <input id="inpmass1" type="text" class="inpmass1">
            <button id="buttmassive1">Task-1</button>
            <div class="divmassive1"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass2, которая применяет метод pop к массиву massive2 = [33,'best', 66, 'best'],
                а затем выводит его (showArr) в out-2</p>
            <button id="buttmassive2">Task-2</button>
            <div class="divmassive2">out-2</div>
        </li>
        <li>
            <p>Напишите функцию funkmass3, которая применяет метод shift к массиву massive3 = [33,'best', 66,
                'best'], а затем выводит его (showArr) в out-3</p>
            <button id="buttmassive3">Task-3</button>
            <div class="divmassive3">out-3</div>
        </li>
        <li>
            <p>Напишите функцию funkmass4, которая применяет метод push к массиву massive4 = [33,'best', 66,
                'best'], данные для массива берите из inpmass4, а затем выводит его (showArr) в out-4</p>
            <label for="inpmass4" class="form-control">Input i-4</label>
            <input id="inpmass4" type="text" class="inpmass4">
            <button id="buttmassive4">Task-4</button>
            <div class="divmassive4"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass5, которая применяет метод unshift к массиву massive5 = [33,'best', 66,
                'best'], данные для массива берите из inpmass5, а затем выводит его (showArr) в out-5</p>
            <label for="inpmass5" class="form-control">Input i-5</label>
            <input id="inpmass5" type="text" class="inpmass5">
            <button id="buttmassive5">Task-5</button>
            <div class="divmassive5"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass6, которая эмулирует работу метода push применительно к массиву massive6 =
                ['test', 5, 12]. Т.е. добавляет
                значение из inpmass6 как последний элемент в массив massive6. Эмуляция, значит, что мы получим
                результат
                аналогичный методу push без применения его. Эмуляция заключается в присвоение значения как
                последнего
                элемента массива. Как вычислить индекс последнего элемента используя длину массива - вы знаете из
                предыдущего урока. Повторный запуск функции должен также приводить к добавлению элемента.</p>
            <label for="inpmass6" class="form-control">Эмулируем push</label>
            <input id="inpmass6" type="text" class="inpmass6">
            <button id="buttmassive6">Task-6</button>
            <div class="divmassive6"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass7, которая эмулирует метод pop, т.е. удаляет последний элемент массива
                massive7 = ['china', 'india', 'brazil', 'japan', 'egypt'];. Эмулировать
                - получать результат аналогичный pop, но без применения pop. Функция может быть вызвана много раз,
                при
                этом каждый раз должен удаляться последний элемент d7.</p>
            <button id="buttmassive7">Task-7</button>
            <div class="divmassive7">out-7</div>
        </li>
        <li>
            <p>Напишите функцию funkmass8, которая эмулирует работу метода unShift - добавляем значение из inpmass8
                в начало массива massive8 = [2,'4', 12, 67, 'hello'].</p>
            <label for="inpmass8" class="form-control">Эмулируем unShift</label>
            <input id="inpmass8" type="text" class="inpmass8">
            <button id="buttmassive8">Task-8</button>
            <div class="divmassive8"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass9, которая эмулирует работу метода shift - на примере массива massive9 =
                [100, 200, 300, 400, 700, 121].</p>
            <button id="buttmassive9">Task-9</button>
            <div class="divmassive9">out-9</div>
        </li>
        <li>
            <p>Напишите функцию funkmass10, которая применяет к массиву massive10 = [3,14,15,92,6] метод reverse и
                выводит полученный массив в out-10</p>
            <button id="buttmassive10">Task-10</button>
            <div class="divmassive10">out-10</div>
        </li>
        <li>
            <p>Напишите функцию, которая получает число из input inpmass11, переводит в число, и с помощью метода
                indexOf
                проверяет наличие в массиве massive11 = [2,3,4,5,6,7]. Функция выводит в out-11 -1 если такого числа
                нет в массиве, либо его
                индекс в массиве.</p>
            <label for="inpmass11" class="form-control">indexOf</label>
            <input id="inpmass11" type="text" class="inpmass11">
            <button id="buttmassive11">Task-11</button>
            <div class="divmassive11"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass12, которая эмулирует работу метода indexOf - ищет введенное число в массиве
                massive12 = [6,62,60,70,1,5] (перебором). Если числа нет - выводит -1, если есть - его позицию в
                массиве.</p>
            <label for="inpmass12" class="form-control">эмуляция indexOf</label>
            <input id="inpmass12" type="text" class="inpmass12">
            <button id="buttmassive12">Task-12</button>
            <div class="divmassive12"></div>
        </li>
        <li>
            <p>Напишите функцию funkmass13, которая эмулирует работу метода reverse. Т.е. создает новый массив на
                основе massive13 = [6, 0, 22, 1, 4, 76] с обратным порядком элементов и выводит в out-13.</p>
            <button id="buttmassive13">Task-13</button>
            <div class="divmassive13">out-13</div>
        </li>
        <li>
            <p>Напишите функцию funkmass14, которая получает inpmass14, переводит в число, а потом заполняет массив
                massive14 так, что
                количество элементов равно введенному числу, и каждый элемент равен 1. Т.е. пользователь ввел 5,
                массив
                будет [1,1,1,1,1]. Выведите массив в out-14.</p>
            <label for="inpmass14" class="form-control">заполняем массив</label>
            <input id="inpmass14" type="text" class="inpmass14">
            <button id="buttmassive14">Task-14</button>
            <div class="divmassive14">out-14</div>
        </li>
        <li>
            <p>Напишите функцию funkmass15, которая вначале проверяет, есть ли элемент из inpmass15 в массиве
                massive15 = [0, 2, 5, -4, 6, 22, -9, -12, 8, 12, 13, 78]; (переводим в
                число), а потом - если нет - добавляет его в массив.</p>
            <label for="inpmass15" class="form-control">заполняем массив</label>
            <input id="inpmass15" type="text" class="inpmass15">
            <button id="buttmassive15">Task-15</button>
            <div class="divmassive15">out-15</div>
        </li>
        <li>
            <p>Даны два массива massive16_1 = [5,6,7,8,9]; и massive16_2 = [23,24,56,87]; - используя метод concat -
                добавьте в массив massive16 результат применения concat между массивом massive16_1 и
                massive16_2 </p>
            <button id="buttmassive16">Task-16</button>
            <div class="divmassive16">out-16</div>
        </li>
        <li>
            <p>Напишите функцию funkmass17, которая эмулирует работу метода concat. Функция должна объединять
                массивы massive17_1 = ['a', 'b', 'c', 'd'] и massive17_2 = [1,2,3,4,5] и записывать результат в
                massive17. Для эмуляции используйтe цикл. </p>
            <button id="buttmassive17">Task-17</button>
            <div class="divmassive17">out-17</div>
        </li>
        <li>
            <p>Напишите функцию funkmass18, которая получает значение из inpmass18 и проверяет есть ли такое
                значение в массиве massive18 = ['b', 'c', '45', 'e', 'z', 'y'];
                c использованием метода includes. Результат применения метода - выводится в out-18.</p>
            <label for="inpmass18" class="form-control">заполняем массив</label>
            <input id="inpmass18" type="text" class="inpmass18">
            <button id="buttmassive18">Task-18</button>
            <div class="divmassive18">out-18</div>
        </li>
        <li>
            <p>Напишите фукнцию funkmass19, которая выводит самую длинную строку maxString из массива massive19 =
                ['Your','payment','method','will','automatically','be','charged','in','advance','every'] в
                out-19.</p>
            <button id="buttmassive19">Task-19</button>
            <div class="divmassive19">out-19</div>
        </li>
        <li>
            <p>Напишите функцию funkmass20, которая применяет к массиву massive20 = [4,5,6,7,8,9,10] метод join с
                параметрами и соединяет элементы
                массива в одну строку. Результат выводит в out-20. Укажите мето так massive20.join(''). Обратите
                внимание - между апострофами нет пробела!!!</p>
            <button id="buttmassive20">Task-20</button>
            <div class="divmassive20">out-20</div>
        </li>
    </ul>


    <h3 id="JSlesson12">UNIT 12. ДВУМЕРНЫЕ МАССИВЫ</h3>

    <div class="outarray"></div>
    <div class="outarrayh"></div>

    <button id="butarray">push</button>
    <div class="outdualarray"></div>


    <ol>
        <li>
            <p>При нажатии butarray1 выполняете функцию funcarray1. Функция должна вывести в out-1 значение 55 из
                массива array1 = [12, [45, 87], [55, 13]]. Возвратите это значение.</p>
            <button id="butarray1">Task-1</button>
            <div class="divarray1">out-1</div>
        </li>
        <li>
            <p>При нажатии butarray2 выполняете функцию funcarray2. Функция должна вывести в out-2 значение hi из
                массива array2 = [[12, 'hi'], [45, 87], [55, 13]]. Возвратите это значение.</p>
            <button id="butarray2">Task-2</button>
            <div class="divarray2">out-2</div>
        </li>
        <li>
            <p>При нажатии butarray3 выполняете функцию funcarray3. Функция должна вывести в out-3 значение my из
                массива array3 = [[1, 2, 3], [3, 4, 5], [6, [7, 'my']]]. Возвратите это значение.</p>
            <button id="butarray3">Task-3</button>
            <div class="divarray3">out-3</div>
        </li>
        <li>
            <p>При нажатии butarray4 выполняете функцию funcarray4. Функция должна вывести в out-4 значение go из
                массива array4 = [[1, 2, 3], 'go', [3, 4, 5], [6, [7, 'my']]]. Возвратите это значение.</p>
            <button id="butarray4">Task-4</button>
            <div class="divarray4">out-4</div>
        </li>
        <li>
            <p>При нажатии butarray5 выполняете функцию funcarray5. Функция должна вывести в out-5 четные значения
                из массива array5 = [[1, 2], [3, 4], [5, 6], [21, 34], [44, 56]]. Для перебора используем цикл.</p>
            <button id="butarray5">Task-5</button>
            <div class="divarray5">out-5</div>
        </li>
        <li>
            <p>При нажатии butarray6 выполняете функцию funcarray6. Функция должна вывести в out-6 нечетные значения
                из массива array6 = [[1, 2], [3, 4], [5, 6], [21, 34], [44, 56]]. Для перебора используем цикл.
                Делаем по образу предыдущей задачи.</p>
            <button id="butarray6">Task-6</button>
            <div class="divarray6">out-6</div>
        </li>
        <li>
            <p>При нажатии butarray7 выполняете функцию funcarray7. Функция должна вывести в out-7 четные значения
                из массива array7 = [[1, 2, 3, 9],[3, 4, 7],[5, 6, 8, 32],[21, 34, 43],[44, 56]];. Как видите,
                вложенные массивы имеют разную длину, значит, предыдущий вариант уже не работает. Используем цикл.
                Вывод - через пробел.</p>
            <button id="butarray7">Task-7</button>
            <div class="divarray7">out-7</div>
        </li>
        <li>
            <p>При нажатии butarray8 выполняете функцию funcarray8. Функция должна вывести в out-8 нечетные значения
                из массива array8 = [[1, 2, 3, 9],[3, 4, 7],[5, 6, 8, 32],[21, 34, 43],[44, 56]];. Как видите,
                вложенные массивы имеют разную длину, значит, предыдущий вариант уже не работает. Используем цикл.
                Вывод - через пробел</p>
            <button id="butarray8">Task-8</button>
            <div class="divarray8">out-8</div>
        </li>
        <li>
            <p>При нажатии butarray9 выполняете функцию funcarray9. Функция должна вывести в out-9 значения из
                массива array9 = [[-2, 7, -3],[3, 4, -7],[-5, 6, -8, 32],[21, -34, -43],[44, -56]]; которые больше
                нуля. Используем цикл. Вывод - через пробел.</p>
            <button id="butarray9">Task-9</button>
            <div class="divarray9">out-9</div>
        </li>
        <li>
            <p>При нажатии butarray10 выполняете функцию funcarray10. Функция должна вывести в out-10 значения из
                массива array10 = [[-2, '7', -3],[3, 4, -7],[-5, 6, -8, 32, 'a'],['st', 21, -34, -43],[44, -56,
                'task']]; которые являются строкой. Используем цикл. Вывод - через пробел.</p>
            <button id="butarray10">Task-10</button>
            <div class="divarray10">out-10</div>
        </li>
        <li>
            <p>При нажатии butarray11 выполняете функцию funcarray11. Функция должна вывести в out-11 значения из
                массива array11 = [[4, 5, 6],[7, 8],[9, 10, 11, 12, 13]];, причем каждый вложенный массив должен
                идти в обратном порядке. Вывод через пробел. Т.е. вы должны получить в out-11 строку вида 6 5 4 8 7
                13 12 11 10 9. Решаем задачу двумя циклами, без reverse.</p>
            <button id="butarray11">Task-11</button>
            <div class="divarray11">out-11</div>
        </li>
        <li>
            <p>Дан массив array12 который моделирует шахматную доску. Используя цикл выведите в out-12 единицы из
                этого массива. Все действия в функции funcarray12. Функция запускается при нажатии на butarray12.
                Вывод через пробел.</p>
            <pre>
                let array12 = [
                [0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0],
                [0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0],
                [0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0],
                [0,1,0,1,0,1,0,1],
                [1,0,1,0,1,0,1,0],
                ];
            </pre>
            <button id="butarray12">Task-12</button>
            <div class="divarray12">out-12</div>
        </li>
        <li>
            <p>При нажатии butarray13 выполняете функцию funcarray13. Функция должна присвоить переменной array13
                массив эмулирующий шахматную доску. Причем массив должен создаваться с помощью циклов. Для проверки
                - выведите массив в консоль.</p>
            <button id="butarray13">Task-13</button>
            <div class="divarray13">out-13</div>
        </li>
        <li>
            <p>При нажатии butarray14 выполняете функцию funcarray14. Функция должна вывести в out-14 длины
                вложенных в array14 массивов. Через пробел.</p>
            <pre>
                let array14 = [
                    [],
                    1,0],
                    [1,0,0,0],
                    [3,4,5,6,7,8],
                    [1,2]
                };
            </pre>
            <button id="butarray14">Task-14</button>
            <div class="divarray14">out-14</div>
        </li>
        <li>
        <pre>
            let array15 = [
                [],
                [1,0],
                [1,0,0,0],
                [3,4,5,6,7,8],
                [1,2]
            };
        </pre>
            <p>При нажатии butarray15 выполняете функцию funcarray15. Функция должна вывести в out-15 длину самого
                большого вложенного массива в array15.</p>
            <button id="butarray15">Task-15</button>
            <div class="divarray15">out-15</div>
        </li>
        <li>
            <p>Впишите в переменную array16 массив, который соответствует всем условиям приведенным ниже (все
                console.log должны дать true);</p>
            <pre>
                array16 = [
                       [0,7,0,6],
                       0,
                       0,
                       8
                ];

                console.group('Task 16 ================');
                console.log(a16[3] == 8);
                console.log(a16[0][1] == 7);
                console.log(a16[0][3] == 6);
                console.groupEnd();
            </pre>
        </li>
        <li>
            <p>Впишите в переменную array17 массив, который соответствует всем условиям приведенным ниже (все
                console.log должны дать true);</p>
            <pre>
                let array17 = [];
                console.group('Task 17 ================');
                console.log(array17[3][2] == 8);
                console.log(array17[1][1] == 7);
                console.log(array17[0][2] == 6);
                console.groupEnd();
            </pre>
        </li>
        <li>
            <p>Впишите в переменную array18 массив, который соответствует всем условиям приведенным ниже (все
                console.log должны дать true);</p>
            <pre>
               let array18 = [];
               console.group('Task 18 ================');
               console.log(array18[0] == 3);
               console.log(array18[4][0] == 8);
               console.log(array18[2][1] == 12);
               console.groupEnd();
            </pre>
        </li>
        <li>
            <p>Впишите в переменную array19 массив, который соответствует всем условиям приведенным ниже (все
                console.log должны дать true);</p>
            <pre>
               let array19 = [];
               console.group('Task 19 ================');
               console.log(array19[0][0][1] == 3);
               console.log(array19[1][0][2] == 8);
               console.log(array19[2][1][0] == 12);
               console.groupEnd();
            </pre>
        </li>
        <li>
            <p>Впишите в переменную array20 массив, который соответствует всем условиям приведенным ниже (все
                console.log должны дать true);</p>
            <pre>
                let array20 = [];
                console.group('Task 20 ================');
                console.log(array20[1][1][1] == 9);
                console.log(array20[2][2] == 18);
                console.log(array20[3]== 12);
                console.groupEnd();
            </pre>
        </li>
    </ol>


    <h3 id="JSlesson13">UNIT 13. АССОЦИАТИВНЫЙ МАССИВ (ОБЪЕКТ) В JAVASCRIPT</h3>

    <p>В отличие от обычного массива, в ассоциативном массиве индексом может быть как число, так и строка.</p>

    <div class="asoarrayout"></div>

    <p>Ассоциативные массивы могут быть так же двумерными.</p>

    <ol>
        <li>
            <p>При нажатии asoarraybutt1 выполняете функцию funkasoaray1. Функция должна вывести в out-1 значение
                сохраненное под ключем two из массива asoarray1. Возвратите это значение</p>
            <pre>
                 let asoarray1 = {
                     "one" : 15,
                     "two" : 16,
                     "five" : 20
                 };
            </pre>
            <button id="asoarraybutt1">Task-1</button>
            <div class="assoarrayout1">out-1</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt2 выполняете функцию funkasoaray2. Функция должна вывести в out-2 значение hi
                из массива asoarray2. Возвратите это значение.</p>
            <pre>
                 let asoarray2 = {
                     "one" : "hello",
                     "two" : "mahai",
                     "five" : "hi"
                 };
            </pre>
            <button id="asoarraybutt2">Task-2</button>
            <div class="assoarrayout2">out-2</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt3 выполняете функцию funkasoaray3. Функция должна вывести в out-3 значение hi
                из массива asoarray3. Возвратите это значение. Вывод - через пробел.</p>
            <pre>
                 let asoarray3 = {
                     "one": "hello",
                     "two": "mahai",
                     "five": "hi",
                     "test": 21,
                     "odd": "hi",
                     "mix": "mix"
                 };
            </pre>
            <button id="asoarraybutt3">Task-3</button>
            <div class="assoarrayout3">out-3</div>
        </li>
        <li>
            <p>Давайте напишем функцию funkasoaray4, которая будет выводить массив asoarray4 в out-4 при нажатии
                кнопки asoarraybutt4. Формат вывода - ключ пробел значение перенос строки +'&#x27; &#x3C;br&#x3E;'.
                Функция должна возвращать строку в указанном формате вывода.</p>
            <pre>
                 let asoarray4 = {
                     "one": "hello",
                     "two": "mahai",
                     "five": "hi",
                     "test": 21,
                     "odd": "hi",
                     "mix": "mix"
                 };
            </pre>
            <button id="asoarraybutt4">Task-4</button>
            <div class="assoarrayout4">out-4</div>
        </li>
        <li>
            <p>Функция funkasoaray4 жестко привязана к массиву asoarray4. Это не удобно. Давайте напишем функцию
                funkasoaray5, которая принимает массив как параметр и выводит его в формате указанном в функции в
                указанный блок (как второй параметр).</p>
            <pre>
                 let asoarray5 = {
                     "one": 1,
                     "two": 2
                 };
            </pre>
            <button id="asoarraybutt5">Task-5</button>
            <div class="assoarrayout5">out-5</div>
        </li>
        <li>
            <p> Добавьте input 61 и 62. При нажатии asoarraybutt6 выполняете функцию funkasoaray6. Функция должна
                получать из input 61 ключ, а из input 62 значение и добавлять его в массив asoarray6. После этого, с
                помощью функции funkasoaray5 выводите массив a6 в out-6.</p>
            <pre>
                 let asoarray6 = {
                     "b": 17,
                     "e": 22
                 };
            </pre>
            <label for="inpasoarray61" class="form-control">Input 61</label>
            <input id="inpasoarray61" type="text" class="inpasoarray61">

            <label for="inpasoarray62" class="form-control">Input 62</label>
            <input id="inpasoarray62" type="text" class="inpasoarray62">

            <button id="asoarraybutt6">Task-6</button>
            <div class="assoarrayout6">out-6</div>
        </li>
        <li>
            <p> Добавьте input 71. При нажатии asoarraybutt7 выполняете функцию funkasoaray7. Функция должна
                получать из input 7 ключ. Если такой ключ есть в asoarray7, то выводить 1 в out-7, если нет - 0.</p>
            <pre>
                 let asoarray7 = {
                     "b": 17,
                     "e": 22
                 };
            </pre>
            <label for="inpasoarray71" class="form-control">Input 71</label>
            <input id="inpasoarray71" type="text" class="inpasoarray71">
            <button id="asoarraybutt7">Task-7</button>
            <div class="assoarrayout7">out-7</div>
        </li>
        <li>
            <p>Добавьте input 81. При нажатии asoarraybutt8 выполняете функцию funkasoaray8. Функция должна выводить
                значение в out-8, если ключ введенный в input 8 есть в массиве, если нет - 0.</p>
            <pre>
                 let asoarray8 = {
                     "b": 17,
                     "e": 22
                 };
            </pre>
            <label for="inpasoarray81" class="form-control">Input 81</label>
            <input id="inpasoarray81" type="text" class="inpasoarray81">
            <button id="asoarraybutt8">Task-8</button>
            <div class="assoarrayout8">out-8</div>
        </li>
        <li>
            <p>Добавьте input 91. При нажатии asoarraybutt9 выполняете функцию funkasoaray9. Функция должна вывести
                в out-9 все ключи
                массива asoarray9, которые содержат значение, равное значению в input 91. Вывод через пробел. Если
                значений -
                нет, то выводить пустую строку.</p>
            <pre>
                 let asoarray9 = {
                     "b": 17,
                     "e": 22,
                     "j": 17,
                     "k": 22,
                     "d": 54
                 };
            </pre>
            <label for="inpasoarray91" class="form-control">Input 91</label>
            <input id="inpasoarray91" type="text" class="inpasoarray91">
            <button id="asoarraybutt9">Task-9</button>
            <div class="assoarrayout9">out-9</div>
        </li>
        <li>
            <p>Давайте напишем полезную функцию funkasoaray10, которая проверяет есть ли значение в ассоциативном
                массиве. Фукнция
                должна возвращать true если есть, и false если нет. Массив и значение передавать функции в качестве
                параметров.</p>
            <pre>
                 let asoarray9 = {
                    "k": 22,
                    "d": 54,
                    "m": 22,
                 };
            </pre>
            <button id="asoarraybutt10">Task-10</button>
            <div class="assoarrayout10">out-10</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt11 выполняете функцию funkasoaray11. Функция должна получить ключ из input
                11-1 и удалить запись из массива
                asoarray11 с таким ключем. После этого вывести массив в out-11. Для вывода используйте функцию
                funkasoaraycommon.</p>
            <pre>
                 let asoarray11 = {
                     "b": 17,
                     "e": 22,
                     "j": 17,
                     "k": 22,
                     "d": 54
                 };
            </pre>
            <label for="inpasoarray11-1" class="form-control">Input 11-1</label>
            <input id="inpasoarray11-1" type="text" class="inpasoarray11-1">
            <button id="asoarraybutt11">Task-11</button>
            <div class="assoarrayout11">out-11</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt12 выполняете функцию funkasoaray12. Функция должна получить значение из
                input 12 и удалить запись из
                массива asoarray12 с таким значением. После этого вывести массив в out-12. Для вывода используйте
                функцию funkasoaraycommon.</p>
            <pre>
                 let asoarray12 = {
                     "b": 17,
                     "e": 22,
                     "j": 17,
                     "k": 22,
                     "d": 17,
                 };
            </pre>
            <label for="inpasoarray12-1" class="form-control">Input 12-1</label>
            <input id="inpasoarray12-1" type="text" class="inpasoarray12-1">
            <button id="asoarraybutt12">Task-12</button>
            <div class="assoarrayout12">out-12</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt13 выполняете функцию funkasoaray13. Функция должна в out-13 выводить сумму
                значений массива asoarray13
                (только числа).</p>
            <pre>
                 let asoarray13 = {
                     'prim': 'hello',
                     'one': 4,
                     'testt': 'vodoley',
                     'ivan': 6
                 };
            </pre>
            <button id="asoarraybutt13">Task-13</button>
            <div class="assoarrayout13">out-13</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt14 выполняете функцию funkasoaray14. Функция должна в out-14 выводить нулевые
                (по индексу) элементы
                вложенных массивов в asoarray14. Вывод через пробел.</p>
            <pre>
                 let asoarray14 = {
                     'prim': [1, 2, 23],
                     'one': [3, 4, 5],
                     'testt': [6, 7, 8],
                     'ivan': [9, 10]
                 };
            </pre>
            <button id="asoarraybutt14">Task-14</button>
            <div class="assoarrayout14">out-14</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt15 выполняете функцию funkasoaray15. Функция должна в out-15 выводить
                элементы вложенных массивов в
                asoarray15. Вывод через пробел.</p>
            <pre>
                 let asoarray15 = {
                     'prim': [1, 2, 23],
                     'one': [3, 5],
                     'testt': [6, 7, 8],
                     'ivan': [9, 10]
                 };
            </pre>
            <button id="asoarraybutt15">Task-15</button>
            <div class="assoarrayout15">out-15</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt16 выполняете функцию funkasoaray16. Функция должна в out-16 выводить
                элементы name вложенных
                массивов в asoarray16. Вывод через пробел.</p>
            <pre>
                 let asoarray16 = {
                     "iis8sj": {
                         "name": "Ivan",
                         "age": 27,
                     },
                     "iiss7j": {
                         "name": "Petr",
                         "age": 26,
                     },
                     "s3s8sj": {
                         "name": "Serg",
                         "age": 47,
                     },
                 };
            </pre>
            <button id="asoarraybutt16">Task-16</button>
            <div class="assoarrayout16">out-16</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt17 выполняете функцию funkasoaray17. Функция должна в out-17 выводить
                элементы name вложенных
                массивов в asoarraz17 для которых age > 30. Вывод через пробел.</p>
            <pre>
                 let asoarray16 = {
                     "iis8sj": {
                         "name": "Ivan",
                         "age": 27,
                     },
                     "iiss7j": {
                         "name": "Petr",
                         "age": 26,
                     },
                     "s3s8sj": {
                         "name": "Serg",
                         "age": 47,
                     },
                 };
            </pre>
            <button id="asoarraybutt17">Task-17</button>
            <div class="assoarrayout17">out-17</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt18 выполняете функцию funkasoaray18. Функция должна в out-18 вывести станции
                метро из массива asoarray18 той
                ветки, которую пользователь ввел в input 18. Вывод станций - через пробел. Если ветка не найдена
                выводите
                пустую строку.</p>
            <pre>
                 let asoarray18 = {
                     "red": ['Akademmistechko', 'Nyvky', 'Universytet', 'Lisova'],
                     "blue": ['Minska', 'Obolon', 'Pochaina', 'Holosiivska'],
                     "green": ['Syrets', 'Zoloti Vorota', 'Klovska', 'Vidubichi']
                 };
            </pre>
            <label for="inpasoarray18" class="form-control">Input 18</label>
            <input id="inpasoarray18" type="text" class="inpasoarray18">
            <button id="asoarraybutt18">Task-18</button>
            <div class="assoarrayout18">out-18</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt19 выполняете функцию funkasoaray19. Функция должна в out-19 вывести цвет
                ветки станции которую
                пользователь ввел в input 19. Пользователь может вводить текст как с большой, так и с маленькой
                буквы. Если
                ветка не найдена - выводите пустую строку.</p>
            <pre>
                 let asoarray19 = {
                     "red": ['Akademmistechko', 'Nyvky', 'Universytet', 'Lisova'],
                     "blue": ['Minska', 'Obolon', 'Pochaina', 'Holosiivska'],
                     "green": ['Syrets', 'Zoloti Vorota', 'Klovska', 'Vidubichi']
                 };
            </pre>
            <label for="inpasoarray19" class="form-control">Input 19</label>
            <input id="inpasoarray19" type="text" class="inpasoarray19">
            <button id="asoarraybutt19">Task-19</button>
            <div class="assoarrayout19">out-19</div>
        </li>
        <li>
            <p>При нажатии asoarraybutt20 выполняете функцию funkasoaray20. Функция должна в out-20 вывести название
                станции которые
                содержат переход на другую ветку. Такие станции маркируются 2. Вывод через пробел.</p>
            <pre>
                 let asoarray20 = {
                     "red": [['Akademmistechko', 1], ['Nyvky', 0], ['Universytet', 3], ['Lisova', 1]],
                     "blue": [['Minska', 1], ['Obolon', 0], ['Pochaina', 2], ['Holosiivska', 0]],
                     "green": [['Syrets', 1], ['Zoloti Vorota', 2], ['Klovska', 0], ['Vidubichi', 1]],
                 };
            </pre>
            <button id="asoarraybutt20">Task-20</button>
            <div class="assoarrayout20">out-20</div>
        </li>
    </ol>


    <h3 id="JSlesson14">UNIT 14. ПРАКТИКА ПО МАССИВАМ - ПОЛУЧАЕМ ПРОГНОЗ ПОГОДЫ ПО API</h3>

    <div class="container-api">
        <div class="pricing-table row">
            <div class="package featured">
                <p class="package-name">City</p>
                <p class="price">Degrees&deg;</p>
                <p class="disclaimer">Clouds</p>
                <ul class="features">
                    <li>Icon</li>
                </ul>
                <p class="visibility">Visibility</p>
                <p class="wind">Wind speed</p>
                <button id="button-api">Go</button>
                <input id="inputapitext" type="text" aria-label="City Name" class="inputapitext" placeholder="City Name">
                <input id="inputapinumber" aria-label="City id" type="number" class="inputapinumber" placeholder="City id">
            </div>
        </div>
    </div>


    <h3 id="JSlesson15">UNIT 15. SET В JAVASCRIPT</h3>

    <ol>
        <li>
            <p> Создайте set set1. Добавьте в него три элемента 'h', 'b', 'o', 'h'. Добавление делайте через add.
                Выведите в консоль/(или в out-1 используя конвертацию в массив) получившийся набор (set) s1.</p>
            <div class="outset1">out-1:</div>
        </li>
        <li>
            <p>При нажатии buttset2 выполняете функцию funcset2. Функция должна добавить в набор s2 элементы,
                которые пользователь вводит в inputset2. Функция должна выводить в консоль set2 после каждого
                добавления элемента.</p>
            <label for="inputset2" class="form-control">Input 2</label>
            <input id="inputset2" type="text" class="inputset2">
            <button id="buttset2">Task-2</button>
            <div class="outset2">out-2:</div>
        </li>
        <li>
            <p>При нажатии buttset3 выполняете функцию funcset3. Функция должна удалить из набора set3(['one',
                'two', 'four']) строку, которую пользователь вводит в inputset3. Функция должна выводить в консоль
                set3 после каждого удаления элемента.</p>
            <label for="inputset3" class="form-control">Input 3</label>
            <input id="inputset3" type="text" class="inputset3">
            <button id="buttset3">Task-3</button>
            <div class="outset3">out-3:</div>
        </li>
        <li>
            <p>При нажатии buttset4 выполняете функцию funcset4. Функция должна проверить наличие в наборе
                set4(['a', 'b', 'c', 'z']) строки введенной пользователем в inputset4. Если строка есть - то вывести
                в out-4 true. Если нет - false.</p>
            <label for="inputset4" class="form-control">Input 4</label>
            <input id="inputset4" type="text" class="inputset4">
            <button id="buttset4">Task-4</button>
            <div class="outset4">out-4:</div>
        </li>
        <li>
            <p>При нажатии buttset5 выполняете функцию funcset5. Функция должна вывести в out-5 количество элементов
                в наборе set5(['a', 'b', 'c', 'z', 'a2', 'b2', 'c2', 'z2']).</p>
            <button id="buttset5">Task-5</button>
            <div class="outset5">out-5:</div>
        </li>
        <li>
            <p>При нажатии buttset6 выполняете функцию funcset6. Функция должна вывести в out-6 число уникальных
                элементов в массиве arrayforset6 = [1, 2, 3, 4, 5, 3, 4, 5, 2, 4, 5, 3, 24, 5, 2, 4, 56, 4, 3, 2,
                335, 2, 23, 41, 3, 4, 1, 1, 4, 2, 2, 4, 5, 24, 5, 3, 22, 56]. Решение должно использовать set.</p>
            <button id="buttset6">Task-6</button>
            <div class="outset6">out-6:</div>
        </li>
        <li>
            <p>При нажатии buttset7 выполняете функцию funcset7. Функция должна получать из inputset7 значение
                пароля и проверять, чтобы пользователь в
                строке пароля использовал не повторяющиеся символы. Если символы уникальны, а длина пароля больше
                (строго) 6 то
                выводите в out-7 число 1. Если есть повторяющиеся символы, или длина меньше или равна 6 - то
                выводите 0. Для проверки
                уникальности символов используйте Set.</p>
            <label for="inputset7" class="form-control">Input 7</label>
            <input id="inputset7" type="text" class="inputset7">
            <button id="buttset7">Task-7</button>
            <div class="outset7">out-7:</div>
        </li>
        <li>
            <p>При нажатии buttset8 выполняете функцию funcset8. Функция должна перебрать набор set8([1, 2, 3, 4, 5,
                3, 4, 7, 9, 5, 7, 8, 9, 23, 45, 5, 2, 4, 5, 3, 24, 5, 2, 4, 56, 4, 3, 2, 335, 2, 23, 41, 3, 4, 1, 1,
                4, 2, 2, 4, 5, 24, 5, 3, 22, 56]) и добавить в массив setarray8 только числа больше 5. Выведите
                массив в консоль.</p>
            <button id="buttset8">Task-8</button>
            <div class="outset8">out-8:</div>
        </li>
        <li>
            <p>При нажатии buttset9 выполняете функцию funcset9. Функция должна принимать набор our_set в качестве
                параметра, преобразовывать его
                в строку, причем после каждого символа строки должен быть пробел. Функция должна возвращать
                результирующую строку. В нашем примере результат должен быть 9 8 7 6 5 </p>
            <button id="buttset9">Task-9</button>
            <div class="outset9">out-9:</div>
        </li>
        <li>
            <p>При нажатии buttset10 выполняете функцию funcset10. Функция должна принимать набор set10 в качестве
                параметра и выводить его в
                указанный элемент. Элемент указывается как второй параметр функции funcset10. Вывод значений - через
                пробел.</p>
            <button id="buttset10">Task-10</button>
            <div class="outset10">out-10:</div>
        </li>
        <li>
            <p>При нажатии buttset11 выполняете функцию funcset11. Функция должна преобразовать массив array11 в
                набор. И выводить в консоль. Изучите
                вывод получившегося набора. Разберитесь почему так происходит.</p>
            <button id="buttset11">Task-11</button>
        </li>
        <li>
            <p>При нажатии buttset12 выполняете функцию funcset12. Функция должна преобразовать строку str12 в
                массив, так, что каждая буква -
                отдельный элемент массива. Потом создать набор на основе массива и возвратить его.</p>
            <button id="buttset12">Task-12</button>
        </li>
        <li>
            <p>При нажатии buttset13 выполняете функцию funcset13. Функция должна преобразовать строку str13 в
                массив, причем каждая буква -
                отдельный элемент массива. Потом создать набор на основе массива. Затем, перебирая набор по
                элементам, найти сколько раз
                каждый символ встречается в исходном массиве. Результат - в виде объекта типа { символ : количество,
                символ : количество } вывести в консоль и возвратить.</p>
            <p>Пример результата для строки 'Hello ho'</p>
            <p>{ "H" : 1, 'e' : 1, 'l' : 2, "o" : 2, " ": 1}</p>
            <button id="buttset13">Task-13</button>
        </li>
    </ol>


    <h3 id="JSlesson16">UNIT 16. ПЕРЕБОР МАССИВОВ: FOR, FOR IN, FOR OF</h3>

    <span>
        <div class="newelem">1</div>
        <div class="newelem">2</div>
        <div class="newelem">3</div>
    </span>

    <ol>
        <li>
            <p>При нажатии buttfor1 выполняете функцию funcfor1. Функция перебирает массив arrayfor1 = [5, 7, 9, 11,
                13, 15]; c помощью цикла for (let i. Выведите на страницу в out-1 формате значение+пробел.</p>
            <button id="buttfor1">Task-1</button>
            <div class="outfor1">out-1:</div>
        </li>
        <li>
            <p>При нажатии buttfor2 выполняете функцию funcfor2. Функция перебирает массив arrayfor2 = [5, 7, 9, 11,
                13, 15]; c помощью цикла for (let i. Выведите на страницу в .out-2 формате индекс+пробел+значение +
                &lt;br&gt;.</p>
            <button id="buttfor2">Task-2</button>
            <div class="outfor2">out-2:</div>
        </li>
        <li>
            <p>При нажатии buttfor3 выполняете функцию funcfor3. Функция получает div.buttfor3 со страницы с помощью
                getElementsByClassName и в каждый записывает число 3, перезаписывая содержимое div</p>
            <button id="buttfor3">Task-3</button>
            <div class="outfor3">out-3</div>
            <div class="outfor3">out-3</div>
            <div class="outfor3">out-3</div>
        </li>
        <li>
            <p>При нажатии buttfor4 выполняете функцию funcfor4. Функция получает div.buttfor4 со страницы с помощью
                querySelectorAll и в каждый дописывает число 4.</p>
            <button id="buttfor4">Task-4</button>
            <div class="outfor4">out-4</div>
            <div class="outfor4">out-4</div>
            <div class="outfor4">out-4</div>
        </li>
        <li>
            <p>При нажатии buttfor5 выполняете функцию funcfor5. Функция должна с помощью for of перебрать массив
                arrayfor5 = [3,4,5,2,1,7,8,2,4,6,8,11,23,17]; и возвратить новый массив куда входят элементы из
                arrayfor5 большие 7.</p>
            <button id="buttfor5">Task-5</button>
            <div class="outfor5">out-5:</div>
        </li>
        <li>
            <p>При нажатии buttfor6 выполняете функцию funcfor6. Функция должна превратить массив arrayfor6 =
                [[1,2], [3,4], [5,6]]; в одномерный. Результат вывести в out-6 через пробел.</p>
            <button id="buttfor6">Task-6</button>
            <div class="outfor6">out-6:</div>
        </li>
        <li>
            <p>При нажатии buttfor7 выполняете функцию funcfor7. Функция должна переиндексировать массив arrayfor7 =
                [{ id : 23, name: 'Ivan'}, {id: 45, name : 'Petr'}];. Что имеется ввиду. Сейчас у нас обычный
                массив,
                который содержит вложенные объекты. Вам необходимо сделать из arrayfor7 объект, где ключи - значения
                id из вложенных массивов, а значения - имя (т.е { 23 : Ivan, 45 : Petr}.
                Функция должна возвращать результирующий массив.</p>
            <button id="buttfor7">Task-7</button>
        </li>
        <li>
            <p>При нажатии buttfor8 выполняете функцию funcfor8. Функция должна переиндексировать массив arrayfor8 =
                [ { id : 23, name: 'Ivan'}, {id: 45, name : 'Petr'}];. Что имеется ввиду. Сейчас у нас обычный
                массив,
                который содержит вложенные объекты. Вам необходимо сделать из arrayfor8 массив, который будет
                содержать только числовые id. Т.е. [23, 45]. Функция должна возвращать результирующий массив.</p>
            <button id="buttfor8">Task-8</button>
        </li>
        <li>
            <p>При нажатии buttfor9 выполняете функцию funcfor9. Функция должна возвращать в out-9 самый большой
                индекс из вложенных в arrayfor9 = [ [4,3,2], [2,5], [0,0,0,0,0]]; массивов.
                В данном случае это 4. Т.е. самый большой вложенный массив это [0,0,0,0,0], а в нем самый большой
                индекс 4.</p>
            <button id="buttfor9">Task-9</button>
            <div class="outfor9">out-9:</div>
        </li>
        <li>
            <p>При нажатии buttfor10 выполняете функцию funcfor10. Функция должна преобразовывать массив arrayfor10
                в ассоциативный массив вида {4: 4, 6: 6, 9: 9, hello : "hello"} и возвращать полученный массив.</p>
            <button id="buttfor10">Task-10</button>
        </li>
        <li>
            <p>При нажатии buttfor11 выполняете функцию funcfor11. Функция должна c помощью for in перебрать объект
                arrayfor11 и вывести в out-11 только те значения, которые больше 10. Вывод - через пробел.</p>
            <pre>
                let arrayfor11 = {
                        one : 11,
                        two : 7,
                        three : 13,
                        four: 0
                    }
            </pre>
            <button id="buttfor11">Task-11</button>
            <div class="outfor11">out-11:</div>
        </li>
        <li>
            <p>При нажатии buttfor12 выполняете функцию funcfor12. Функция должна c помощью for of перебрать
                arrayfor12 = [4,5,6,7]; и вывести в out-12 через пробел.</p>
            <button id="buttfor12">Task-12</button>
            <div class="outfor12">out-12:</div>
        </li>
        <li>
            <p>При нажатии buttfor13 выполняете функцию funcfor13. Функция должна c помощью for of перебрать
                arrayfor13 = 'testone' и вывести по символу в out-13 через пробел.</p>
            <button id="buttfor13">Task-13</button>
            <div class="outfor13">out-13:</div>
        </li>
        <li>
            <p>При нажатии buttfor14 выполняете функцию funcfor14. Функция должна c помощью for of перебрать
                arrayfor14([4,5,6]) и вывести по элементам в out-14 через пробел.</p>
            <button id="buttfor14">Task-14</button>
            <div class="outfor14">out-14:</div>
        </li>
        <li>
            <p>При нажатии buttfor15 выполняете функцию funcfor15. Функция должна получить NodeList элементов out-15
                c помощью document.querySelectorAll,
                затем c помощью for of перебрать полученную коллекцию элементов .out-15 записать внутрь них число 15
                (затерев содержимое).</p>
            <button id="buttfor15">Task-15</button>
            <div class="outfor15">out-15:</div>
            <div class="outfor15">out-15:</div>
            <div class="outfor15">out-15:</div>
            <div class="outfor15">out-15:</div>
        </li>
    </ol>

    <h3 id="JSlesson17">UNIT 17. МЕТОДЫ МАССИВОВ: MAP, FILTER ( ЧАСТЬ 1)</h3>

    <ol>
        <li>
            <p>Дан массив array1 = [4, 5, 6, 7, 12, 34, 56, 78, 90, 11] - с помощью map переберите массив и создайте
                новый массив array1_res куда добавьте элементы данного массива умноженные на 2. Возвратите массив
                array1_res.</p>
            <button id="buttmap1">task 1</button>
            <div class="outmap1">out-1:</div>
        </li>
        <li>
            <p>Дан массив array2 = [2,3,4,5,10,11,12] - с помощью map переберите массив и создайте массив array2_res
                куда добавьте элементы данного массива возведенные во вторую степень. Возвратите массив array2_res.
                Действия должны запускаться при вызове функции t2.</p>
            <button id="buttmap2">task 2</button>
            <div class="outmap2">out-2:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter3 = [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите массив и
                создайте массив array3_res куда добавьте все элементы приведенные к числу. Возвратите array3_res.
                Действия должны запускаться при вызове функции funcfilter3.</p>
            <button id="buttmap3">task 3</button>
            <div class="outmap3">out-3:</div>
        </li>
        <li>
            <p>Следующая задача проще будет решаться через метод forEach, который мы изучим во второй части урока!
                Сейчас мы делаем костыль, для отработки навыков работы с map. Дан массив a4 =
                [4,"3",6,7,"12",34,"56",78,90,11] - с помощью map переберите массив и создайте массив a4_res куда
                добавьте ТОЛЬКО числа из массива a4. Возвратите a4_res. Действия должны запускаться при вызове
                функции funcfilter4.</p>
            <button id="buttmap4">task 4</button>
            <div class="outmap4">out-4:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter5 = [3, 14, 15, 92]. C помощью filter переберите массив и создайте
                arrayfilter5_res, который содержит только четные числа из arrayfilter5. Возвратите arrayfilter5_res.
                Действия должны запускаться при вызове функции funcfilter5.</p>
            <button id="buttmap5">task 5</button>
            <div class="outmap5">out-5:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter6 = [3, 14, 15, 92, "6", "5", "hello", 32]. C помощью filter переберите массив
                b6 и создайте массив arrayfilter6_res, который содержит только числа из arrayfilter6. Возвратите
                arrayfilter6_res. Действия должны запускаться при вызове функции funcfilter6.</p>
            <button id="buttmap6">task 6</button>
            <div class="outmap6">out-6:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter7 = ["php-7", "html", "css", 92, "6", "5", "hello", 32]. C помощью filter
                переберите массив arrayfilter7 и создайте arrayfilter7_res, который содержит только строки из
                arrayfilter7, длина которых больше 3. Возвратите arrayfilter7_res. Действия должны запускаться при
                вызове функции funcfilter7.</p>
            <button id="buttmap7">task 7</button>
            <div class="outmap7">out-7:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter8 = [3, 14, 15, 92, "6", "5", "hello", 32]. С помощью filter, переберите массив
                arrayfilter8 и создайте массив arrayfilter8_res, который содержит индексы четных элементов.
                Возвратите arrayfilter8_res. Действия должны запускаться при вызове функции funcfilter8.</p>
            <button id="buttmap8">task 8</button>
            <div class="outmap8">out-8:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter9 = [3, "hello", 4, "world", 5, "hi"]. С помощью filter, переберите массив
                arrayfilter9 и создайте массив arrayfilter9_num и arrayfilter9_string, которые содержат первый -
                числа из arrayfilter9, второй - строки. Задачу решите с помощью filter. Действия должны запускаться
                при вызове функции funcfilter9.</p>
            <button id="buttmap9">task 9</button>
            <div class="outmap91">числа:</div>
            <div class="outmap92">строки:</div>
        </li>
        <li>
            <p>Дан массив arrayfilter10 = [[1,2,3],[3,4,6],[4,5,7],[8,9,3]]. С помощью filter переберите массив и
                создайте arrayfilter10_res, в который входят вложенные массивы содержащие цифру 3. Возвратите
                arrayfilter10_res. Действия должны запускаться при вызове функции funcfilter10.</p>
            <button id="buttmap10">task 10</button>
            <div class="outmap10">out-10:</div>
        </li>
    </ol>


    <h3 id="JSlesson18">UNIT 18. МЕТОДЫ МАССИВОВ: JOIN, SPLIT, FOREACH ( ЧАСТЬ 2)</h3>

    <ol>
        <li>
            <p>Дан массив arrayforeach1 = [4,5,6,7,12,34,56,78,90,11] - с помощью forEach переберите массив и
                создайте новый массив arrayforeach1_res куда добавьте элементы данного массива умноженные на 2.
                Действия должны запускаться при вызове функции funcforeach1.</p>
            <button id="buttforeach1">task 1</button>
            <div class="outforeach1">out-1:</div>
        </li>
        <li>
            <p>Дан массив arrayforeach2 = [2,3,4,5,10,11,12] - с помощью forEach переберите массив и создайте новый
                массив arrayforeach2_res куда добавьте элементы данного массива деленные на 2.
                Действия должны запускаться при вызове функции funcforeach2.</p>
            <button id="buttforeach2">task 2</button>
            <div class="outforeach2">out-2:</div>
        </li>
        <li>
            <p>Дан массив arrayforeach3 = [2, "hello", 3, "hi", 4, "Mazai"] - с помощью forEach переберите массив и
                создайте новый массив arrayforeach3_res куда добавьте элементы данного массива являющиеся числом.
                Запускаться решение должно при вызове функции funcforeach3.</p>
            <button id="buttforeach3">task 3</button>
            <div class="outforeach3">out-3:</div>
        </li>
        <li>
            <p>На странице созданы 3 span.taskforeach-4 c атрибутом data. С помощью forEach переберите их и добавьте
                атрибуты в массив arrayforeach4_res. Запускаться решение должно при вызове функции funcforeach4.</p>
            <button id="buttforeach4">task 4</button>
            <div>
                <span class="taskforeach-4" data="1">One span with data</span>
                <span class="taskforeach-4" data="34">Two span with data</span>
                <span class="taskforeach-4" data="66">Thre span with data</span>
            </div>
            <div class="outforeach4">out-4:</div>
        </li>
        <li>
            <p>На странице созданы 3 p.task-5 c атрибутом data. С помощью forEach переберите их и добавьте событие
                клик.
                Напишите функцию funcforeach5, которая будет запускаться при клике и добавлять атрибут data
                элемента, по которому кликнули в массив arrayforeach5_res.</p>
            <div>
                <p class="taskforeach-5" data="1">One p with data</p>
                <p class="taskforeach-5" data="34">Two p with data</p>
                <p class="taskforeach-5" data="66">Three p with data</p>
            </div>
        </li>
        <li>
            <p>Дана строка str6="helloworld" - преобразуйте ее в массив и присвойте arrayforeach6_res. Выведите на
                страницу. Запускаться решение должно при вызове функции funcforeach6.</p>
            <button id="buttforeach6">task 6</button>
            <div class="outforeach6">out-6:</div>
        </li>
        <li>
            <p>Дана строка str7="hello world hi mazai" - преобразуйте ее в массив и разбейте по словам. Причем слова
                не должны содержать пробелов и присвойте arrayforeach7_res.
                Выведите на страницу. Запускаться решение должно при вызове функции funcforeach7.</p>
            <button id="buttforeach7">task 7</button>
            <div class="outforeach7">out-7:</div>
        </li>
        <li>
            <p>Дан массив arrayjoin8 = [1,2,66,77,15] - преобразуйте ее в строку. Разделитель - дефис. Результат
                присвойте arrayjoin8_res. Запускаться решение должно при вызове функции funcforeach8.</p>
            <button id="buttforeach8">task 8</button>
            <div class="outforeach8">out-8:</div>
        </li>
        <li>
            <p>Дан массив arrayforeach9 = [[hi, mahai], [test, best]] - преобразуйте его в строку. Разделитель -
                дефис. Результат присвойте arrayforeach9_res. Запускаться решение должно при вызове функции
                funcforeach9.
                Допускается лишний дефис в конце строки!!!</p>
            <button id="buttforeach9">task 9</button>
            <div class="outforeach9">out-9:</div>
        </li>
        <li>
            <p>Дан массив arrayforeach10 = {name: ivan, age: 15, sex: 1, id: 45} - преобразуйте его в GET строку
                (GET параметры). Найдите описание, что такое GET строка самостоятельно.
                Разделитель - амперсанд. Результат присвойте arrayforeach10_res. Запускаться решение должно при
                вызове функции funcforeach10. Допускается лишний амперсанд в конце строки!!!</p>
            <button id="buttforeach10">task 10</button>
            <div class="outforeach10">out-10:</div>
        </li>
    </ol>


    <h3 id="JSlesson19">UNIT 19. СОБЫТИЯ МЫШИ В JAVASCRIPT</h3>

    <p>В javascript существуют следующие события:</p>
    <ol>
        <li>
            oncklick - клик левой кнопки мыши
        </li>
        <li>
            ondblclick - двойной клик левой кнопки мыши
        </li>
        <li>
            oncontextmenu - клик правой кнопки мыши(который инициирует вызов контекстного меню), "return false" в
            функции которая вызывается данным событием отменяет контекстное меню.
        </li>
        <li>
            onmousemove - при движении курсора мыши.
        </li>
        <li>
            onmouseenter - при вхождении курсора мыши в область елемента.
        </li>
        <li>
            onmouseleave - при покидании курсора мыши области елемента.
        </li>
        <li>onmousedown/onmouseup - комбинация событий работающая на зажатии и отжатии левой кнопки мыши.</li>
    </ol>

    <div class="unit19container">
        <div class="blockone">one</div>
        <div class="blocktwo">two</div>
        <hr>
        <div class="blockthree">three</div>
        <hr>
        <progress id="progressbar" value="10" max="100"></progress>
        <button id="buttprogress">progress</button>
    </div>

    <hr>


    <ol>
        <li>
            <p>Добавьте на блок .blockevent1 событие клик и по клику запуск функции funcevent1. Функция должна
                возвращать и выводить
                на экран содержимое блока (только текст). Вывод осуществляется в out-1. </p>
            <div class="blockevent event1">task-1</div>
            <div class="outevent1">out-1:</div>
        </li>
        <li>
            <p>Добавьте на блок .blockevent2 событие клик и по клику запуск функции funcevent2. Функция должна
                возвращать true или false в зависимости от того,
                нажата ли клавиша alt или нет в момент клика. Также, выводите на экран результат. Вывод
                осуществляется в out-2.</p>
            <div class="blockevent event2">task-2</div>
            <div class="outevent2">out-2:</div>
        </li>
        <li>
            <p>Добавьте на блок .event3 событие клик. При клике - увеличивайте ширину блока на 5px. Каждый клик -
                увеличение ширины на 5px. 10 кликов - на 50px. Ширину выводите в out-3.</p>
            <div class="blockevent event3">task-3</div>
            <div class="outevent3">out-3:</div>
        </li>
        <li>
            <p>Добавьте на блок .blockevent4 событие двойной клик и по двойному клику запуск функции funcevent4.
                Функция должна возвращать и выводить на экран содержимое блока (только текст). Вывод осуществляется
                в out-4.</p>
            <div class="blockevent event4">task-4</div>
            <div class="outevent4">out-4:</div>
        </li>
        <li>
            <p>Дан блок .blockevent5.active. Добавьте на него событие двойной клик, по которому удалется класс
                active если он есть и добавляется если такого класса нет.</p>
            <div class="blockevent event5 active">task-5</div>
        </li>
        <li>
            <p>Дан блок .event6 и список .ulevent6. При двойном клике на блоке скрывайте .ulevent6 если он показан и
                показывайте если скрыт. Скрытие и показ делайте через добавление - удаление класса .hideevent6.</p>
            <div class="blockevent event6">task-6</div>
            <ul class="ulevent6">
                <li>one</li>
                <li>two</li>
                <li>three</li>
            </ul>
            <div class="outevent6">
            </div>
        </li>
        <li>
            <p>Дан блок .event7. При клике правой кнопкой мыши на блоке добавляйте ему класс .active. При повторном
                клике - удаляйте.</p>
            <div class="blockevent event7">task-7</div>
        </li>
        <li>
            <p>Дано .checkboxevent8. Повесьте на него событие onchange при котором на документе отключается клик
                правой кнопкой мыши если checkbox выбран и отключает если не выбран.</p>
            <div class="form-control">
                <label>
                    <input type="checkbox" class="checkboxevent8"> включить / выключить
                    контекстное меню
                </label>
            </div>
        </li>
        <li>
            <p>Дан блок .event9. Внутри блока - изображение 1.png. При клике правой кнопкой мыши - меняйте
                изображение на 2.png. Надеюсь вы догадаетесь изменить только src изображения?</p>
            <div class="blockeventimage event9">task-9
                <img src="JSImages/jojo1.png" width="150px" alt="">
            </div>
        </li>
        <li>
            <p>Дан блок .event10. Внутри блока - изображение 1.png. При наведении мыши (mouseenter) - меняйте
                изображение на 2.png.</p>
            <div class="blockeventimage event10">task-10
                <img src="JSImages/jojo1.png" width="150px" alt="">
            </div>
        </li>
        <li>
            <p>Дан блок .event11. Внутри блока - изображение 1.png. При наведении мыши (mouseenter) - меняйте
                изображение на 2.png. При уведении мыши - mouseleave - возвращайте исходное изображение.</p>
            <div class="blockeventimage event11">task-11
                <img src="JSImages/jojo1.png" alt="jojo1" width="150px">
            </div>
        </li>
        <li>
            <p>Дан блок .event12. Добавьте на него событие mousedown - при нажатии кнопки мыши - добавляйте ему
                класс active.</p>
            <div class="blockevent event12">task-12</div>
        </li>
        <li>
            <p>Дан блок .event13. Добавьте на него событие mousedown - при нажатии кнопки мыши - добавляйте ему
                класс active. Добавьте ему событие mouseup - при отпускании мыши - удаляйте класс active.</p>
            <div class="blockevent event13">task-13</div>
        </li>
        <li>
            <p>Дан блок .event14. При нажатии кнопки buttevent14 добавляйте к нему событие onclick - которое, при
                клике добавляем блоку event14 класс active.</p>
            <div class="blockevent event14">task-14</div>
            <button id="buttevent14">press</button>
        </li>
        <li>
            <p>Дан блок .event15. Добавьте на него событие onmousemove. При каждом движении мыши увеличивайте число
                внутри на 1.</p>
            <div class="blockevent event15">0</div>
        </li>
        <li>
            <p>Дан блок .event16. Добавьте на него событие onmousemove. При каждом движении мыши увеличивайте ширину
                блока на 1px.</p>
            <div class="blockevent event16">task-16</div>
        </li>
        <li>
            <p>Дано 2 кнопки - butteven17_on и butteven17_off. Напишите фукнции funcevent17On и funcevent17Off
                которые включают и отключают событие move в задании 16.</p>
            <button id="buttevent17_on">ON</button>
            <button id="buttevent17_off">OFF</button>
        </li>
        <li>
            <p>Дан блок .event18. Напишите фукнцию funcevent18 которая выводит в данный блок его ширину при событии
                onmouseenter.</p>
            <div class="blockevent event18">task-18</div>
        </li>
        <li>
            <p>Дан блок .event19. Напишите фукнцию funcevent19 которая выводит в данный блок его классы при событии
                onmouseout.</p>
            <div class="blockevent event19 active">task-19</div>
        </li>
        <li>
            <p>Дан элемент progress. Напишите фукнцию funcevent20 которая увеличивает его value на 1 при каждом
                событии mousemove внутри progress.</p>
            <progress id="progressbar20" value="10" max="100"></progress>
        </li>
    </ol>


    <h3 id="JSlesson20">UNIT 20. СОБЫТИЯ КЛАВИАТУРЫ В JAVASCRIPT</h3>

    <p>Срабатывание input: onchange(срабатывает когда инпут теряет фокус); oninput(срабатывает при любом
        изменении);</p>
    <p>onkeypress - срабатывает только на цифрах и буквах ентере пробеле и некоторых вспомогательных клавишах</p>
    <div>
        <input aria-label="inputkb" type="text" class="inputkb">
    </div>
    <div>
        <label for="checkboxkb">CapsLock</label>
        <input id="checkboxkb" type="checkbox" class="checkboxkb">
    </div>
    <br>
    <div>
        <input aria-label="inputkbfalse" type="text" class="inputkbfalse">
    </div>


    <ol>
        <li>
            <p>Дан input .inputkb1. Напишите функцию funckb1, которая выводит в .outkb1 символ и возвращает его. Во
                всех
                последующих задачах - работаем с латиницей и цифрами. </p>
            <input aria-label="inputkb1" type="text" class="inputkb1">
            <div class="outkb1"></div>
        </li>
        <li>
            <p>Дан input .inputkb2. Напишите функцию funckb2, которая выводит в .outkb2 код символа и возвращает
                его. </p>
            <input aria-label="inputkb2" type="text" class="inputkb2">
            <div class="outkb2"></div>
        </li>
        <li>
            <p>Дан input .inputkb3. Напишите функцию funckb3, которая выводит на страницу true если введен символ и
                false если
                цифра. Для определения - используйте код клавиши. </p>
            <input aria-label="inputkb3" type="text" class="inputkb3">
            <div class="outkb3"></div>
        </li>
        <li>
            <p>Дан input .inputkb4. Напишите функцию funckb4, которая выводит в .outkb4 только символы в нижнем
                регистре. Т.е.
                ввели ab4Bci в out получаем ab4bci. </p>
            <input aria-label="inputkb4" type="text" class="inputkb4">
            <div class="outkb4">
            </div>
        </li>
        <li>
            <p>Дан input .inputkb5. Напишите функцию funckb5, которая выводит в .outkb5 все вводимые символы в
                верхнем регистре.
                Т.е. пользователь ввел AbCd и функция выведет ABCD. </p>
            <input aria-label="inputkb5" type="text" class="inputkb5">
            <div class="outkb5"></div>
        </li>
        <li>
            <p>Дан input .inputkb6. Напишите функцию funckb6, которая выводит в .inputkb6 только символы в нижнем
                регистре. </p>
            <input aria-label="inputkb6" type="text" class="inputkb6">
            <div class="outkb6"></div>
        </li>
        <li>
            <p>Дан input .inputkb7. Напишите функцию funckb7, которая выводит в .outkb7 случаный символ из массива
                arraykb7 при каждом
                вводе символа.</p>
            <input aria-label="inputkb7" type="text" class="inputkb7">
            <div class="outkb7"></div>
        </li>
        <li>
            <p>Дан input .inputkb8. Напишите функцию funckb8, которая выводит в .outkb8 вводимый в input текст, но
                заменяет i на 1,
                o на 0, l на 7.</p>
            <input aria-label="inputkb8" type="text" class="inputkb8">
            <div class="outkb8"></div>
        </li>
        <li>
            <p>Дан input .inputkb9. Напишите функцию funckb8, выводит в .outkb9 количество нажатых клавиш стрелка
                вниз.</p>
            <input aria-label="inputkb9" type="text" class="inputkb9">
            <div class="outkb9"></div>
        </li>
        <li>
            <p>Дан input .inputkb10 и изображение 1.png. Добавьте событие на input, при нажатии клавиш стрелка
                вправо и
                стрелка влево увеличивать ширину изображения. Клавиши стрелка вверх и вниз - увеличивать высоту
                изображения. Одно нажатие клавиши - 1px.</p>
            <input aria-label="inputkb10" type="text" class="inputkb10">
            <div class="blockeventimage divkb10">
                <img src="/JSImages/jojo1.png" width="150px" height="80px" alt="" id="jojoimg10">
            </div>
            <div class="outkb10"></div>
        </li>
        <li>
            <p>1. Выполните в html верстку клавиш клавиатуры. Сверстайте – блок цифровых клавиш от 1 до 0. И ряд
                клавиш q – p. Добавьте
                клавишу левый shift, левый alt, левый ctrl, пробел, enter.</p>
            <p>2. Добавьте на input .inputkb11 событие onkeypress или onkeyup или onkeydown ( по вашему выбору).
                Когда событие происходит (
                ввод символа в input) необходимо подсветить ( добавить класс active) клавише с таким символом. Со
                всех остальных клавиш
                – удалить класс active.</p>
            <p>3. Если вводится следующий символ – повторить удаление active и подсветить клавишу с введенным
                символом.</p>
            <p>4. Ограничения проекта – тестируются только указанные клавиши в латинской раскладке. Комбинации
                клавиш не тестируются.
                Т.е. нажиматься shift+A, ctrl+shift – не будут. Все символы вводятся в нижнем регистре.</p>
            <div class="containerkb11">
                <div>1</div>
                <div>2</div>
                <div>3</div>
                <div>4</div>
                <div>5</div>
                <div>6</div>
                <div>7</div>
                <div>8</div>
                <div>9</div>
                <div>0</div>
                <div>ShiftLeft</div>
                <div>ControlLeft</div>
            </div>
            <div class="containerkb11">
                <div>q</div>
                <div>w</div>
                <div>e</div>
                <div>r</div>
                <div>t</div>
                <div>y</div>
                <div>u</div>
                <div>i</div>
                <div>o</div>
                <div>p</div>
                <div>AltLeft</div>
                <div>Space</div>
                <div>Enter</div>
            </div>
            <input aria-label="inputkb11" type="text" class="inputkb11">
            <div class="outkb11"></div>
        </li>
    </ol>


    <h3 id="JSlesson21">UNIT 21. КРАТКИЙ ОБЗОР TOUCH СОБЫТИЙ</h3>

    <div class="touchevent"></div>
    <div class="outtouchevent"></div>
    <div class="outtouchevent-1"></div>
    <div class="outtouchevent-2"></div>
    <br>
    <div class="touchevent-1"></div>
    <div class="outtouchevent-3"></div>


    <ol>
        <li>
            <p>Создайте блок diveventmove1. Добавьте на него событие touchstart. Выведите в outeventmove1 слово
                touch
                если событие сработает. </p>
            <div class="diveventmove1 blockevent"></div>
            <div class="outeventmove1"></div>
        </li>
        <li>
            <p>Создайте блок diveventmove2. Добавьте на него событие touchstart. Выведите в outeventmove2 число
                срабатываний события.</p>
            <div class="diveventmove2 blockevent"></div>
            <div class="outeventmove2"></div>
        </li>
        <li>
            <p>Создайте блок diveventmove3_1 и diveventmove3_2. Добавьте на них событие touchstart. Выведите в
                outeventmove3 номер блока 1 или 2
                на котором сработало событие.</p>
            <div class="diveventmove3_1 blockevent">1</div>
            <div class="diveventmove3_2 blockevent">2</div>
            <div class="outeventmove3"></div>
        </li>
        <li>
            <p>Создайте блок diveventmove4. И кнопку butteventmove4. При нажатии кнопки - добавляйте событие
                ontouchstart на блок diveventmove4.
                При событии происходит вывод текста touch в outeventmove4. </p>
            <button id="butteventmove4">Task-4</button>
            <div class="diveventmove4 blockevent"></div>
            <div class="outeventmove4"></div>
        </li>
        <li>
            <p> Дана кнопка butteventmove5. При ее нажатии очищайте событие ontouchstart на блоке diveventmove4.</p>
            <button id="butteventmove5">Task-5</button>

        </li>
        <li>
            <p> Добавьте событие ontouchend на diveventmove4. При его срабатывании выведите в outeventmove6 слово
                touchend.</p>
            <div class="outeventmove6"></div>
        </li>
        <li>
            <p> Дан блок diveventmove7. Добавьте событие touch, при срабатывании которого окрашивайте блок в красный
                цвет.</p>
            <div class="diveventmove7 blockevent">7</div>
        </li>
        <li>
            <p>Дан блок diveventmove8. Добавьте на него событие touch, которое при срабатывании окрашивает блок
                случаным цветом
                из массива arrayeventmove8=[red, green, blue, orange, pink, yellow] </p>
            <div class="diveventmove8 blockevent"></div>
            <div class="outeventmove8"></div>
        </li>
        <li>
            <p>Дан блок diveventmove9. Добавьте событие ontouch. Выводите количество одновременных касаний в
                outeventmove9.</p>
            <div class="diveventmove9 blockevent"></div>
            <div class="outeventmove9">
            </div>
        </li>
        <li>
            <p>Дан блок diveventmove10. Добавьте на него событие touchmove. При срабатывании события - увеличивайте
                его ширину
                на 1.</p>
            <div class="diveventmove10 blockevent">10</div>
            <div class="outeventmove10"></div>
        </li>
        <li>
            <p> Дан блок diveventmove11. Добавьте на него событие touch. При срабатывании выводите радиус события
                radiusX,
                radiusY.</p>
            <div class="diveventmove11 blockevent">11</div>
            <div class="outeventmove11">
            </div>
        </li>
        <li>
            <p>Изучите html код внутри diveventmove12-wrapper.</p>
            <p>1. Добавьте на кнопку next событие click, touch так, чтобы при событии запускалась функция
                nextFunction и
                активным становилось изображение следующее за выделенным классом active-img (рамкой).
                Соответственно, на
                активном изображении появляется рамка, а остальные - лишаются рамки.</p>
            <p>2. Добавьте на кнопку prev событие click, touch так, чтобы при событии запускалась функция
                prevFunction и
                активным становилось изображение до выделенного классом active-img (рамкой). Соответственно, на
                активном
                изображении появляется рамка, а остальные - лишаются рамки.</p>
            <p>3. Учтите краевые эффекты - когда мы доходим до конца или начала, то нажатие кнопки должно приводить
                к
                перемещению рамки в начало или конец изображений.</p>
            <p>4. Добавьте кнопку reset (функция resetFunction), нажатие которой сбрасывает активное изображение на
                нулевое. </p>
            <p>5. Добавьте во все действия следующее - в изображении img-12-max заменяется src на активную. Т.е.
                произошло событие - заменилась главная картинка.</p>

            <div class="diveventmove12-wrapper">
                <img src="images/1.png" alt="" class="img-12-min active-img">
                <img src="images/2.png" alt="" class="img-12-min">
                <img src="images/3.png" alt="" class="img-12-min">
                <img src="images/4.png" alt="" class="img-12-min">
                <img src="images/5.png" alt="" class="img-12-min">
                <img src="images/6.png" alt="" class="img-12-min">
            </div>
            <div class="diveventmove12-max">
                <img src="images/1.png" alt="" class="img-12-max"></div>
            <p class="img-12-text"></p>
            <button class="prev12">Prev</button>
            <button class="next12">Next</button>
            <button class="reset12">Reset</button>
            <div class="outeventmove12"></div>
        </li>
    </ol>


    <h3 id="JSlesson22">UNIT 22. ОБРАБАТЫВАЕМ ОШИБКИ С ПОМОЩЬЮ TRY CATCH</h3>

    <div class="divtry"></div>


    <ol>
        <li>
            <p>Добавьте в код функции try catch так, чтобы вместо ошибки выводилось в tryout1 цифра 1.</p>
            <button id="trybutt1">Task-1</button>
            <div class="tryout1"></div>
        </li>
        <li>
            <p>Добавьте в код функции try catch так, чтобы вместо ошибки был вывод результата в tryout2.</p>
            <button id="trybutt2">Task-2</button>
            <div class="tryout2"></div>
        </li>
        <li>
            <p>Добавьте в код функции try catch так, чтобы вместо ошибки был вывод результата в tryout3. Если его
                нет - создавайте в коде.
                т.е. вы не знаете будет или нет он в html.</p>
            <button id="trybutt3">Task-3</button>
        </li>
        <li>
            <p>Дана переменная atry4. В переменную делается push. Используя try catch отловите ошибки если они есть.
                Если ошибка вывести в tryout4 число 0. Если не ошибка - то результирующий массив через пробел.</p>
            <button id="trybutt4">Task-4</button>
            <div class="tryout4"></div>
        </li>
        <li>
            <p>Добавьте try, catch, finnaly так, чтобы в tryout5 выводился 0 при ошибки. А в tryout5-1 всегда
                выводилось слово 'finnaly';</p>
            <button id="trybutt5">Task-5</button>
            <div class="tryout5"></div>
            <div class="tryout5-1"></div>
        </li>
    </ol>


    <h3 id="JSlesson23">UNIT 23. LOCALSTORAGE. СОХРАНЯЕМ ВСЕ</h3>

    <p>При сохранении массива в localStorage, он преобразуется в строку!!!</p>
    <p>Чтобы сохранить массив в LS не переводя его в строку, используют JSON.stringify; чтобы заданная переменная
        или константа так же не переводила массив в строку используют JSON.parse;</p>
    <p>Метод JSON.stringify() преобразует значение JavaScript в строку JSON, возможно с заменой значений, если
        указана функция замены, или с включением только определённых свойств, если указан массив замены.</p>
    <p>Метод JSON.parse() разбирает строку JSON, возможно с преобразованием получаемого в процессе разбора
        значения.</p>
    <a href="testlocalStorage.html" target="_blank">страница для тестирования LS</a>
    <div class="testLS"></div>

    <ol>
        <li>
            <p>Создайте функцию funcLS1 которая записывает в LS ключ 5 со значением 11. Проверьте что происходит при
                повторном вызове функции. Запускается ф-я по кнопкуе buttLS1. </p>
            <button id="buttLS1">Task-1</button>
        </li>
        <li>
            <p> Создайте функцию funcLS2 которая записывает в LS массив arrayLS2 = [7,6,5]. Ключ arrayLS2. Проверьте
                что происходит при
                повторном вызове функции. Запускается ф-я по кнопкуе buttLS2.</p>
            <button id="buttLS2">Task-2</button>
        </li>
        <li>
            <p> При нажатии кнопки funcLS3 выведите из LS сохранненный массив arrayLS2. Выведите в divLS3 в формате
                ключ пробел
                значение перенос строки. </p>
            <button id="buttLS3">Task-3</button>
            <div class="divLS3"></div>
        </li>
        <li>
            <p>Создайте функцию funcLS4 которая записывает в LS массив arrayLS4 = {hello: world, hi:mahai}. Ключ
                arrayLS4. Проверьте что
                происходит при повторном вызове функции. Запускается ф-я по кнопкуе buttLS4.</p>
            <button id="buttLS4">Task-4</button>
            <div class="divLS4"></div>
        </li>
        <li>
            <p> При нажатии кнопки buttLS5 выведите из LS сохранненный массив arrayLS4. Выведите в divLS5 в формате
                ключ пробел
                значение перенос строки. </p>
            <button id="buttLS5">Task-5</button>
            <div class="divLS5"></div>
        </li>
        <li>
            <p>Создайте функцию funcLS6 которая очищает весь LS. Запуск по кнопке buttLS6.</p>
            <button id="buttLS6">Task-6</button>
            <div class="divLS6"></div>
        </li>
        <li>
            <p> Создайте input inputLS7 куда пользователь может вводить числа и строки. Создайте массив arrayLS7.
                Когда
                пользователь нажимает кнопку buttLS7 число должно добавляться в массив. Массив должен сохраняться в
                LS с
                ключем arrayls7.</p>
            <div class="form-control">
                <label>Введите значение</label>
                <input aria-label="Enter some info" type="text" placeholder="Enter some info" id="inputLS7">
            </div>
            <button id="buttLS7">Task-7</button>
        </li>
        <li>
            <p>Создайте функцию funcLS8 при запуске которой из arrayLS7 удаляется последний элемент. После чего
                массив сохраняется
                в LS с ключем arrayLS7. Использовать массив из предыдущего задания.</p>
            <button id="buttLS8">Task-8</button>
        </li>
    </ol>


    <h3 id="JSlesson24">UNIT 24. НЕМНОГО ТЕОРИИ - РАБОТА С POST, GET ЗАПРОСАМИ</h3>

    <p>Запросы работают только с включенным VPN!</p>

    <p>Метод GET это способ обращения к серверу, в котором информация запрашивается и передается через адресную
        строку</p>
    <p>Помимо URL адреса также содержит параметры. Знаком вопроса адрес отделяется от параметров, далее идет
        параметр равно значение который в свою очередь отделяется от других параметров амперсандом:</p>
    <p> Пример гет строки: https//.....?action=edit&section=1</p>
    <p>Метод POST не дублирует информацию в адресной строке.</p>

    <p>GET запрос</p>
    <form action="t1.dat">
        <input aria-label="first param" type="text" name="one" placeholder="переход по ссылке...">
        <input aria-label="second param" type="number" name="two" placeholder="...с параметрами">
        <input type="submit" value="GO">
    </form>
    <p>POST запрос</p>
    <form action="t1.dat" method="post">
        <input aria-label="first param" type="text" name="one" placeholder="переход по ссылке...">
        <input aria-label="second param" type="number" name="two" placeholder="...с параметрами">
        <input type="submit" value="GO">
    </form>

    <p>index2.php?auth=7859d9d42a8834141d529577207c9596</p>
    <ol>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1. Если
                все сделано верно, сервер пришлет строку hello.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=1</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.
                Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать параметр auth
                (ключ в чате).
                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=2&name=Dmitriy</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth (ключ в
                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=3&num1=1&num2=10</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате). Используем POSTMAN.
                Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=4&num1=5&num2=15</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=5</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=6&num1=10&num2=4</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=7</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в чате).
                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=8&year=1993</p>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 9. В
                качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
            <p>Запрашиваем:</p>
            <p>auth=7859d9d42a8834141d529577207c9596&action=9&d=1&m=1&y=1</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1. Если
                все сделано верно, сервер пришлет строку hello.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.
                Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать параметр auth
                (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth (ключ в
                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате). Используем POSTMAN.
                Данную работу на проверку не присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не
                присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в чате).
                Используем POSTMAN. Данную работу на проверку не присылаем.</p>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 9. В
                качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Используем POSTMAN. Данную работу на проверку не присылаем.</p>
        </li>
    </ol>


    <h3 id="JSlesson25">UNIT 25. AJAX - АСИНХРОННЫЙ JAVASCRIPT</h3>

    <ol>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1.
                Выведите в outAJAX1 результат. Запускаться функция должна по нажатию buttAJAX1.</p>
            <button id="buttAJAX1">Сделать запрос</button>
            <div class="outAJAX1"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.
                Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Выведите в outAJAX2 результат.
                Запускаться функция должна по нажатию buttAJAX2.</p>
            <button id="buttAJAX2">Сделать запрос</button>
            <div class="outAJAX2"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Выведите в outAJAX3 результат. Запускаться
                функция должна по нажатию buttAJAX3.</p>
            <button id="buttAJAX3">Сделать запрос</button>
            <div class="outAJAX3"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате). Выведите в outAJAX4 результат.
                Запускаться функция должна по нажатию buttAJAX4.</p>
            <button id="buttAJAX4">Сделать запрос</button>
            <div class="outAJAX4"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX5 результат. Запускаться
                функция должна по нажатию buttAJAX5.</p>
            <button id="buttAJAX5">Сделать запрос</button>
            <div class="outAJAX5"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outAJAX6 результат.
                Запускаться функция должна по нажатию buttAJAX6.</p>
            <button id="buttAJAX6">Сделать запрос</button>
            <div class="outAJAX6"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX7 результат. Запускаться
                функция должна по нажатию buttAJAX7.</p>
            <button id="buttAJAX7">Сделать запрос</button>
            <div class="outAJAX7"></div>
            <div class="containerAJAX7"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в чате).
                Выведите в outAJAX8 результат. Запускаться функция должна по нажатию buttAJAX8.</p>
            <button id="buttAJAX8">Сделать запрос</button>
            <div class="outAJAX8"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 9. В
                качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Выведите в outAJAX9 результат.
                Запускаться функция должна по нажатию buttAJAX9.</p>
            <button id="buttAJAX9">Сделать запрос</button>
            <div class="outAJAX9"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1.
                Выведите в outAJAX10 результат. Запускаться функция должна по нажатию buttAJAX10.</p>
            <button id="buttAJAX10">Сделать запрос</button>
            <div class="outAJAX10"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.
                Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать параметр auth
                (ключ в чате).
                Выведите в outAJAX11 результат. Запускаться функция должна по нажатию buttAJAX11.</p>
            <button id="buttAJAX11">Сделать запрос</button>
            <div class="outAJAX11"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outAJAX12 результат.
                Запускаться функция должна по нажатию buttAJAX12.</p>
            <button id="buttAJAX12">Сделать запрос</button>
            <div class="outAJAX12"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате).
                Выведите в outAJAX13 результат. Запускаться функция должна по нажатию buttAJAX13.</p>
            <button id="buttAJAX13">Сделать запрос</button>
            <div class="outAJAX13"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX14 результат. Запускаться
                функция должна по нажатию buttAJAX14.</p>
            <button id="buttAJAX14">Сделать запрос</button>
            <div class="outAJAX14"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outAJAX15 результат.
                Запускаться функция должна по нажатию buttAJAX15.</p>
            <button id="buttAJAX15">Сделать запрос</button>
            <div class="outAJAX15"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outAJAX16 результат. Запускаться
                функция должна по нажатию buttAJAX16.</p>
            <button id="buttAJAX16">Сделать запрос</button>
            <div class="outAJAX16"></div>
            <div class="containerAJAX16"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outAJAX17 результат. Запускаться функция должна по нажатию buttAJAX17.</p>
            <button id="buttAJAX17">Сделать запрос</button>
            <div class="outAJAX17"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 9. В
                качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Выведите в outAJAX18 результат.
                Запускаться функция должна по нажатию buttAJAX18.</p>
            <button id="buttAJAX18">Сделать запрос</button>
            <div class="outAJAX18"></div>
        </li>
    </ol>


    <h3 id="JSlesson26">UNIT 26. УЧИМ FETCH НА ПРАКТИКЕ</h3>

    <p>Fetch имеет следующие параметры:</p>
    <ol>
        <li>
            <p>'input' - параметр куда записываем адрес к которому хотим обратиться, в нашем примере
                'https://getpost.itgid.info/index2.php'.</p>
        </li>
        <li>
            <p>promise - обработчик результата ответа</p>
        </li>
    </ol>


    <h4>Tasks:</h4>

    <ol>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                1. Выведите в outfetch1 результат. Запускаться функция должна по нажатию buttfetch1.</p>
            <button id="buttfetch1">Сделать запрос</button>
            <div class="outfetch1"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                2. Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Выведите в outfetch2 результат.
                Запускаться функция должна по нажатию buttfetch2.</p>
            <button id="buttfetch2">Сделать запрос</button>
            <div class="outfetch2"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                3. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Выведите в outfetch3 результат. Запускаться
                функция должна по нажатию buttfetch3.</p>
            <button id="buttfetch3">Сделать запрос</button>
            <div class="outfetch3"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                4. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате). Выведите в outfetch4 результат.
                Запускаться функция должна по нажатию buttfetch4.</p>
            <button id="buttfetch4">Сделать запрос</button>
            <div class="outfetch4"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                5. Если все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch5 результат. Запускаться
                функция должна по нажатию buttfetch5.</p>
            <button id="buttfetch5">Сделать запрос</button>
            <div class="outfetch5"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                6. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outfetch6 результат. Запускаться функция должна по нажатию buttfetch6.</p>
            <button id="buttfetch6">Сделать запрос</button>
            <div class="outfetch6"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                7. Если все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch7 результат. Запускаться
                функция должна по нажатию buttfetch7.</p>
            <button id="buttfetch7">Сделать запрос</button>
            <div class="outfetch7"></div>
            <div class="containerfetch7"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                8. В качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в чате).
                Выведите в outfetch8 результат. Запускаться функция должна по нажатию buttfetch8.</p>
            <button id="buttfetch8">Сделать запрос</button>
            <div class="outfetch8"></div>
        </li>
        <li>
            <p>Отправьте GET запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                9. В качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Выведите в outfetch9 результат. Запускаться функция должна по нажатию
                buttfetch9.</p>
            <button id="buttfetch9">Сделать запрос</button>
            <div class="outfetch9"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                1. Выведите в outfetch10 результат. Запускаться функция должна по нажатию buttfetch10.</p>
            <button id="buttfetch10">Сделать запрос</button>
            <div class="outfetch10"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                2. Добавьте параметр name с вашим именем на латинице.
                Если все сделано верно, сервер пришлет строку hello ваше имя. Не забывайте указывать параметр auth
                (ключ в чате). Выведите в outfetch11 результат. Запускаться функция должна по нажатию
                buttfetch11.</p>
            <button id="buttfetch11">Сделать запрос</button>
            <div class="outfetch11"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                3. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет сумму чисел. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outfetch12 результат. Запускаться функция должна по нажатию buttfetch12.</p>
            <button id="buttfetch12">Сделать запрос</button>
            <div class="outfetch12"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                4. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет случайное число в заданном диапазоне. Не забывайте указывать
                параметр auth (ключ в чате). Выведите в outfetch13 результат.
                Запускаться функция должна по нажатию buttfetch13.</p>
            <button id="buttfetch13">Сделать запрос</button>
            <div class="outfetch13"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                5. Если все сделано верно, сервер вернет текущее время и дату.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch14 результат. Запускаться
                функция должна по нажатию buttfetch14.</p>
            <button id="buttfetch14">Сделать запрос</button>
            <div class="outfetch14"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                6. Добавьте параметр num1 и num2 содержащие числа.
                Если все сделано верно, сервер вернет большее число. Не забывайте указывать параметр auth (ключ в
                чате). Выведите в outfetch15 результат. Запускаться функция должна по нажатию buttfetch15.</p>
            <button id="buttfetch15">Сделать запрос</button>
            <div class="outfetch15"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                7. Если все сделано верно, сервер случайную ссылку на изображение.
                Не забывайте указывать параметр auth (ключ в чате). Выведите в outfetch16 результат. Запускаться
                функция должна по нажатию buttfetch16.</p>
            <button id="buttfetch16">Сделать запрос</button>
            <div class="outfetch16"></div>
            <div class="containerfetch16"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                8. В качестве параметра по очереди укажите year равный году вашего рождения.
                Если все правильно сервер вернет ваш возраст. Не забывайте указывать параметр auth (ключ в
                чате).Выведите в outfetch17 результат. Запускаться функция должна по нажатию buttfetch17.</p>
            <button id="buttfetch17">Сделать запрос</button>
            <div class="outfetch17"></div>
        </li>
        <li>
            <p>Отправьте POST запрос (fetch) на сайт http://getpost.itgid.info/index2.php. В качестве action укажите
                9. В качестве параметра по очереди укажите m = 1, d=1, y=1.
                Если все сделано верно, сервер возвратит дату или месяц или год. Не забывайте указывать параметр
                auth (ключ в чате). Выведите в outfetch18 результат.
                Запускаться функция должна по нажатию buttfetch18.</p>
            <button id="buttfetch18">Сделать запрос</button>
            <div class="outfetch18"></div>
        </li>
    </ol>

    <h3 id="JSlesson27">UNIT 27. РАБОТАЕМ С ПРОМИСАМИ (PROMISE)</h3>

    <p>Объект Promise используется для отложенных и асинхронных вычислений.</p>
    <h4>Синтаксис:</h4>
    <p>new Promise(function(resolve, reject) { ... });</p>
    <p>Где resolve вызывает успешное исполнение промиса, а reject отклоняет его</p>
    <h4>Promise может находиться в трёх состояниях:</h4>
    <ol>
        <li>ожидание (pending): начальное состояние, не исполнен и не отклонён.</li>
        <li>исполнено (fulfilled): операция завершена успешно.</li>
        <li>отклонено (rejected): операция завершена с ошибкой.</li>
    </ol>

    <h4>Методы промиса:</h4>
    <ul>
        <li>
            <p>Promise.all(iterable)</p>
            <p>Ожидает исполнения всех промисов или отклонения любого из них. Возвращает промис, который исполнится
                после исполнения всех промисов в iterable.
                В случае, если любой из промисов будет отклонён, Promise.all будет также отклонён.</p>
        </li>
        <li>
            <p>Promise.allSettled(iterable)</p>
            <p>Ожидает завершения всех полученных промисов (как исполнения так и отклонения). Возвращает промис,
                который исполняется когда все полученные промисы завершены (исполнены или отклонены),
                содержащий массив результатов исполнения полученных промисов.</p>
        </li>
        <li>
            <p>Promise.race(iterable)</p>
            <p>Ожидает исполнения или отклонения любого из полученных промисов. Возвращает промис, который будет
                исполнен или отклонён с результатом исполнения первого исполненного или отклонённого промиса из
                iterable.</p>
        </li>
        <li>
            <p>Promise.reject(reason)</p>
            <p>Возвращает промис, отклонённый из-за reason.</p>
        </li>
        <li>
            <p>Promise.resolve(value)</p>
            <p>Возвращает промис, исполненный с результатом value.</p>
        </li>
    </ul>

    <h4>Tasks:</h4>
    <ol>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1.</p>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.</p>
            <p>Два запроса объедините с помощью promiseAll. Результат выведите в outpromise1 результат. Запускаться
                функция должна по нажатию buttpromise1.</p>
            <button id="buttpromise1">Сделать запрос</button>
            <div class="outpromise1"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет сумму
                чисел.</p>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет случайное
                число в заданном диапазоне.</p>
            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise2 результат. Запускаться функция
                должна по нажатию buttpromise2.</p>
            <button id="buttpromise2">Сделать запрос</button>
            <div class="outpromise2"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату. Не забывайте указывать параметр auth (ключ в
                чате).</p>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет большее
                число.</p>
            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise3 результат. Запускаться функция
                должна по нажатию buttpromise3.</p>
            <button id="buttpromise3">Сделать запрос</button>
            <div class="outpromise3"></div>
        </li>
        <li>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение. Не забывайте указывать параметр auth
                (ключ в чате).</p>
            <p>Отправьте GET запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения. Если все правильно сервер
                вернет ваш возраст.</p>
            <p>Выведите в outpromise4 результат. Запускаться функция должна по нажатию buttpromise4.</p>
            <button id="buttpromise4">Сделать запрос</button>
            <div class="outpromise4"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 1.</p>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 2.</p>
            <p>Два запроса объедините с помощью promiseAll. Результат выведите в outpromise5 результат. Запускаться
                функция должна по нажатию buttpromise5.</p>
            <button id="buttpromise5">Сделать запрос</button>
            <div class="outpromise5"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 3.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет сумму
                чисел.</p>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 4.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет случайное
                число в заданном диапазоне.</p>
            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise6 результат. Запускаться функция
                должна по нажатию buttpromise6.</p>
            <button id="buttpromise6">Сделать запрос</button>
            <div class="outpromise6"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 5. Если
                все сделано верно, сервер вернет текущее время и дату. Не забывайте указывать параметр auth (ключ в
                чате).</p>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 6.
                Добавьте параметр num1 и num2 содержащие числа. Если все сделано верно, сервер вернет большее
                число.</p>
            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise7 результат. Запускаться функция
                должна по нажатию buttpromise7.</p>
            <button id="buttpromise7">Сделать запрос</button>
            <div class="outpromise7"></div>
        </li>
        <li>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 7. Если
                все сделано верно, сервер случайную ссылку на изображение. Не забывайте указывать параметр auth
                (ключ в чате).</p>
            <p>Отправьте POST запрос на сайт http://getpost.itgid.info/index2.php. В качестве action укажите 8. В
                качестве параметра по очереди укажите year равный году вашего рождения. Если все правильно сервер
                вернет ваш возраст.</p>
            <p>Два запроса объедините с помощью promiseAll. Выведите в outpromise8 результат. Запускаться функция
                должна по нажатию buttpromise8.</p>
            <button id="buttpromise8">Сделать запрос</button>
            <div class="outpromise8"></div>
        </li>
    </ol>


    <h3 id="JSlesson28">UNIT 28. ООП В ES6</h3>

    <div class="testOOP"></div>
    <div class="testOOP1"></div>

    <p>Классы в JavaScript представляют собой синтаксический сахар над существующим в JavaScript механизмом
        прототипного наследования.
        Синтаксис классов не вводит новую объектно-ориентированную модель, а предоставляет более простой и понятный
        способ создания объектов и организации наследования.</p>
    <p>p.s. На самом деле классы — это "специальные функции", поэтому точно также, как вы определяете функции
        (function expressions и function declarations),
        вы можете определять и классы с помощью: class declarations и class expressions.</p>
    <p>Первый способ определения класса — class declaration (объявление класса). Для этого необходимо
        воспользоваться ключевым словом class и указать имя класса.</p>
    <pre>
        class Rectangle {
          constructor(height, width) {
            this.height = height;
            this.width = width;
          }
        }
    </pre>
    <p>Второй способ определения класса — class expression (выражение класса). Можно создавать именованные и
        безымянные выражения.
        В первом случае имя выражения класса находится в локальной области видимости класса и может быть получено
        через свойства самого класса, а не его экземпляра.</p>
    <pre>
        // безымянный
        var Rectangle = class {
          constructor(height, width) {
            this.height = height;
            this.width = width;
          }
        };
        console.log(Rectangle.name);
        // отобразится: "Rectangle"

        // именованный
        var Rectangle = class Rectangle2 {
          constructor(height, width) {
            this.height = height;
            this.width = width;
          }
        };
        console.log(Rectangle.name);
        // отобразится: "Rectangle2"
    </pre>


    <h4>Tasks:</h4>
    <ol>
        <li>
            <p>Создайте класс Goods. Класс должен содержать свойства name, amount. Создайте на его основе объект
                goods.
                Выведите в консоль созданный объект. Помните, все классы - в отдельных файлах. Имена классов с
                большой буквы.</p>
        </li>
        <li>
            <p>Добавьте в класс Goods свойства image и count - картинка и количество на складе.</p>
        </li>
        <li>
            <p> Добавьте в класс Goods метод draw, который будет выводить div с изображением, названием товара,
                ценой - в указанный элемент (дозапись). </p>
        </li>
        <li>
            <p>Создайте на основе класса Goods объект goods2, заполните свойства, примените метод draw для вывода
                товара на страницу в блок out-4.</p>
            <div class="outOOP4"></div>
        </li>
        <li>
            <p>Создайте класс Goods2, который наследуется от Goods. Добавьте ему свойство sale равное true или
                false. Перезапишите метод draw так, чтобы он выводил информацию о распродажах.</p>
        </li>
        <li>
            <p>Создайте на основе класса Goods2 объект goods3. Заполните все поля. Выведите товар на страницу с
                помощью метода draw. Вывод осуществить в out-6. </p>
            <div class="outOOP6"></div>
        </li>
        <li>
            <p>Создайте класс Valid, который содержит свойства email, password, isValid. И метод validate. Метод
                validate должен проверять длину пароля и писать false в isValid если длина меньше 6 и true если
                больше.
                Изначально свойство isValid равно false.</p>
        </li>
        <li>
            <p>Создайте объект на основе класса Valid и задайте ему имя и пароль длиной 5 символов. Запустите метод
                validate() и выведите в консоль свойство isValid.</p>
        </li>
        <li>
            <p>Создайте объект на основе класса Valid и задайте ему имя и пароль длиной 7 символов. Запустите метод
                validate() и выведите в консоль свойство isValid.</p>
        </li>
        <li>
            <p>Унаследуйтесь от класса Valid и создайте класс Valid2. Расширьте его свойствами emaiError,
                passwordError. По умолчанию, они равны пустой строке.
                Перезапишите метод validate(), помимо проверки пароля, он должен содержать еще проверку свойства
                email на пустоту. Если поле email пустое - то isValid - false.
                Также, в случае ошибки валидации в поле emailError пишется сообщение ‘email empty’, в поле
                passwordError - ‘min length 6’.</p>
        </li>
        <li>
            <p>Создайте на основе класса Valid2 объект valid2 и задайте пустой емейл и длину пароля меньше 7.
                Запустите метод validate(). Выведите объект в консоль.</p>
        </li>
        <li>
            <p>Создайте на основе класса Valid2 объект valid3 и задайте не пустой емейл и длину пароля больше 7.
                Запустите метод validate(). Выведите объект в консоль.</p>
        </li>
    </ol>

    <h3 id="JSlesson29">UNIT 29. ЗАМЫКАНИЯ</h3>

    <p>Замыкание — это комбинация функции и лексического окружения, в котором эта функция была определена.
        Другими словами, замыкание даёт вам доступ к Scope (en-US) внешней функции из внутренней функции.
        В JavaScript замыкания создаются каждый раз при создании функции, во время её создания.</p>
    <p>Вы можете вложить одну функцию в другую. Вложенная функция (nested function; inner) приватная (private) и она
        помещена в другую функцию (outer). Так образуется замыкание (closure).
        Closure — это выражение (обычно функция), которое может иметь свободные переменные вместе со средой, которая
        связывает эти переменные (что "закрывает" ("close") выражение).</p>
    <p>Замыкания это следствие работы функции в javascript</p>

    <button id="buttclosure1">первый счетчик</button>
    <div class="outclosure1"></div>
    <button id="buttclosure2">второй счетчик</button>
    <div class="outclosure2"></div>

    <h3 id="JSlesson30">UNIT 30. РЕКУРСИЯ</h3>

    <p>Рекурсия это возможность функции вызвать саму себя</p>
    <p>Функция, которая вызывает саму себя, называется рекурсивной функцией (recursive function). Получается, что
        рекурсия аналогична циклу (loop).
        Оба вызывают некоторый код несколько раз, и оба требуют условия (чтобы избежать бесконечного цикла, вернее
        бесконечной рекурсии). </p>

    <div class="boxforbox">
        <div class="moovingblock"></div>
    </div>
    <br>
    <button id="moovingbutt">двигай</button>

    <p>задание для unit24</p>

    <form action="http://getpost.itgid.info/index2.php">
        <input aria-label="auth" type="text" name="auth" placeholder="auth"><br>
        <input aria-label="action" type="text" name="action" placeholder="action"><br>
        <input aria-label="name" type="text" name="name" placeholder="name"><br>
        <input aria-label="num1" type="text" name="num1" placeholder="num1"><br>
        <input aria-label="num2" type="text" name="num2" placeholder="num2"><br>
        <input aria-label="year" type="text" name="year" placeholder="year"><br>
        <input aria-label="m" type="text" name="m" placeholder="m"><br>
        <input aria-label="d" type="text" name="d" placeholder="d"><br>
        <input aria-label="y" type="text" name="y" placeholder="y"><br>
        <input aria-label="go" type="submit" value="go"><br>
    </form>


    <div class="boxforbox">
        <div class="moovingblock" id="moovingbox"></div>
    </div>
    <button id="boxbutt">рекурсия</button>


    <h3 id="ReactBase">Основы React</h3>

    <section>
        <div>
            <p>React - JavaScript библиотека для создания пользовательских интерфейсов(UI)</p>
            <p>React позволяет избежать императивный метод программирования когда логика программы указывается шаг
                за шагом выполняя одни и те же действия</p>
            <p>React разбивает приложение на компоненты и каждый компонент имеет небольшую задачу, упрощая поддержку
                приложения,
                использующийся же подход называется декларативным</p>
            <p>Альтернативами React являются:</p>
            <ul>
                <li>Angular-более объемная библиотека</li>
                <li>Vue- что-то среднее между React и Angilar</li>
            </ul>
        </div>
    </section>


    <h3 id="Components">Компоненты</h3>

    <section>
        <div>
            <p>Компоненты - фундаментальные блоки приложений React</p>
            <p>Подобный подход позволяет их использовать повторно(Dont Repeat Yourself) и разделять
                ответсвенность(Не делать слишком много и в одном и том же месте)</p>
        </div>
        <div>
            <p>Создание веб приложений при помощи React опирается на компоненты.
                Компонент это часть JSX кода, который помещен в отдельный файл и обернут функцией(возвращающая
                функция, т.е. с return()),
                которая потом импортируется как тэг в другой компонент или в корневой компонент</p>
            <p>Пример</p>
            <img src="./images/component.png" alt="component" height="449">
            <img src="./images/componentImport.png" alt="componentImport">
            <p>"App" является корневым компонентом тк собирает в себе все остальные компоненты и потом в итоге
                рендерится на страницу.</p>
        </div>
    </section>

    <h3 id="DeclatationMethod">Декларативный подход</h3>

    <section>
        <div>
            <p>При помощи React мы определяем конечное целевое состояние и позволяем React самому определить нужные
                JavaScript DOM инструкции.
                Данный подход называется декларативным</p>
        </div>
    </section>

    <h4>Все шаги по работе с create-react-app прописаны на <a href="https://github.com/facebook/create-react-app"
                                                              target="_blank">Гитхабе</a></h4>
    <h4>А по работе с самим React на<a href="https://react.dev/learn">React.dev</a></h4>

    <h3 id="JSX">JSX код</h3>

    <section>
        <div>
            <p>Львиная доля кода в приложениях React написана на JSX коде, в среде JavaScript это не валидный код.
                Благодаря преобразованию React он перерабатывается в обычный JS код</p>
            <p>пример:</p>
            <pre>
                function functionName (){
                   return (
                      &lt;div&gt;
                          &lt;h1&gt;Content&lt;/h1&gt;
                      &lt;/div&gt;
                   );
                }
            </pre>
        </div>
    </section>

    <h3 id="CSSstyling">Стилизация CSS</h3>

    <section>
        <div>
            <p>Для стилизации компонентов используются все те же CSS стили.</p>
            <p>CSS файл импортируется в файл компонента(import './File.css') и потом с помощью атрибута
                className='...' подключается к стилизируемому элементу</p>
            <p>Общепринято называть CSS файл так же как компонент.</p>
        </div>
    </section>

    <h3 id="JSXrender">Отображение динамических данных в JSX</h3>

    <section>
        <div>
            <p>Для отображения динамических данных используются одинарные фигурные скобки {expresion}</p>
            <p>пример:</p>
            <img src="./images/динамическое_отображение_данных.png" alt="dinamicData">
        </div>
    </section>

    <h3 id="Props">Передача данных при помощи props</h3>

    <section>
        <div>
            <p>Если данные, которые нужно использовать в текущем файле находятся вне его, то используют концепцию
                props:</p>
            <img src="./images/props.png" alt="props" width="670">
            <p>Т.е. мы задаем некие атрибуты внутри тега компонента, и в файле где мы его настраиваем, подключаем их
                в скобках
                функции параметром "props" и потом в коде с помощью props.atribute :</p>
            <img src="./images/props1.png" alt="props1" height="386"><img src="./images/props2.png" alt="props2" height="386">
        </div>
    </section>

    <h3 id="dividingComponents">Разделение компонента на несколько компонентов</h3>

    <section>
        <div>
            <p>Когда некий компонент чрезмерно разрастается, его принято разбивать на несколько компонентов</p>
            <p>При разбитии компонента на несколько компонентов иногда требуется "протаскивать" параметры к
                отделенным компонентам,
                делается это дублированием параметров в новом компоненте с параметром props:</p>
            <img src="./images/newComponent1.png" alt="newComponent" height="389"><img
                src="./images/newComponent2.png" alt="newComponent" height="389">
        </div>
    </section>

    <h3 id="propsChildren">Композиция {props.children}</h3>

    <section>
        <div>
            <p>Для создания компонента который служит оболочкой контента используют {props.children}, т.е.
                настраивают отдельный файл компонент, применяют к нему
                CSS стили, ставят в функции между закрытым тэгом {props.children} и импортируют его в нужный файл, и
                используют его тэг в качестве стилизирующей
                обертки, таким образом сокращая повторяющийся CSS код. Далее к этому тэгу стили нельзя применить на
                прямую и нужно добавлять переменную в которую
                через конкатенацию нужного стиля и props.className указывают все требуемые стили:</p>
            <img src="./images/childrenCard.png" alt="childrenCard" width="619"><br>
            <img src="./images/cardImport1.png" alt="cardImport1" width="619"><br>
            <img src="./images/cardImport2.png" alt="cardImport2" width="619">
        </div>
    </section>

    <h3 id="oldReactMethod">Старый метод программирования React</h3>

    <section>
        <div>
            <p>Ранее нужно было импортировать "import React from "react"", и вместо обычного JSX кода возвращался
                объект с методом React.createElement():</p>
            <img src="./images/oldReactMethod.png" alt="oldReactMethod">
        </div>
    </section>

    <h3 id="folderOrganization">Организация файлов компонентов</h3>

    <section>
        <div>
            <p>При разрастании файлов компонентов их следует разместить в поддерикториях:</p>
            <img src="./images/fileOrganisation.png" alt="fileOrganisation">
        </div>
    </section>

    <h3 id="onHandlers">Прослушивание событий и работа с обработчиками событий</h3>

    <section>
        <div>
            <p>Мы можем добавить атрибут "on" для любого события которое поддерживает этот элемент. Список событий
                можно посмотреть на
                <a href="https://developer.mozilla.org/ru/docs/Web/API/Element" target="_blank">MDN</a> в списке
                событий.</p>
            <p>Все события в React начинаются на "on..."(onClick={function} f.e.) и имеют следующий вид записи:</p>
            <img src="./images/eventListener.png" alt="eventListener">
            <p>В конце названий функций обработчиков событий принято писать "Handler"</p>
        </div>
    </section>

    <h3 id="workWithState">Работа с состоянием</h3>

    <section>
        <div>
            <p>Хуки — нововведение в React 16.8, которое позволяет использовать состояние и другие возможности React
                без написания классов.</p>
            <p>Хук useState возвращает значение с состоянием и функцию для его обновления. Используется если
                пользователь нажатием кнопки изменяет контент.</p>
            <p>Во время первоначального рендеринга возвращаемое состояние (state) совпадает со значением, переданным
                в качестве первого аргумента (initialState).</p>
            <pre>
                const [state, setState] = useState(initialState);
            </pre>
            <p>Функция setState используется для обновления состояния. Она принимает новое значение состояния и
                ставит в очередь повторный рендер компонента.</p>
            <pre>
                setState(newState);
            </pre>
            <p>useState можно использовать в пределах одного компонента к разным элементом неограниченное количество
                раз:</p>
            <img src="./images/multipleUseStateUsage1.png" alt="multipleUseStateUsage">
            <p>Так же в useState можно передать объект и управлять несколькими состояниями одновременно, при этом
                обязательно
                нужно учитывать все объекты при многократном вызове функции и считается не очень хорошей практикой
                обновления состояния:</p>
            <img src="./images/multipleUseStateUsage2.png" alt="multipleUseStateUsage">
            <p>Лучше всего будет при втором способе в качестве параметра задать функцию с prevState в скобках и
                возвратить prevState вместе с изменяемым значением:</p>
            <img src="./images/multipleUseStateUsage3.png" alt="multipleUseStateUsage">
        </div>
    </section>

    <h3 id="twoWayBinding">Добавление двустороннего связывания</h3>

    <section>
        <div>
            <p>Для того чтобы очистить форму, в случае если к применен метод event.preventDefault(), применяют
                двухстороннее связывание,
                где в хэндлере обработчике формы вконце кода вставляют функции обновляющие состояния инпутов с
                пустым содержимым между ковычками( setInputName(''); ),
                а в самих инпутах добавляют атрибут value={inputName}:</p>
            <img src="./images/twoWayBinding.png" alt="twoWayBinding" width="619">
        </div>
    </section>

    <h3 id="liftingStateUp">Коммуникация компонентов наследник-родитель (Снизу Вверх)</h3>

    <section>
        <div>
            <p>Чтобы передавать какую-то информацию от наследника к родителю, нужно в родительском компоненте
                создать атрибут значением которой будет функция, задать функции параметр, и через props вызвать эту
                функцию в компоненте-наследнике,
                передав параметром в скобках этой функции нужную информацию, в итоге в параметр функции
                родительского компонента будет записана информация:</p>
            <img src="./images/relativComponentData.png" alt="relativComponentData" height="320"><img
                src="./images/childComponentData.png" alt="childComponentData" height="320">
        </div>
    </section>

    <h4>Подъем состояния вверх</h4>
    <section>
        <div>
            <p>В случае если нужно передать информацию от одного компонента к другому, но они не имеют прямой
                иерархии(родитель-наследник или наоборот) используют
                подъем состояния вверх, когда информацию поднимают до общего родителя и потом уже опускают ее дальше
                по иерархии к нужному компоненту</p>
            <img src="./images/liftingStateUp.png" alt="liftingStateUp" width="619">
        </div>
    </section>

    <h3 id="dummyComponentsVsComponentsWithState">Компоненты - контролируемые vs неконтролируемые, с состоянием vs
        без состояния</h3>

    <section>
        <div>
            <p>Каждый раз когда мы используем двухстороннее связывание мы контролируем компонент</p>
            <p>Если в компоненте не используется обработчик состояния, то данный компонент называется "глупым" или
                компонентом без состояния.</p>
        </div>
    </section>

    <h3 id="dynamicContent">Отображение списков данных(Работа с динамическим контентом)</h3>

    <section>
        <div>
            <p>В случае, если нам требуется отобразить некий контент, который меняется динамично, нам следует
                создать выражение{expression},
                где внутри фигурных скобок, мы будем применять нужный нам метод к JSX коду, тоесть в скобках этого
                метода мы спокойно можем применять компоненты:</p>
            <img src="./images/dinamicData.png" alt="dinamicData">
        </div>
    </section>

    <h3 id="useState">Использование cписков с cостоянием</h3>

    <section>
        <div>
            <p>Чтобы вносить какие-то данные в массив нужно использовать useState и далее уже с помощью обновляющей
                функции set()
                добавляем новые данные в массив сохраняя при этом старые данные:</p>
            <pre>
                const [arrName, setArrName]= useState(oldArrName);

                setArrNAme(prevArr => {
                     return [newArrElem, ...prevArr]
                });
            </pre>
            <img src="./images/addingNewArrElem.png" alt="addingNewArrElem">
        </div>
    </section>

    <h3 id="keysConcept">концепция Keys</h3>

    <section>
        <div>
            <p>В случае если мы используем объекты или массивы, для того чтобы React мог различать элементы внутри
                массивов или объектов, обязателшьно нужно их
                нумеровать добавляя атрибут "key" и задать ему уникальный идентификационный номер(id). Данная
                концепция позволяет избежать багов и "перерендера" списка:</p>
            <img src="./images/conceptKey.png" alt="conceptkey">
        </div>
    </section>

    <h3 id="ternaryOperator">Отображение контента по условию</h3>

    <section>
        <div>
            <p>В React при задании условия нужно использовать тернарный(условный) оператор {условие ? выражение1 :
                выражение2}:</p>
            <img src="./images/ternaryOperator1.png" alt="ternaryOperator1" height="430">
            <p>или {условие && выражение1}+{условие && выражение2} возвращается то, что соответствует условию:</p>
            <img src="./images/ternaryOperator2.png" alt="ternaryOperator2" height="430">
            <p>или задать переменную с базовым контентом вне "return", через оператор if(){} задать условие с
                альтернативным контентом
                и уже через expression{} вывести эту переменную в return:</p>
            <img src="./images/ifExpression3.png" alt="ifExpression3">
        </div>
    </section>

    <h3 id="returnValueByCondition">Возвращение значения по условию</h3>

    <section>
        <div>
            <p>Так же мы можем с помощью оператора if возвращать два return, первый из которых будет возвращаться по
                какому-то условию,
                отменяя тем самым второй, а второй будет возвращать контент дефолтно если не срабатывает условие
                первого:</p>
            <img src="./images/DBLreturn.png" alt="DBLreturn">
        </div>
    </section>

    <h3 id="dynamicStyles">Динамические cтили</h3>

    <section>
        <div>
            <p>Чтобы добавить стиль, который будет меняться в зависимости от какого-то события/условия или
                переменной,
                к требуемому компоненту используют следующий синтаксис:</p>
            <pre>
                const barFillHeigth = Math.round(props.value / props.maxValue * 100) + '%';

                &lt;div style={{
                        bacgroundColor: "yellow",
                        height: barFillheight
                }}&gt;&lt;div/&gt;
            </pre>
            <p>Т.е. в expression мы задаем объект, который содержит в себе как постоянные стили так и стили с
                заданными переменными(динамические стили):</p>
            <img src="./images/dynamicStyles.png" alt="dynamicStyles">
        </div>
    </section>

    <h3 id="title">Title</h3>

    <p>Чтобы сменить название вкладки в бауезере нужно зайти в папку "public">"index.html" и в теге title поменять
        на нужное название</p>

    <h3 id="CssReact">CSS в React</h3>

    <section>
        <div>
            <p>В React стили делятся на условные и динамические</p>
        </div>
    </section>

    <h3 id="dynamicCss">Динамическое добавление стилей</h3>

    <section>
        <div>
            <p>Для того чтобы стиль менялся в зависимости от будевых значений, можно пользоваться синтаксисом
                тернарного оператора:</p>
            <img src="./images/inlineStyles.png" alt="inlineStyles">
        </div>
    </section>

    <h3 id="dynamicClasses">Динамическое добавление классов</h3>

    <section>
        <div>
            <p>Так же как и для стилей к классам можно применять синтаксис тернарного оператора и задавать при каких
                условиях применяется один класс,
                а при каких другой и так же нужно использовать синтаксис обратных кавычек и знак - className ={`...
                ${ifStatement ? ...: ...}`} :</p>
            <img src="./images/dynamicClasses.png" alt="dynamicClasses">
        </div>
    </section>

    <h3 id="StyledComponents">Знакомство со <a href="https://styled-components.com" target="_blank">Styled
        Components</a></h3>

    <section>
        <div>
            <p>Пакет Styled Components позволяет создавать стилизованные компоненты, таким образом,
                что стили соданные для определенных компонентов применяются ТОЛЬКО к ним.</p>
            <p>В директории с проектом в командной строке нужно ввести:</p>
            <pre>
               npm install --save styled-components
            </pre>
            <p>Имеет следующий синтаксис:</p>
            <pre>
                const Button = styled.button`

                    width: 100%;
                    font: inherit;
                    padding: 0.5rem 1.5rem;
                    color: white;
                    background: #00358b;
                    border-radius: 4px;
                    box-shadow: 0 0 4px rgba(50, 50, 50, 0.25);
                    cursor: pointer;

                    media (min-width: 700px) {
                        width: auto;


                        &:focus {
                            outline: none;
                        }

                        &:hover,
                        &:active {
                            background: #245fbd;
                            box-shadow: 0 0 8px rgba(50, 50, 50, 0.25);
                        }
                    }
                `;
            </pre>
            <p>Где после метода button открываются обратные кавычки, так же вместо этого метода может использоваться
                h1,h2... p и тд, т.е. любой тэг.</p>
            <p>Для псевдо селекторов используется &:, для вложенных элементов просто & с пробелом</p>
        </div>
    </section>

    <h3 id="DynamicProps">Styled Components и Динамические Props</h3>

    <section>
        <div>
            <p>В случае если мы создаем компонент, который будет использоваться только одним другим компонентом, то
                можно его создать в этом же файле:</p>
            <img src="./images/innerStyledComponent.png" alt="innerStyledComponent">
            <p>Так же для этого компонента можно устанавливать классы, которые будут добавляться при каких-то
                условиях:</p>
            <img src="./images/dynamicPropsStyledComponents.png" alt="dynamicPropsStyledComponents">
        </div>
    </section>

    <h3 id="StyledCopmponentsMediaQueries">Styled Components и Media Queries</h3>

    <section>
        <div>
            <p>Так же как и в обычном CSS в Styled Components можно использовать Media Queries:</p>
            <img src="./images/styledComponentsMediaQueries.png" alt="styledComponentsMediaQueries">
        </div>
    </section>

    <h3 id="CssModules">Использование CSS Модулей</h3>

    <section>
        <div>
            <p>При данном методе нужно изменить название CSS файла и добавить '.module' перед '.css':</p>
            <img src="./images/CSSModulesReact.png" alt="CSSModulesReact">
            <p>Далее нужно импортировать созданный файл с полным названием, но импортируется уже объект
                "styles"(название любое,
                в данном объекте содержатся все классы, определенные в CSS), и применить его к требуемому компоненту
                с одноименным
                свойством (относительно классов находящимся в CSS файле через точку):</p>
            <img src="./images/importCSSModulesReact.png" alt="importCSSModulesReact">
            <p>Обращаться к свойству объекта можно как через точку, так и через скобки, содержимое которых закрываем
                кавычками:</p>
            <img src="./images/syntCSSModulesReact.png" alt="syntCSSModulesReact">
        </div>
    </section>

    <h3 id="dynamicModules">Динамические Стили и CSS Модули</h3>

    <section>
        <div>
            <p>В случае если нам нужен стиль меняющийся в зависимости от каких то условий то, через синтаксис
                обратных кавычек можно добавить следующее:</p>
            <img src="./images/dynamicCSSModulesReact.png" alt="dynamicCSSModulesReact">
            <p>Для Media Queries мы используем обычный синтаксис CSS:</p>
            <img src="./images/mediaQueriesModulesReact.png" alt="mediaQueriesModulesReact">
        </div>
    </section>

    <h3 id="Debugging">Отладка (Debugging) приложений React<br>
        Работа с Breakpoints.</h3>

    <section>
        <div>
            <p>Для того чтобы работать с Breakpoints нужно открыть инструмент разработчика, зайти во вкладку
                "Sources",
                далее в "src" папке найти исполняемые JS файлы, и в предпологаемом месте в нумерации строк поставить
                синий флажок Breakpoint'a,
                после чего с помощью кнопок перемещения по функциям вызова двигаться по исполняемому коду,
                анализируя его на предмет ошибок:</p>
            <img src="./images/breakpointDebugg.png" alt="BreakpointDebugg" width="644">
        </div>
    </section>

    <h3 id="ReactDevTools">Использование React DevTools</h3>

    <section>
        <div>
            <p>Расширение для Google Chrome браузера, позволяет увидеть древо компонентов так, как оно расположено в
                React,
                отображает информацию о функциях и хуках:</p>
            <img src="./images/reactDeveloperTools.png" alt="reactDeveloperTools" width="644">
        </div>
    </section>

    <h3 id="JSXrestrictions">Ограничения JSX</h3>

    <section>
        <div>
            <p>Из компонентаневозможно вернуть два находящихся на одном уровне JSX елемента(нельзя возвращать более
                одного "root" элемента)</p>
            <p>Решение- просто обернуть в один "root" элемент(div), минусом будет являться множество лишних
                элементов</p>
            <p>Алтернативное решение - вернуть массивом, отделяя смежные элементы запятыми:</p>
            <img src="./images/returnRootElements.png" alt="returnRootElements">
            <p>Данный метод же имеет следующий минус - нужно к каждому элементу добавлять ключи(key).</p>
            <p>Еще одна альтернатива - создание кастомного элемента обертку "Wrapper", который импортируется в
                нужный файл
                и оборачивает элементы находящиеся на одном уровне, таким образом он позволяет избегать лишних div в
                DOM структуре:</p>
            <img src="./images/wrapper.png" alt="wrapper"><br>
            <img src="./images/wrapperUsage.png" alt="wrapperUsage" width="644">
            <p>Есть дефолтный метод обхода ограничения JSX - React.Fragment:</p>
            <img src="./images/ReactFragment.png" alt="ReactFragment" width="644">
            <p>В основном используются "Fragment".</p>
        </div>
    </section>

    <h3 id="Portals">Порталы</h3>

    <section>
        <div>
            <p>Чтобы написать качественную структуру DOM в случае если используются оверлеи, можно использовать
                "порталы"</p>
            <p>С помощью порталов можно структурировать DOM по нашему усмотрению:</p>
            <img src="./images/addPortal.png" alt="addPortal" width="644"><br>
            <img src="./images/ReactDOMcreatePortal.png" alt="ReactDOMcreatePortal" width="644">
        </div>
    </section>

    <h3 id="useRef">Работа с хуком useRef</h3>

    <section>
        <div>
            <p>При помощи хука useRef мы можем установить соединение между HTML элементом(f.e. input) и JS
                кодом.</p>
            <p>данный хук требует импорта import React,{useRef} from 'react', и присваивание некоей переменной через
                useRef,
                далее к зарезервированному атрибуту "ref" мы присваиваем эту переменную:</p>
            <pre>
                const a = useRef();

                &lt;input ref={A} /&gt;
            </pre>
            <p>После привязки Refs к HTML элементу нам нужно объявить новую переменную, которой мы уже присвоим
                следующее:</p>
            <pre>
                const submitHandler = (event) => {
                    event.preventDefault();
                    const ARefs = a.current.value;
                }
            </pre>
            <p>В случае если нам требуется очистить поля input то мы можем присвоить A.current.value пустую
                строку </p>
            <pre>
                a.current.value = '';
            </pre>
            <img src="./images/RefsExample.png" alt="RefsExample" width="644">
        </div>
    </section>

    <h3 id="useEffect">Побочные эффекты</h3>

    <section>
        <div>
            <p>К побочным эффектам относятся:</p>
            <ul>
                <li>Сохранение данных в Storage браузера</li>
                <li>Отправка HTTP запросов к серверу</li>
                <li>Установка и управление таймерами</li>
                <li>Ect.</li>
            </ul>
            <p>Все эти задачи должны происходить вне нормальной оценки компонентов и циклов отображения,
                особенно если они могут задерживать/блокировать отображение.</p>
            <p>Для управления побочными эффектами существует хук "useEffect()", со следующим синтаксисом:</p>
            <pre>
                useEffect( () => {...}, [dependencies] )
            </pre>
            <p>Где, первый аргумент это функция, которая должна выполняться после каждой оценки компонента, ЕСЛИ
                указанные dependencies изменились.
                В эту функцию помещается код побочного эффекта.</p>
            <p>Второй же аргумент [dependencies] - это зависимости этого эффекта(если меняются, то функция
                выполняется).</p>
            <p>Как правило, во втором аргументе используют те же переменные, что и в первом.</p>
        </div>
    </section>

    <h3 id="Debouncing">Функция очистки</h3>

    <section>
        <div>
            <p>Функция очистки (debouncing) позволяет превратить несколько вызовов функции в течение определенного
                времени в один вызов, причем задержка начинает заново отсчитываться с каждой новой попыткой вызова.
                Возможно два варианта:</p>
            <ol>
                <li>
                    Реальный вызов происходит только в случае, если с момента последней попытки прошло время,
                    большее или равное задержке.
                </li>
                <li>
                    Реальный вызов происходит сразу, а все остальные попытки вызова игнорируются, пока не пройдет
                    время, большее или равное задержке,
                    отсчитанной от времени последней попытки.
                </li>
            </ol>
            <img src="./images/debouncing.png" alt="debouncing" id="useEffectExamp" width="644">
        </div>
    </section>

    <h3 id="useReducer">хук useReducer</h3>

    <section>
        <div>
            <p>хук useReducer помогает работать с состоянием так же как и хук useState, но используется для более
                сложных состояний.</p>
            <p>Иногда нужно работать с более сложными состояниями - например, с несколькими состояниями, с
                несколькими способами изменения состояния
                или с состоянием, зависящим от других состояний. В таком случае useState становится трудным в
                использовании, высока вероятность багов.</p>
        </div>
    </section>

    <h4>Использование useReducer</h4>
    <section>
        <div>
            <p>Так же как и useState, useReducer возвращает массив, и так же можно провести его
                деструктуризацию:</p>
            <pre>
                const [state, dispatchFunction] = useReducer(reducerFunction, initialState, initialFunction)
            </pre>
            <p>Где:</p>
            <ul>
                <li>
                    <p><strong>state</strong> - состояние, используемое в цикле переоценки/ перерисовки компонента.
                    </p>
                </li>
                <li>
                    <p><strong>dispatchFunction</strong> - функция, которая может быть использована для отправки
                        нового действия(action)
                        (то есть включающая обновление состояния)</p>
                </li>
                <li>
                    <p><strong>reducerFunction</strong> - функция, которая вызывается автоматически, когда
                        действие(action) отправлено(при помощи функции dispatchFunction).<br>
                        Она получает в качестве аргумента последнее состояние и должна возвращать обновленное
                        состояние.</p>
                </li>
                <li>
                    <p><strong>initialState</strong> - первоначальное состояние.</p>
                </li>
                <li>
                    <p><strong>initialFunction</strong> - функция для установки первоначального состояния
                        программно.</p>
                </li>
            </ul>
            <p>Пример использования useReducer при управлении формой:</p>
            <img src="/images/useReducer.png" alt="useReducer" width="644">
        </div>
    </section>

    <h3 id="useStateVSuseReducer">useState VS useReducer</h3>

    <section>
        <div>
            <table class="useReduserVSuseState">
                <caption>Когда использовать:</caption>
                <thead>
                <tr>
                    <td>useState</td>
                    <td>useReducer</td>
                </tr>
                </thead>
                <tbody>
                <tr>
                    <td>Основной инструмент для работы с состоянием</td>
                    <td>Удобен когда нужна большая гибкость</td>
                </tr>
                <tr>
                    <td>Удобен для независимых друг от друга состояний</td>
                    <td>Использовать, когда есть состояния тесно связанные друг с другом</td>
                </tr>
                <tr>
                    <td>Удобен в случаях, когда обновление состояния несложное и есть немного видов обновлений</td>
                    <td>Удобен в случаях, когда обновление состояния сложное</td>
                </tr>
            </table>
        </div>
    </section>

    <h3 id="Context">Context</h3>

    <section>
        <div>
            <p>В случае когда дерево компонентов слишком большое и требуется передать какую-то информацию от одного
                компонента к другому
                на большом удалении друг от друга, вместо подъема информации вверх можно использовать context.</p>
            <img src="./images/context.png" alt="context" width="644">
        </div>
    </section>

    <h4>Использование Context API</h4>
    <section>
        <div>
            <p>Для использования context нужно создать файл с переменной, в которую помещают "const Context =
                React.createContext()" где метод createContext() возвращает требуемый нам код.</p>
            <p>Далее мы импортируем созданный файл в нужный нам компонент, где мы оборачиваем нужные нам компоненты
                названием переменной и чтобы управлять информацией,
                задаем value={}:</p>
            <pre>
                &lt;Context.Provider
                    value={}
                    &gt;
                     Компоненты
                &lt;Context.Provider/&gt;
            </pre>
            <img src="./images/contextComponent.png" alt="contextComponent">
            <p>и так же через точку нужно предоставить доступ компонентам через Provider в родительском
                компоненте:</p>
            <img src="./images/ContextProvider.png" alt="ContextProvider">
            <p>Далее в компоненте, где требуются данные, мы оборачиваем JSX код следующим:</p>
            <pre>
                &lt;Context.Consumer&gt;
                    {(context) => {
                        return (
                           context.JSXcode
                        )
                    }
                &lt;Context.Provider/&gt;
            </pre>
            <p>Где мы создаем функцию с аргументом "context" с помощью которого мы уже передаем какую-то информацию
                в конечном итоге, и возвращаем весь обернутый код:</p>
            <img src="./images/ContextConsumer.png" alt="ContextConsumer">
        </div>
    </section>

    <h3 id="useContext">Хук useContext</h3>

    <section>
        <div>
            <p>При использовании хука useContext, нужно объявить переменную, которой присваивают данный хук,
                параметром которого, является импортированный context файл:</p>
            <pre>
                import React, {useContext} from "react";
                -------------------------------------------
                const context = useContext(ContextFile);

                context.a = ...
            </pre>
            <img src="./images/useContext.png" alt="useContext">
        </div>
    </section>

    <h3 id="dynamicContext">Динамический Context</h3>

    <section>
        <div>
            <p>Чтобы использовать дополнительные параметры в context, в value нужно дополнительно объявить то, что
                мы хотим передать:</p>
            <img src="./images/dynamicContext.png" alt="dynamicContext">
            <p>А в том месте где нам требуется данные так же нужно применить ранее заданную переменную context:</p>
            <img src="./images/applyingDynamicContext.png" alt="applyingDynamicContext">
        </div>
    </section>

    <h3 id="customProviderComponent">Кастомный компонент Context Provider</h3>

    <section>
        <div>
            <p>Данный компонент подразумевает, что мы в context файл пишем всю логику, и с помощью useContext потом
                импортируем ее,
                а сами компоненты используем для отображения или обработки информации:</p>
            <img src="./images/customComponentContext.png" alt="customComponentContext">
        </div>
    </section>

    <h3 id="contextRestriction">Ограничения context</h3>
    <section>
        <div>
            <p>React Context НЕ оптимизирован для частых изменений!(например если сотояние меняется с какой-то
                переодичностью)</p>
            <p>React Context НЕ СЛЕДУЕТ использовать, как полную замену всех взаимодействий компонентов и
                props!(короткие цепочки props лучше не заменять)</p>
        </div>
    </section>

    <h3 id="hookRooles">Правила использования хуков</h3>

    <section>
        <div>
            <ol>
                <li>Вызывать хуки можно только в функциях React:
                    <ul>
                        <li>В функциях-Компонентах</li>
                        <li>В кастомных хуках</li>
                    </ul>
                </li>
                <li>Вызывать хуки можно только на верхнем уровне:
                    <ul>
                        <li>Нельзя вызывать хуки во вложенных функциях</li>
                        <li>Нельзя вызывать хуки в блоках кода</li>
                    </ul>
                </li>
                <li>ВСЕГДА добавляйте все на что вы ссылаетесь внутри useEffect() в зависимости. <a
                        href="#useEffectExamp" class="hrefExampStyle">Пример</a></li>
            </ol>
        </div>
    </section>

    <h3 id="forwardRefUseImperativeHandle">forwardRef и useImperativeHandle</h3>

    <section>
        <div>
            <p>useImperativeHandle() хук позволяет взаимодействовать с компонентами императивно, не передавая
                состояния внутрь этих компонентов, меняя что-то в них,
                при помощи вызова функций внутри</p>
            <p>useImperativeHandle внутри скобок имеет два аргумента, первый - ref(этот ref используют, если ref
                этого компонента должны использоваться в другом компоненте),
                второй - функция, которая возвращает объект с данными, которые мы хотим задействовать в другом
                компоненте:</p>
            <p>Для того чтобы сделать ref аргумент доступным в другом компоненте, нам нужно экспортировать этот
                компонент особенным образом с помощью React.forwardRef((props, ref) => {return (JSX)})</p>
            <img src="./images/useImperativeHandle.png" alt="useImperativeHandle"><br>
            <img src="./images/importRef.png" alt="importedRef" width="644">
        </div>
    </section>

    <h3 id="howReactWorks">Как работает React</h3>

    <section>
        <div>
            <p>React отвечает за компоненты, за props(данные которые передаются в компоненты), за состояния(state),
                за контекст(context).</p>
            <p>ReactDOM же отвечает за отображение HTML элементов на экране(является интерфейсом для WEB)</p>
            <p>Каждый раз когда меняются props, state или context, происходит переоценка компонента(функция
                компонент запускаются по новой), в случае если между оценками компонента
                есть различия, в реальном DOM происходит перерендеринг, НО перерисовка происходит только там, где
                есть отличия, то что в оценках совпадает - не перерисовывается!</p>
        </div>
    </section>

    <h3 id="childComponentsEvaluation">Переоценка дочернего компонента</h3>

    <section>
        <div>
            <p>В случае, если происходит переоценка компонента, автоматически будут переоценены все его дочерние
                компоненты, даже если них ничего не меняется.</p>
        </div>
    </section>

    <h3 id="ReactMemo">Предотвращение Ненужных Переоценок при Помощи React.memo()</h3>

    <section>
        <div>
            <p>Для функциональных компонентов, для предотвращения ненужных переоценок можно использовать
                React.memo() при экспорте компонента:</p>
            <img src="./images/ReactMemo.png" alt="ReactMemo" width="644">
            <p>Данный метод позволяет исполнять переоценку компонента только в том случае, если были изменения ЕГО
                props.</p>
            <p>Использовать React.memo() везде нельзя, тк он заставляет React сравнивать props компонента, тратя на
                это производительность.</p>
            <p>Так же, из-за того что, memo сравнивает при помощи "===", то данный метод на прямую работает только к
                примитивным значениям(числа строки булинг null и тд),
                в случае с массивами, объектами(ссылочными данными), он не сработает, тк при очередной оценке
                компонента происходит их пересоздание и пересозданные объекты не ===.</p>
        </div>
    </section>

    <h3 id="useCallback">Предотвращение Пересоздания Функций при Помощи useCallback()</h3>

    <section>
        <div>
            <p>Хук UseCallback сохраняет указанную функцию в каком-то внутреннем хранилище React и далее будет
                постоянно использовать одну и ту же функцию при перезапуске функции-компоненте</p>
            <p>Внутри useCallback помещают нужный к React.memo() код первым аргументом, вторым же аргументом
                указывают массив с зависимостями(dependencies):</p>
            <img src="./images/useCallback.png" alt="useCallback" width="644">
            <p>Зависимости(deps) служат для того, чтобы в случае изменения какой-то переменной(записанной в
                зависимостях) хук useCallback сделал перезапись функции
                и поменял требуемые значения</p>
            <p>Для useState хука создается переменная при первой инициализации компонента, и может быть пересоздана
                по новой только в случае удаления компонента из DOM
                и очереного его добавления. Внутри переменной меняется только значение.</p>
        </div>
    </section>

    <h3 id="planningState">Обновление состояний и Планирование</h3>

    <section>
        <div>
            <p>В случае, если у нас есть какое-то состояние, и мы меняем его с помощью обновляющей
                функции(setFunction), то обновление состояния происходит не сразу,
                сначала происходит планирование обновления состояния! В большинстве случаев запланированное
                изменение состояния происходит быстро, но React оставляет за собой
                право отложить изменение состояния, в случае если параллельно идут более приоритетные задачи:</p>
            <img src="./images/planningState.png" alt="planningState" width="644">
            <p> React гарантирует, что для одного и того же состояния порядок изменения состояния будет
                сохранен:</p>
            <p>Рекомендуется использовать форму обновления состояния при помощи функций, если новое состояние
                зависит от предыдущего состояния.</p>
        </div>
    </section>

    <h3 id="classBasedComponents">Компоненты на основе классов</h3>

    <section>
        <div>
            <p>Компоненты на основе классов - устаревший способ создания компонентов. До версии React 16.8
                компоненты должны были создаваться на основе классов для управления
                состоянием.</p>
            <p>При создании компонентов на основе классов, компоненты определяются при помощи классов JS, метод
                render() определяет то, что отображается на веб странице.</p>
            <img src="./images/classBasedComponents.png" alt="classBasedComponents" width="644">
        </div>
    </section>

    <h3 id="classBasedComponentStructure">Структура Компонента на Основе Класса</h3>

    <section>
        <div>
            <p>Компоненты на основе класса имеют следующую стандартную структуру:</p>
            <pre>
                import {Component} from "react";

                class ComponentName extends Component{

                    render () {
                        return &lt; JSX /&gt;
                    }
                }

                export default ComponentName;
            </pre>
            <p>extends Component служит для добавления свойства props, далее это свойство употребляется так:
                this.props.argument</p>
            <img src="./images/classBasedComponent.png" alt="classBasedComponent">
            <p>Компоненты на основе классов могут работать в связке с функциональными компонентами в любой
                наследственной последовательности.</p>

        </div>
    </section>

    <h3 id="workWithStateInClassBasedComponent">Работа с Состояниями и Событиями в Компонентах на Основе Класса</h3>

    <section>
        <div>
            <p>Для определения состояния в классовых компонентах используют constructor(){}. Внутри конструктора
                инициализируется состояние this.state = {}.</p>
            <p>В компонентом на основе классов состояние ВСЕГДА является объектом!!!(В функциональных компонентах
                состояние может быть чем угодно)</p>
            <p>Чтобы изменить состояние в неком созданном методе используют this.setState({параметр ВСЕГДА
                объект!!!}). При использовании setState происходит не изменение
                состояния, а слияние двух объектов(двух состояний).</p>
            <pre>
                    ...
                    constructor() {
                        super();
                        this.state = {
                            someState: value
                        }
                    }

                    someMethod() {
                       this.setState ({
                           someState: newValue
                       })
                    }
                    ...
                </pre>
            <p>Там где нужно получить доступ к состоянию нужно использовать this.state.someState</p>
            <p>чтобы вызвать нужный метод, нужно использовать this.someMethod.bind(this)</p>
            <img src="./images/classBasedComponentState.png" alt="classBasedComponentState" width="644">
        </div>
    </section>

    <h3 id="lifeCycleMethods">Жизненный Цикл Компонентов на Основе Классов</h3>

    <section>
        <div>
            <p>Существуют три метода жизненного цикла компонентов, которые выполняли функцию useEffect:</p>
            <ol>
                <li>componentDidMount() - вызывается когда компонент был установлен(оценен и отображен). Эквивалент
                    useEffect(... , [пустой])
                </li>
                <li>componentDidUpdate() - вызывается когда компонент обновлен(переоценен и переотображен).
                    Эквивалент useEffect(... , [someValue])
                </li>
                <li>componentWillUnmount() - вызывается перед тем, как компонент будет удален из DOM. Эквивалент
                    функции очистки в useEffect(() => {return()=>{...}}, [])
                </li>
            </ol>
            <img src="./images/lifeCycleMethods.png" alt="lifeCycleMethods" width="644">
        </div>
    </section>

    <h3 id="classBasedComponentContext">Компоненты на Основе Классов и Контекст</h3>

    <section>
        <div>
            <p>В компонентах на основе классов можно так же определять контекст и далее предоставлять этот контекст
                при помощи Provider</p>
            <p>Чтобы использовать контекст есть два метода - оборачивание JSX кода &lt;someContextComponent.Consumer&gt;
                JSX &lt;someContextComponent.Consumer/&gt;
                и static contextType = someContextComponent (использовать два контекста нельзя)</p>
            <p>Использование компонента в компоненте в качестве аргумента - this.context.someContext</p>
            <img src="./images/classBasedComponentContext.png" alt="classBasedComponentContext" width="644">
        </div>
    </section>

    <h3 id="errorBoundaries">Error Boundaries</h3>

    <section>
        <div>
            <p>В случае если происходит какая-то ошибка, и нужно чтобы приложение не крашилось и ошибку нужно
                поймать в другом компоненте - используют ErrorBoundary.</p>
            <p>При использовании конецепции ErrorBoundary, сначала создается компонент на основе класса с
                соответствующим названием, в котором вызывают
                метод componentDidCatch(error) {} и метод render(){return this.props.children}</p>
            <p>Life-Cycle метод componentDidCatch() будет вызываться когда дочерний элемент генерирует ошибку,
                отлавливать ее и обеспечивая работу приложения.</p>
            <img src="./images/errorBoundaries.png" alt="errorBoundaries" width="644">
        </div>
    </section>

    <h3 id="connectinWithBD">Соединение с базой данных</h3>

    <section>
        <div>
            <p>React приложение НЕЛЬЗЯ соединять на прямую с базой данных! Т.к. реквизиты для доступа к БД будут не
                защищенными и доступными в браузере.</p>
            <p>Доступ к базе данных получается из Back-End приложения:</p>
            <img src="./images/BDconnection.png" alt="BDconnection" width="644">
        </div>
    </section>

    <h3 id="getFetching">Отправка GET запроса</h3>

    <section>
        <div>
            <p>Отправка get запроса осуществляется как с помощью стандартного fetch запроса, так и с помощью других
                пакетов(например axios).</p>
            <p>Так же можно пользоваться async/await синтаксисом:</p>
            <img src="./images/fetchAsyncAwait.png" alt="fetchAsyncAwait" width="644">
        </div>
    </section>

    <h3 id="fetchState">Управление загрузкой и состояниями данных</h3>

    <section>
        <div>
            <p>Чтобы управлять загрузкой и состоянием данных дабы пользователь понимал, что приложение не зависло, а
                ждет ответ от сервера, можно пользоваться переменными с булевыми значениями, которые помещаются до
                получения запроса и после, и далее используются где-то в UI в качестве индикаторов загрузки:</p>
            <img src="./images/fetchState.png" alt="fetchState" width="644">
        </div>
    </section>

    <h3 id="reactRouteTryCatch">Обработка HTTP Ошибок</h3>

    <section>
        <div>
            <p>Для того чтобы выводить ошибки запросов в UI, необходимо обернуть код в try/catch блок, при помощи
                значения response.ok(true/false), в случае если response.ok = false генерировать ошибку, которая
                далеее
                будет обрабатываться в catch блоке, обновляя дополнительное состояние параметром error.message:</p>
            <img src="./images/reactTryCatch.png" alt="reactTryCatch" width="644">
        </div>
    </section>

    <h3 id="reactRouteUseEffectForFetch">Использование useEffect для Запросов</h3>

    <section>
        <div>
            <p>Для того чтобы загружать данные с сервера каждый раз когда загружается компонент, нужно использовать
                useEffect и в зависимостях указать саму функцию, дабы не происходило зацикливание загрузки,
                useEffect
                используется всегда, если загрузка данных
                происходит не по клику пользователя. Так же функцию с fetch запросом оборачивают в useCallback дабы
                не
                происходило изменение этой функции при обновлении компонента, в deps же указывают внешние
                зависимости в случае если таковые существуют.</p>
            <img src="./images/fetchUseEffectUseCallback.png" alt="fetchUseEffectUseCallback" width="644">
        </div>
    </section>

    <h3 id="postFetching">Отправка Запроса POST</h3>

    <section>
        <div>
            <p>Для того чтобы в React приложении делать POST запросы/отправку данных - используется стандартный
                синтаксис JavaScript:</p>
            <img src="./images/reactPOSTfetch.png" alt="reactPOSTfetch" width="644">
        </div>
    </section>

    <h3 id="customReactRouteHook">Создание Функции Custom React Hook</h3>

    <section>
        <div>
            <p>Как и обычные компоненты, кастомные хуки помещаются в отдельную папку. Имя кастомной функции
                обязательно
                должно начинаться со слова "use". В каждом компоненте в котором будет вызываться кастомный хук,
                будет
                создаваться собственное состояние. В кастомных хуках можно возвращать что угодно и далее
                использовать
                это присваивая переменной при вызове кастомного хука:</p>
            <img src="./images/creationCustomHooks.png" alt="creationCustomHooks" width="644">
        </div>
    </section>

    <h3 id="customHooksParams">Конфигурация Custom Hooks</h3>

    <section>
        <div>
            <p>Функции можно сделать конфигурируемыми при помощи передачи функциям параметров:</p>
            <img src="./images/customHooksParams.png" alt="customHooksParams" width="644">
        </div>
    </section>

    <h3 id="workingWithReactRouteForm">Работа с вводом данных из форм</h3>

    <section>
        <div>
            <p>Валидацию формы можно проводить:</p>
            <ol>
                <li>Когда форма отправлена.
                    <ul>
                        <li>Позволяет пользователю ввести валидное значение перед тем, как выводить в интерфейс
                            предупреждение для него.
                        </li>
                        <li>Позволяет избежать показа лишних предупреждений, но предоставляет пользователю фидбэк
                            слишком
                            поздно.
                        </li>
                    </ul>
                </li>
                <li>Когда инпут теряет фокус
                    <ul>
                        <li>Позволяет пользователю ввести валидное значение перед тем, как выводить в интерфейс
                            предупреждение для него.
                        </li>
                        <li>Полезно использовать для формы, которой не коснулись</li>
                    </ul>
                </li>
                <li>При каждом нажатии клавиши
                    <ul>
                        <li>Предупреждает пользователя не давая возможности ввести валидное значение.</li>
                        <li>Предоставляет пользователю конкретный фидбэк, если использовать для невалидного ввода.
                        </li>
                    </ul>
                </li>
            </ol>
            <p>Если значение из форм нужно однажды, когда форма отправлена, то, тогда как правило используют useRef
                хук.</p>
            <p>Если нужно значение инпута обновленное после каждого ввода для мгновенной валидации, тогда используют
                хук
                useState. Так же useState используют, когда хотят очистить инпут после нажатия кнопки отправки
                формы.</p>
            <img src="./images/formUseRefState.png" alt="formUseRefState" width="644">
        </div>
    </section>

    <h3 id="reduxAPI">Библиотека Redux</h3>

    <section>
        <div>
            <p>Redux это система управления состояниями: состояниями для нескольких компонентов и состоянием уровня
                приложения.</p>
            <p>Состояния бывают трех видов:</p>
            <ol>
                <li>Локальные состояния</li>
                <li>Состояние для нескольких компонентов</li>
                <li>Состояние уровня приложения</li>
            </ol>
            <p>Локальные состояния это состояния которые принадлежат одному компоненту(например состояние ввода
                данных
                пользователем). Такие состояния должны управляться внутри компонента при помощи useState или
                useReducer</p>
            <p>Состояние для нескольких компонентов(кросс компонентное состояние) это состояние влияющее на
                несколько
                компонентов(например состояние видимости модального окна). Такое состояние так же может управляться
                при
                помощи useState и useReducer, но уже требуются цепочки props(props drilling)</p>
            <p>Состояние уровня приложения это состояние влияющее на все(или почти все) компоненты(например статус
                аутентификации пользователя). Так же может управляться при помощи useState и useReducer и так же
                требуются цепочки props</p>
            <img src="./images/reactAppState.png" alt="reactAppState" width="644">
            <p>Redux решает проблему длинных цепочек props(так же как и useContext)</p>
        </div>
    </section>

    <h3 id="reduxVSReactContext">Redux VS React Context</h3>

    <section>
        <div>
            <p>React Context имеет потенциальные проблемы в использовании, и в таком случае нужно использовать Redux
                библиотеку, если же таких проблем не возникает можно использовать как и React Context так и Redux, и
                даже оба этих подхода в разных местах одного приложения.</p>
            <p>Недостатки React Context:</p>
            <ul>
                <li>Сложность создания/управления состояниями. В больших приложениях использование React Context
                    может
                    привести к глубокой вложенности JSX кода или к "раздуванию" компонентов Context Provider.
                </li>
                <li>Потеря производительности приложения. React Context не оптимизирован для часто меняющихся
                    состояний
                </li>
            </ul>
        </div>
    </section>

    <h3 id="reduxBasics">Как работает Redux</h3>

    <section>
        <div>
            <p>Концепция Redux состоит в том, чтобы использовать одно центральное хранилище данных(состояний) в
                приложении. Все состояния со всех компонентов приложения сохраняются в этом хранилище. Чтобы
                компонент
                имел доступ к состоянию в хранилище, создается т.н. подписка на центральное хранилище данных.</p>
            <p>Компоненты НИКОГДА не манипулируют данными в хранилище! Для этого используется функция
                Reducer(Функция
                Reducer - это общая концепция, не путать с useReducer хуком!). Компоненты отправляют actions(простые
                JS
                объекты, которые описывают тип операций), далее Redux переадреcсовывает эти actions в функцию
                Reducer,
                считываются желаемые операции описанные в actions, после чего они выполняются в функции Reducer,
                создается новое состояние, которое заменяет старое состояние хранимое в центральном хранилище данных
                и
                далее хранилище уведомляет подписанные компоненты об изменении состояния.</p>
            <img src="./images/reduxBasics.png" alt="reduxBasics" width="644">
        </div>
    </section>

    <h3 id="reduxStoreCreation">Создание хранилища</h3>

    <section>
        <div>
            <p>Для того чтобы работать с Redux, требуется установить с помощью npm install в командной строке
                "redux" и
                "react-redux".</p>
            <p>Далее создается файл в котором создают хранилище с помощью "redux.legacy_createStore()" и функцию
                Reducer, функции redux.legacy_createStore() в качестве параметра передают функцию Reducer:</p>
            <p>Так же через action можно передать дополнительные свойства, которые далее будут вызываться в функции
                диспетчере</p>
            <img src="./images/reduxStoreCreation.png" alt="reduxStoreCreation" width="644">
        </div>
    </section>

    <h3 id="reduxStoreProviding">Предоставление хранилище всему React приложению</h3>

    <section>
        <div>
            <p>Для того чтобы предоставить хранилище всему React приложению, в index.js файле (где отображается
                корневой
                компонент приложения) нужно импортировать {Provider} из "react-redux" и обернуть им корневой "App"
                компонент, так же в Provider в атрибуте "store" нужно указать созданное хранилище.</p>
            <img src="./images/reduxStoreProviding.png" alt="reduxStoreProviding" width="644">
        </div>
    </section>

    <h3 id="useSelector">Использование Данных Redux в React Компонентах</h3>

    <section>
        <div>
            <p>Для того чтобы получать данные о состоянии из хранилища, в React компоненте нужно импортировать либо
                кастомный хук useSelector, который подписывает компонент на определенное состояние, либо хук
                useStore,
                который дает непосредственный доступ ко всему хранилищу.</p>
            <p>При вызове кастомного хука в параметрах нужно передать функцию, которая будет определять какую часть
                данных нужно извлечь из хранилища.</p>
            <pre>
                import {useSelector} from "react-redux";

                const someComponent = () => {
                   const someVar = useSelector((state) => state.stateName)
                   ......................................................
                }
            </pre>
            <img src="./images/useSelector.png" alt="useSelector" width="644">
        </div>
    </section>

    <h3 id="useDispatch">Отправка actions</h3>

    <section>
        <div>
            <p>Для отправки actions используется хук useDispatch. При вызове хука useDispatch, его нужно присвоить
                переменной и так же не требуется передача параметров. Созданной переменной присваевается функция
                диспетчер, которой в параметрах нужно передать объект {type: 'actionName'} и допольнительные
                свойства
                actions если такие были определены в хранилище(как number в примере):</p>
            <pre>
                import {useDispatch} from "react-redux";

                const someComponent = () => {
                   const someDispatchFunction = useDispatch();
                }

                someDispatchFunction({
                   type: 'actionName'
                })
            </pre>
            <img src="./images/useDispatch.png" alt="useDispatch" width="644">
        </div>
    </section>

    <h3 id="reactReduxInClassBasedComponents">Redux в Классовых Компонентах</h3>

    <section>
        <div>
            <p>Для того чтобы в классовых компонентах использовать хранилище состояний, нужно импортировать функцию
                {connect} из "react-redux". При экспорте классового компонента, нужно перед классом дописать
                "connect()"
                а сам классовый компонент передать в качестве параметра во вторую функцию, которую возвращает
                connect, в
                первую же функцию нужно передать в качестве параметров две функции - mapStateToProps и
                mapDispatchToProps, первая из которых, возвращает объект содержащий ссылку на состояния, а второй
                объект
                содержащий типы actions</p>
            <pre>
                import {connect} from "react-redux";

                class someClassComponent extends Component {
                   someHandler() {
                      this.props.someFunction();
                   }

                   render() {
                      return (
                         < div>
                            < div>{this.props.someStateName}< /div>
                            < button onClick={this.someHandler.bind(this)}>press< /button>)
                         < /div>
                   }
                }

                const mapStateToProps = (state) => {
                   return {
                      someState: state.someStateName
                   }
                }

                const mapDispatchToProps = (dispatch) => {
                   return {
                      someFunction: () => dispatch({type: 'increment'}),
                   }
                }

                export default connect(mapStateToProps, mapDispatchToProps)(someClassComponent);
            </pre>
            <img src="./images/classBasedComponentWithRedux.png" alt="classBasedComponentWithRedux"
                 width="644">
        </div>
    </section>

    <h3 id="workingWithSeveralStates">Работа с Несколькими Свойствами Состояний</h3>

    <section>
        <div>
            <p>Чтобы управлять несколькими состояниями в одном хранилище, в качестве параметра функции Reducer нужно
                передать в объекте через запятую другие состояния, и так же if блоком определять для них тип action,
                тк
                объект переданный в параметр функции Reducer становится больше, его лучше вынести в переменную. Так
                же
                эти состояния нужно дублировать с дефолтными значениями в каждый action. Чтобы изменять
                дополнительное
                состояние, к нему применяется тот же подход:</p>
            <img src="./images/workingWithSeveralStates.png" alt="workingWithSeveralStates" width="644"><br>
            <img src="./images/changingAdditionalState.png" alt="changingAdditionalState" width="644">
        </div>
    </section>

    <h3 id="reduxRules">Правилa Работы с Redux Состоянием</h3>

    <section>
        <div>
            <p>Всегда нужно возвращать новый объект состояния, насколько бы сложен объект ни был, так же нужно
                возвращать все состояния объекта даже если их значения не меняются, просто нужно сделать отссылку к
                старому состоянию!</p>
            <img src="./images/reduxRules.png" alt="reduxRules" width="644">
        </div>
    </section>

    <h3 id="reduxToolkit">Redux Toolkit</h3>

    <section>
        <div>
            <p>В случае если функция Reducer сильно раздувается состояниями и action, упростить работу с состояниями
                поможет библиотека Redux Toolkit</p>
            <p>Установив Redux Toolkit в командной строке в папку с проектом с помощью команды "npm install
                @reduxjs/toolkit", открывается доступ к функции createSlice. Импортировав ее в файл можно комфортно
                конфигурировать состояния следующим синтаксисом:</p>
            <pre>
                import {createSlice} from "@reduxjs/toolkit";

                const someStateVar = createSlice({
                   name: "someStateName",
                   initialState: someInitialState,
                   reducers:{
                      someFunctionName(state, action){
                         state.someInitialState +-/* action.payload
                      }
                   }
                })
            </pre>
            <p>Далее нужно импортировать configureStore в файл для того, чтобы произвести экспорт reducers
                функций:</p>
            <pre>
                import {createSlice, configureStore} from "@reduxjs/toolkit";

                const store = configureStore({
                   reducer: {
                      someReducerName: someStateVar.reducer
                   }
                })

                export default store;
            </pre>
            <p>Так же нужно произвести экспорт actions следующим синтаксисом:</p>
            <pre>
                export const someStateActions = someStateVar.actions;
            </pre>
            <p>Чтобы воспользоваться состояниями созданными createSlice, импортируем старым способом store и
                переменную
                с actions в
                нужный файл и в dispatch функции вызываем функции редьюсеры через созданную переменную с actions,
                если
                же ранее в функции редьюсере была указана actions то в качестве параметра можно указать требуемое
                значение:</p>
            <pre>
                dispatchFunction(someStateActions.someFunctionName(any))
            </pre>
            <img src="./images/createSlice.png" alt="createSlice" width="644"><br>
            <img src="./images/createdSliceReducerUsage.png" alt="createdSliceReducerUsage" width="644">
            <p>Пример использования нескольких слайсов:</p>
            <img src="./images/severalSlicesUsage1.png" alt="severalSlicesUsage1" width="644"><br>
            <img src="./images/severalSlicesUsage2.png" alt="severalSlicesUsage2" width="644">
            <p>В случае если слайсов много, их можно вынести в отдельные файлы и импортировать в хранилище:</p>
            <img src="./images/dividinSlices.png" alt="dividinSlices" width="644"><br>
            <img src="./images/optimisedStore.png" alt="optimisedStore" width="644">
        </div>
    </section>

    <h3 id="reduxUseEffect">Работа с Побочными Эффектами в Redux</h3>

    <section>
        <div>
            <p><strong>Reducers должны быть чистыми синхронными функциями без побочных эффектов!!!</strong></p>
            <img src="./images/reduxUseEffect.png" alt="reduxUseEffect" width="644">
        </div>
    </section>

    <h3 id="frontendvsBackend">Frontend vs Backend</h3>

    <section>
        <div>
            <p>Существует два варианта взаимодействия frontEnd и backEnd:</p>
            <img src="./images/frontendvsBackend.png" alt="frontendvsBackend" width="644">
        </div>
    </section>

    <h3 id="logicPlace">Где размещать логику?</h3>

    <section>
        <div>
            <p>Размещение логики приложения зависит от следующих факторов:</p>
            <img src="./images/logicPlace.png" alt="logicPlace" width="644">
        </div>
    </section>

    <h3 id="actionCreatorSlice">Запись и извлечение данных с сервера</h3>

    <section>
        <div>
            <p>Для записи данных на сервер используют useEffect внутри которого помещают fetch запрос. В случае если
                нужно постоянно перезаписывать данные на сервере, при каких-то манипуляциях данными пользователем -
                используют PUT метод:</p>
            <img src="./images/fetchInRedux.png" alt="fetchInRedux" width="644">
            <p>Так же возможно использование action creator thunk. Thunk - это функция откладывающая action. Action
                creator возвращает не action, а функцию которая уже возвратит функцию. Данный метод имеет следующий
                синтаксис -
                в слайс файле создается кастомный action который возвращает асинхронную функцию с параметром
                "dispatchAction",
                далее вызывают dispatchAction и в ее параметры указывают нужный(ые) action, создают через константу
                асинхронную функцию в которую вкладывают fetch запрос и в try/catch блоке вызывают эту функцию,
                далее
                всю эту конструкцию вызывают в useEffect при помощи useDispatch:</p>
            <p>Пример отправки данных на сервер:</p>
            <img src="./images/actionCreatorSlice.png" alt="actionCreatorSlice" width="644">
            <p>Пример запроса данных с сервера:</p>
            <img src="./images/reduxGetFetch.png" alt="reduxGetFetch" width="644">
            <p>Вызов функций с помощью useEffect:</p>
            <img src="./images/useEffectInRedux.png" alt="useEffectInRedux">
        </div>
    </section>

    <h3 id="createAsyncThunk">createAsyncThunk в Redux Toolkit</h3>

    <section>
        <div>
            <p>По своей сути createAsyncThunk это тот же action creator thunk только в оболочке Redux Toolkit, его
                синтаксис выглядит следующим образом:</p>
            <img src="./images/createAsyncThunk.png" alt="createAsyncThunk">
            <p>С помощью createAsyncThunk (перед createSlice) мы конфигурируем запрос на сервер, далее в слайсе
                после
                Reducers мы
                конфигурируем extraReducers с аргументом (bilder) и метода addCase мы обрабатываем наш запрос в трех
                состояниях- pending, fulfilled, rejected, показывая начало загрузки данных, получения и обработки
                данных
                и вывод
                сообщения об ошибке соответственно:</p>
            <img src="./images/extraReducer.png" alt="extraReducer">
            <p>В первом аргументе (типе) "typePrefix" мы указываем имя слайса, и через слеш наше название-индикатор
                при
                помощи которого, в DevTools мы будем проводить дебаг приложения.</p>
        </div>
    </section>

    <h3 id="thunkApi">ThunkApi в Redux Toolkit</h3>

    <section>
        <div>
            <p>В блоке аргументов createAsyncThunk мы можем использовать ThunkApi для дополнительной конфигурации
                запроса, данный аргумент обладает следующими методами:</p>
            <ul>
                <li>dispatch: the Redux store dispatch method(Позволяет вызвать метод из Reducers)</li>
                <li>getState: the Redux store getState method(Позволяет получить состояние нужной переменной)</li>
                <li>extra: the "extra argument" given to the thunk middleware on setup, if available</li>
                <li>requestId: a unique string ID value that was automatically generated to identify this request
                    sequence(Позволяет получить айди запроса)
                </li>
                <li>signal: an AbortController.signal object that may be used to see if another part of the app
                    logic
                    has marked this request as needing cancelation(Позволяет отменить запрос, например в случае
                    долгого
                    выполнения).
                </li>
                <li>rejectWithValue(value, [meta]): rejectWithValue is a utility function that you can return (or
                    throw)
                    in your action creator to return a rejected response with a defined payload and meta. It will
                    pass
                    whatever value you give it and return it in the payload of the rejected action. If you also pass
                    in
                    a meta, it will be merged with the existing rejectedAction.meta(Позволяет сделать реджект в
                    случае
                    если полученные данные нас не устраивают, например пришел пустой массив значит мы делаем
                    реджект).
                </li>
                <li>fulfillWithValue(value, meta): fulfillWithValue is a utility function that you can return in
                    your
                    action creator to fulfill with a value while having the ability of adding to
                    fulfilledAction.meta.(Можно использовать в случае если к полученной информации нужно добавить
                    какую-то другую информацию)
                </li>
            </ul>

            <p>Пример конфигурации параметров запроса при помощи getState:</p>
            <img src="./images/getState.png" alt="getState">
        </div>
    </section>

    <h3 id="reduxDevTools">Redux DevTools</h3>

    <section>
        <div>
            <p>При помощи Redux DevTools производится отладка приложения использующего Redux.</p>
            <p><a href="https://github.com/reduxjs/redux-devtools" target="_blank">Гайд по использованию Redux
                DevTools</a></p>
        </div>
    </section>

    <h3 id="reactRouterBasics">React Router. Что такое маршрутизация?(Routing)</h3>

    <section>
        <div>
            <p>Особенностью React приложения является единый url который всегда направляет пользователя на
                домашнюю/стартовую страницу.</p>
            <p>Для создания различных эндпоинтов с разным отображаемым контентом url обрабатывается React на стороне
                клиента, таким образом происходит получение другого контента без загрузки нового HTML файла</p>
            <img src="./images/basicsReactRouter.png" alt="basicsReactRouter" width="644">
            <p>Подробную информацию можно найти на <a href="https://reactrouter.com/en/main" target="_blank">официальном
                сайте разработчиков React Router</a></p>
            <p>Чтобы работать с React Router в консоли в папку с проектом нужно ввести "npm install
                react-router-dom(@5
                если нужна 5тая версия)"</p>
        </div>
    </section>

    <h3 id="urlInfo">Что такое URL?</h3>

    <section>
        <div>
            <img src="./images/urlIno.png" alt="urlIno" width="644">
            <p>В случае если в троке запросов несколько параметров, они разделяются знаком амперсанда (&).</p>
            <p>У корневого домена могут быть под домены</p>
        </div>
    </section>

    <h3 id="httpMethods">Методы HTTP запросов</h3>

    <section class="httpMethodsSection">
        <div>
            <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/GET" target="_blank">GET</a> —
                запрашивает контент из сервера. Поэтому у запросов с методом GET нет тела сообщения. Но при
                необходимости можно отправить параметры через path.</p>
            <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/POST" target="_blank">POST</a> —
                публикует информацию на
                сервере. POST-запрос может передавать разную информацию: параметры в формате ключ=значение, JSON,
                HTML-код или даже файлы. Вся информация передается в теле сообщения.</p>
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" target="_blank">HEAD</a> —
                запрашивает ресурс так же, как и метод GET, но без тела ответа.</p>
            <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/PUT" target="_blank">PUT</a> —
                заменяет
                все текущие представления ресурса данными запроса.</p>
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" target="_blank">DELETE</a>
                —
                удаляет указанный ресурс.</p>
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/CONNECT"
                  target="_blank">CONNECT</a> —
                устанавливает "туннель" к серверу, определённому по ресурсу.</p>
            <p><a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Methods/OPTIONS" target="_blank">OPTIONS</a>
                —
                используется для описания параметров соединения с ресурсом.</p>
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/TRACE" target="_blank">TRACE</a> —
                выполняет вызов возвращаемого тестового сообщения с ресурса.</p>
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" target="_blank">PATCH</a> —
                используется для частичного изменения ресурса.</p>
        </div>
    </section>

    <h3 id="reactRouter">Работа с React Router v5</h3>

    <section>
        <div>
            <p>Компоненты учавствующие в маршрутизации по конвенции лучше помешать не в components папку, а другую,
                например pages.</p>
            <p>Для того чтобы установить маршрутизацию, в корневой файл (например App.js) импортируют компонент
                {Router}
                из "react-router-dom", далее в return блоке помещают Router компонент с props "/someUrlName" где
                "someUrlName" это предполагаемый энд-поинт который будет выводить пользователя на компонент который
                разработчик поместит между < Router>< Some Component>< /Router>. Далее требуется в index.js
                импортировать компонент {BrowserRouter} из "react-router-dom" и обернуть им App компонент:</p>
            <pre>
                import {Router} from "react-router-dom";

                function App() {
                    return &lt;div&gt;
                       &lt;Route path="/linkToSomeComponent1"&gt;
                           &lt;someComponent1/&gt;
                       &lt;/Route&gt;
                       &lt;s path="/linkToSomeComponent2"&gt;
                           &lt;someComponent2/&gt;
                       &lt;/Route&gt;
                    &lt;/div&gt;

                ----------------------------------------
                import {BrowserRouter} from "react-router-dom";
                ...
                root.render(&lt;BrowserRouter&gt;&lt;App/&gt;&lt;/BrowserRouter&gt;);
            </pre>
            <img src="./images/reactRouterBasics.png" alt="reactRouterBasics" width="644">
        </div>
    </section>

    <h3 id="linkInRouterApp">Работа со Ссылками</h3>

    <section>
        <div>
            <p>Для того чтобы создать иллюзию перехода по ссылкам в файл, где будет имитация ссылок нужно
                импортировать
                компонент Link и создать "ссылку" в нужном месте указав в props "to" ту ссылку, которая ведет на
                компонент в
                Router:</p>
            <pre>
                import {Link} from "react-router-dom";
                ...
                &lt;Link to="/linkToSomeComponent1(2)"&gt;someComponent1(2)&lt;/Link&gt;
            </pre>
            <img src="./images/linkInRouterApp.png" alt="linkInRouterApp" width="644">
        </div>
    </section>

    <h3 id="navLinkComponent">Компонент NavLink</h3>

    <section>
        <div>
            <p>Для того чтобы в панели навигации выделять ту "ссылку" на странице которой находится пользователь в
                текущий момент, вместо Link компонента используют NavLink компонент, в props activeClassName
                указывают
                нужный стиль для смены стиля:</p>
            <pre>
                import {NavLink} from "react-router-dom";
                ...
                &lt;NavLink activeClassName={styles.active} to="/linkToSomeComponent1(2)"&gt;someComponent1(2)&lt;/NavLink&gt;
            </pre>
            <img src="./images/navLinkInReactRouterApp.png" alt="navLinkInReactRouterApp" width="644">
        </div>
    </section>

    <h3 id="dynamicRouter">Добавление Динамических Маршрутов с Параметрами</h3>

    <section>
        <div>
            <p>В случае, если требуется отобразить страницу динамически, в конце ссылки props path добавляют
                дополнительную часть "/:anyURL", где "anyURL" является обрабатываемым параметром:</p>
            <img src="./images/dynamicRouter.png" alt="dynamicRouter">
            <p>Для того чтобы извлечь динамические параметры из "anyURL", в требуемый файл нужно импортировать
                кастомный
                хук "useParams":</p>
            <pre>
                import {useParams} from "react-router-dom";
                ...
                const params = useParams();
            </pre>
            <p>В итоге params.anyURL будет в себе содержать ту часть URL которую ввели в адресной строке после
                основного
                адреса, именно по ней
                можно динамически отображать информацию в компоненте на прямую либо при помощи запроса на
                сервер.</p>
        </div>
    </section>

    <h3 id="switchComponent">Использование компонента Switch</h3>

    <section>
        <div>
            <p>Т.к. при переходе по "ссылкам" из-за особенностей поведения React Router происходит совмещение
                компонентов на одной странице, в случае если требуется отобразить один компонент, используют
                кастомный
                компонент {Switch}, которым оборачивают все Route. При таком подходе будет отображено только один
                компонент, НО в случае когда части url совпадают,
                будет отражен первый компонент в списке и для того, чтобы исключить такое поведение в Route
                используют
                props "exact", либо перемещают Route с более коротким url ниже по списку:</p>
            <img src="./images/switchComponentReactRouter.png" alt="switchComponentReactRouter">
        </div>
    </section>

    <h3 id="inneredRouters">Вложенные Маршруты, Перенаправление и Предупреждение Пользователя и Работа с Параметрами
        Запроса</h3>

    <section>
        <div>
            <p>Вложенные маршруты создаются при помощи компонента Route в том компоненте где нам нужно отобразить
                дополнительную информацию при дописывании дополнительной части ссылки. При использовании данной фичи
                требуется соблюдать соответсвие начальных частей ссылок:</p>
            <img src="./images/inneredRouters.png" alt="inneredRouters">
            <p>В случае если с доменного имени без дополнительных эндпоинтов требуется перенаправлять
                пользователя на какой-то компонент(стартовую страницу например), можно импортировать компонент
                {Redirect} в props "to" которого мы указываем ссылку на требуемый компонент. Так же компонент
                Redirect
                оборачивается Route с props "path='/'" и props exact:</p>
            <img src="./images/redirectReactRouter.png" alt="redirectReactRouter">
            <p>В случае если требуется обработать невалидный ввод url после доменного имени, например требуется
                вывести
                в UI "Страница не найдена", создается компонент с соответствующим предупреждением и компонентом
                Route
                оборачиваем его в конце всего списка Route, так же в props path требуется указать "*":</p>
            <pre>
                ...
                &lt;Route path='*'&gt;
                   &lt;PageNotFoundComponent&gt;
                &lt;/Route&gt;
            </pre>
            <p>В случае, если требуется после завершения работы какой-то функции(отправка формы на сервер например)
                перенаправить пользователя на другую страницу - применяется хук useHistory(). Создается переменная,
                которой присваивается вызов хука useHistory() и далее эта переменная вызывается с методом push()
                либо
                replace() в параметрах которых указывают требуемый путь после доменного имени. Push и Replace в
                данном
                случае отличаются тем, что в случае push кнопкой возврата будет переход на предыдущую страницу, а
                вслучае replace - нет:</p>
            <pre>
                import {useHistory} from "react-router-dom";
                ...
                history.push('/someLink');
                // или
                history.replace('/someLink');
            </pre>
            <p>В случае если требуется предупреждать пользователя, когда он заполняет например форму и случайно жмет
                кнопки перехода на другую страницу, можно использовать кастомный компонент {Prompt}. Данный
                компонент
                имеет два props - when и message, где when принимает в параметры boolean значения, которые меняет
                пользователь своими действиями, а message - функцию с параметром (location), которая возвращает
                текст
                предупреждения: </p>
            <pre>
                &lt;Prompt
                   when={booleanValue}
                   message={(location) => {
                      return 'Вы точно хотите покинуть страницу? Данные в форме в случае перехода будут потеряны!'
                   }}
                /&gt;
            </pre>
            <p>Для работы с параметрами запроса используют хук useLocation:</p>
            <img src="./images/useLocation.png" alt="useLocation" width="644">
            <p>Для гибкого кода маршрутизации используют хук useRouteMatch. Переменной присваивают вызов хука
                useRouteMatch() и далее эту переменную с ".path" присваивают в path нужного Route. Таким же образом
                можно воспользоваться useLocation с атрибутом ".pathname". Так же в props компонента Link можно
                использовать данную переменную, но уже с ".url". Данный способ позволяет настроить путь
                динамически.</p>
            <img src="./images/useRouteMatch.png" alt="useRouteMatch" width="644">
        </div>
    </section>

    <h3 id="RTQQueryBasics">Основной функционал Redux Toolkit Query(RTK Query)</h3>

    <section>
        <div>
            <p>Подробно можно почитать на <a href="https://redux-toolkit.js.org/tutorials/rtk-query">
                Redux Toolkit Портале</a></p>

            <p>RTK Query дефолтно включена в Redux Toolkit, скачивать дополнительно ничего не нужно. Эту библиотеку
                можно использовать вне реакта.</p>

            <p>Сначала мы создаем Api файл где мы с помощью метода createApi создаем объект генерирующий хуки, при
                помощи которых мы можем делать либо прямой запрос по требованию, либо запрашивать данные сразу при
                монтировании компонента автоматически: </p>

            <p><a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/store/api/api.ts"
                  target="_blank">Гитхаб файл api.ts</a></p>

            <pre>
                import {createApi, fetchBaseQuery} from '@reduxjs/toolkit/query/react';

                const baseUrl = 'https://albion-profit-calculator.com/api';

                export interface IQueryTransportationParams{
                    ...
                }

                export interface IQueryItemsParams {
                    ...
                }

                export const albionApi = createApi({
                    reducerPath: 'albion/api',
                    baseQuery: fetchBaseQuery({
                        baseUrl,
                    }),
                    endpoints: build => ({
                        getTransportationsData: build.query&lt;TransportationData[], IQueryTransportationParams&gt;({
                            query: ({from, to, count, skip, profitSort, checkSort, serverId}) => ({
                                url: `transportations/sort?from=${from}&to=${to}&count=${count}&skip=${skip}&sort=${checkSort}${profitSort}&serverId=${serverId}`,
                            }),
                        }),
                        getItemsData: build.query&lt;IItemsData[], IQueryItemsParams&gt;({
                            query: ({itemsParams, isBlackMarket, serverId}) => ({
                                url: `data?items=${itemsParams}&locations=${!!isBlackMarket ? 'Black%20Market,' : ''}Thetford,Bridgewatch,Lymhurst,Caerleon,Martlock,Fort%20Sterling,Brecilien&serverId=${serverId}`,
                            })
                        }),
                    })
                })

                export const { useGetTransportationsDataQuery, useLazyGetItemsDataQuery, useGetItemsDataQuery} = albionApi;
            </pre>

            <p>Где useGetTransportationsDataQuery - это хук с мгновенным срабатыванием при монтировании компонента, а
                useLazyGetItemsDataQuery хук, который нужно вызывать в коде с помощью предоставленного им метода после
                его декларации.</p>
            <p>Далее к store надо подключить созданную api:</p>

            <p><a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/store/index.ts"
                  target="_blank">Гитхаб файл store.ts</a></p>

            <pre>
                import {combineReducers, configureStore} from "@reduxjs/toolkit";
                //...остальные импорты

                const rootReducer = combineReducers({
                    ...
                    [albionApi.reducerPath]: albionApi.reducer,
                })

                export const store = configureStore({
                    reducer: rootReducer,
                    middleware: (getDefaultMiddleware) => getDefaultMiddleware().concat(albionApi.middleware)
                })

                setupListeners(store.dispatch); // для refetchOnFocus(true/false) свойства в конфигурирующем объекте
            </pre>

            <p>Далее в нужных компонентах мы вызываем требуемый нам хук и передаем в него параметры:</p>

            <p>
                <a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/components/Transportation/TransportationTable/TransportationTable.tsx"
                   target="_blank">Гитхаб файл TransportationTable.tsx</a></p>
            <p>
                <a href="https://github.com/Slipbang/albion-calculator-app-v1/blob/master/src/components/Calculator/DefaultCalculator/InfoTable/InfoTable.tsx">Гитхаб
                    файл InfoTable.tsx</a></p>

            <pre>
                дефолтный хук:
                import {useGetTransportationsDataQuery} from "../../../store/api/api";
                //... остальные импорты

                const TransportationTable = () => {
                    ...

                    const queryParams = useSelector(selectTransportationQueryParams);

                    const {
                        isFetching,
                        isError,
                        data,
                    } = useGetTransportationsDataQuery({...queryParams}, {
                        refetchOnReconnect: true,
                    });

                    ...
                }

                ---------------------------------------------------------------------------
                ленивый хук:

                import {srcRoute, useLazyGetItemsDataQuery} from "../../../../store/api/api";
                //... остальные импорты

                const InfoTable = ({calculatorType}: {calculatorType: TCalcProps}) => {
                    ...

                    const [fetchItems, {
                        isFetching: isItemFetching,
                        isError: isErrorItems,
                        data: itemsData,
                    }] = useLazyGetItemsDataQuery();

                    ...

                    useEffect(() => {
                        if (calculatorType === 'ITEMS') {
                            fetchItems({itemsParams: queryItemsParams!, isBlackMarket: true, serverId});

                            ...
                        }

                        ...
                    }, [queryItemsParams, queryMatsParams!, queryJournalsParams, artefactId, serverId, itemId])
            </pre>

            <p>Из самих хуков можно деструктурировать isFetching, isLoading, isError, error, data и фетч функцию в
                случае Lazy хуков и хуков с мутациями</p>

            <p>В случае если нам требуется отправить данные на бэкэнд/удалить с бэкэнда и тут же их обновить в
                приложении, то нужно использовать build.mutation в endpoints:</p>

            <p><a href="">Гитхаб файл goodsApi.js</a></p>
            <pre>
                import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';

                export const goodsApi = createApi({
                    reducerPath: 'goodsApi',
                    tagTypes: ['Products'],
                    baseQuery: fetchBaseQuery({baseUrl: 'http://localhost:3001/'}),
                    endpoints: (build) => ({
                        getGoods: build.query({
                            query: (limit = '') => `goods?${limit && `_limit=${limit}`}`,
                            providesTags: (result) => result
                              ? [
                                  ...result.map(({ id }) => ({ type: 'Products', id })),
                                  { type: 'Products', id: 'LIST' },
                                ]
                              : [{ type: 'Products', id: 'LIST' }],
                        }),
                        addProduct: build.mutation({
                            query: (body) => ({
                                url: 'goods',
                                method: 'POST',
                                body,
                            }),
                            invalidatesTags: [{type: 'Products', id: 'LIST'}]
                        }),
                        deleteProduct: build.mutation({
                            query: (id) => ({
                                url: `goods/${id}`,
                                method: 'DELETE',
                            }),
                            invalidatesTags: [{type: 'Products', id: 'LIST'}]
                        })
                    })
                });

                export const {useGetGoodsQuery, useAddProductMutation, useDeleteProductMutation} = goodsApi;
            </pre>

            <p>Где в addProduct мы передаем body в качестве параметра и тела будущего запроса, и далее при использовании
                хука useAddProductMutation мы будем деструктурировать из него функцию в параметры которой собственно и
                будем передавать то, что мы хотим добавить.</p>
            <p>В случае же deleteProduct в параметр мы передаем расширитель эндпоинта и используем тип запроса
                DELETE</p>
            <p>tagTypes, providesTags и invalidatesTags используются для того, чтобы синхронизировать бэкенд и фронтэнд
                и производить автоматические запросы для обновления данных в случае если МЫ поменяли данные на бэкенде,
                данные сущности нужны в случае если мы работаем с build.mutation.</p>

            <p>Деструктурированные из useAddProductMutation и useDeleteProductMutation функции АСИНХРОННЫ и требуют
                использования синтаксиса async/await!:</p>

            <p><a href="https://github.com/michey85/rtk-query-example/blob/rtk/src/App.js">Гитхаб файл App.js</a></p>

            <pre>
                ...
                const {data = [], isLoading} = useGetGoodsQuery(count);
                const [addProduct, {isError}] = useAddProductMutation();
                const [deleteProduct] = useDeleteProductMutation();

                const handleAddProduct = async () => {
                  if(newProduct) {
                    await addProduct({name: newProduct}).unwrap();
                    setNewProduct('');
                  }
                }

                const handleDeleteProduct = async (id) => {
                  await deleteProduct(id).unwrap();
                }
                ...
            </pre>

            <p>unwrap() нужен для обработки ошибок.</p>
        </div>
    </section>

    <h3 id="typescript">TypeScript</h3>

    <section>
        <div>
            <p>TypeScript это расширение JavaScript, которое типизирует переменные.</p>
            <p>Тип в TS - простой способ обращения к различным свойствам и функциям, которые имеют значения.</p>
            <p>Описание типов всех методов и их аргументов находится в библиотеке с definition файлами d.ts, по-сути
                разработчики перенесли туда всю
                документацию по методам и исходя из типов переменных применяемых в этих методах в документации,
                TS производит оценку валидности наших переменных, которые мы пытаемся подставить в аргументы к
                данным методам.</p>

            <p>Система Типов TypeScript:</p>
            <ul>
                <li>Помогает нам обнаруживать ошибки во время разработки</li>
                <li>Использует "аннотации типов" для анализа кода</li>
                <li>Активна только во время разработки</li>
                <li>Не обеспечивает оптимизацию производительности</li>
            </ul>

            <p>TypeScript compiler устанавливается с помощью следующей команды:</p>
            <pre>
                npm install -g typescript ts-node
            </pre>
            <p>Чтобы перевести код из ts в js нужно использовать команду tsc fileName или просто tsc в корневой
                папке,
                чтобы сделать постоянную компиляцию из ts в js нужно использовать команду tsc -w в корневой
                папке</p>
            <p>Для того чтобы js код сохранялся в определенной папке в конфигурационном файле tsconfig.json нужно
                включить и настроить опции "rootDir" и "outDir"</p>

            <p>Типы делятся на:</p>
            <ul>
                <li>
                    Примитивные типы:
                    <ul>
                        <li>number</li>
                        <li>string</li>
                        <li>boolean</li>
                        <li>symbol</li>
                        <li>void</li>
                        <li>null</li>
                        <li>undefined</li>
                    </ul>
                </li>
                <li>
                    Объектные типы:
                    <ul>
                        <li>functions</li>
                        <li>classes</li>
                        <li>arrays</li>
                        <li>objects</li>
                    </ul>
                </li>
            </ul>
            <p>interface используется в TS для определения структуры объектов.</p>
        </div>
    </section>

    <h3 id="typeAnnotationsAndTypeInference">Аннотации и вывод типов</h3>

    <section>
        <div>
            <p>Type annotations(аннотации типов) - код, который мы добавляем для TS, чтобы он понял, значение какого
                типа будут содержаться в переменной.</p>
            <p>Примеры аннотации типов:</p>
            <pre>
                //dummy variables
                const someVariable1: number = 5;
                const someVariable2: string = "string";
                const someVariable3: boolean = true;
                const someVariable4: null = null;      // в случае с null можно присвоить переменной undefined
                const someVariable5: undefined = undefined;    // в случае же с undefined переменной можно присвоить null

                //build-in objects(встроенные объекты)
                const date: Date = new Date();

                //array
                const arrayOfColors: string[] = ["red", "yellow", "black"];
                const numbers: number[] = [1, 2, 3];

                // classes
                class Car {

                }
                const car: Car = new Car();

                 //annotation for object literal(аннотации для объектных литералов)
                interface ServerConfiguration {
                   protocol: 'http' | 'https',
                   port: 3000 | 3001
                }

                const serverConfig: ServerConfiguration = {
                   protocol: 'https',
                   port: 3001
                }

                const port3000: number = 3000;
                const port3001: number = 3001;

                function startServer(protocol: "http" | "https", port: 3000 | 3001): "Server started" {
                   if (port === port3000 || port === port3001) {
                      console.log(`Server started on ${protocol}://server:${port}`)
                   } else {
                      console.error('Invalid Port ')
                   }
                   return "Server started";
                }

                startServer(serverConfig.protocol, serverConfig.port);

                type someObjectType = {       // или interface someObjectType {...}
                   someObjectKey1: string;
                   someObjectKey2: number;
                   someObjectKey3: string[];
                   someObjectKey4: number[];
                }

                const someObject: someObjectType = {
                   someObjectKey1: 'someString',
                   someObjectKey2: 2,
                   someObjectKey3: ["string","string","string",],
                   someObjectKey4: [1, 2, 3,]
                };

                //functions
                const logNumber: (i: number) => void = (i) => {
                   console.log(i)
                }

                //примитивные литеральные типы(создание своих типов на основании конкретных значений примитивов)
                let msg: 'Hello';
                msg = 'Hello'; // и ничего больше сюда нельзя присвоить!

            </pre>
            <p>Type inference(вывод типов) - TS пытается сам определить, значение какого типа будут содержаться в
                переменной.</p>
            <p>Если декларация переменной и инициализация ее значения происходит в одной строке, то будет
                происходить
                автоматическое определение типа при помощи TS, НО если декларация и инициализация происходят на
                разных
                строках, то вывод типа не происходит!</p>
            <pre>
                let color = "red";    // let color: string
                let color;
                color = red;  // let color: any
            </pre>
            <p>Поэтому если переменная объявляется и инициализируется в одном выражении - аннотация типов
                НЕНУЖНА!</p>
            <p>Аннотация типов используется в следующих случаях:</p>
            <ul>
                <li>Когда переменная объявляется, но инициализируется позже</li>
                <li>Когда создается переменная, вывод о типе которой не может быть сделан</li>
                <li>Когда функция возвращает тип "any" и нам нужно уточнить тип</li>
            </ul>
            <p>Тип "any" категорически нужно избегать!!! Т.к. TS не имеет входных данных для проверки кода на
                валидность.</p>
            <p>В случае если переменная объявляется через const и без аннотации типа, то типом данной переменной
                будет
                присвоенное ей значение(литеральный тип)!</p>
            <pre>
                const isOkay = true; // const isOkay: true (НЕ boolean!!!!!!)
                let movement: string | boolean = false;

                if (isOkay){
                   movement = 'moving'
                }
            </pre>
        </div>
    </section>

    <h3 id="typeAlias">Type Alias (Псевдонимы типов)</h3>

    <section>
        <div>
            <p>В случае если аннотация типов получается слишком длинная или используется несколько раз в разных
                местах,
                то используют псевдоним типов</p>
            <pre>
                type AnimationTimingFunction = 'ease' | 'ease-out' | 'ease-in';
                type AnimationID = string | number;

                function createAnimation(
                   id: AnimationID,
                   animName: string,
                   timingFunction: AnimationTimingFunction = 'ease',
                   duration: number,
                   iterCount: 'infinite' | number
                ): void {
                   console.log(`${animName} ${timingFunction} ${duration} ${iterCount}`);
                }
            </pre>
        </div>
    </section>

    <h3 id="functionTypeAnnotations">Аннотации TS для функций и объектов</h3>

    <section>
        <div>
            <p>Type annotations(аннотации типов) для функций - Код, который мы добавляем для TS, чтобы он понял,
                аргумент какого типа будет принимать функция и значение какого типа она будет возвращать.</p>
            <p>Type inference(вывод типов) для функций - TS пытается сам определить, значение какого типа будет
                возвращать функция(аргументы не определяются).</p>

            <pre>
                const add = (a: number, b: number): number => {
                   return a + b;
                }

                //

                const subtract: (a: number, b: number) => number = (a, b) => {
                   return a - b;
                }

                //

                function divide (a: number, b: number): number {
                   return a / b;
                }

                //

                const multiply = function (a: number, b: number): number {
                   return a * b;
                }
            </pre>
            <p>Аннотации типов функций пишутся как для аргументов, так и для возвращаемого значения ВСЕГДА!!!</p>
            <p>В случае если функция ничего не возвращает, используют следующий синтаксис:</p>
            <pre>
                const logger = (message: string): void => {
                   console.log(message)
                }
            </pre>
            <p>Если мы полностью уверены, что мы никогда не будем достигать конца функции, то используем следующий
                синтаксис:</p>
            <pre>
                const throwError = (message: string): never => {
                   throw new Error(message);
                }

                //возврат never в качестве исчерпывающей проверки

                const createError = (msg: string): never => {
                    throw new Error(msg);
                }

                const userData: userDataTypes = JSON.parse(userDataJSON);

                const logBirthday = (userData: userDataTypes): string => {
                    if (userData.isBirthday){
                        return `Congrats to ${userData.userNameData}, he is ${userData.ageData} age today`
                    } else if (!userData.isBirthday) {
                       return 'It is bad'
                    }
                    return createError('Error'); // исчерпывающая проверка
                }

                console.log(logBirthday(userData));
            </pre>
            <p>В случае если в качестве аргумента в функции используется объект используют следующий синтаксис:</p>
            <pre>
                const forecast = {
                   date: new Date(),
                   weather: 'rainy',
                }

                const logWeather = (forecast: {date: Date; weather: string}): void => {
                   console.log(forecast.date);
                   console.log(forecast.weather)
                }
                logWeather(forecast);
            </pre>
            <p>Если же пользоваться синтаксисом ES2015 с деструктуризацией аргументов из объекта, то синтаксис TS
                будет
                выглядеть следующим образом:</p>
            <pre>
                const forecast = {
                   date: new Date(),
                   weather: 'rainy',
                }
                const logWeather1 = ({date, weather}: {date: Date; weather: string}) => {
                   console.log(date)
                   console.log(weather);
                }
                logWeather1(forecast);
            </pre>
            <p>В случае если мы деструктуризируем объект и нам нужно применить TS, то используется следующий
                синтаксис:</p>
            <pre>
                const profile = {
                   name: 'Sally',
                   age: 25,
                   coordinates: {
                       lat: 1,
                       lng: 20
                   },
                   setAge(age: number): void{
                      this.age = age;
                   }
                }

                const {age}: {age: number} = profile;

                const {coordinates: {lat, lng}}: {coordinates: {lat: number; lng: number}} = profile;
            </pre>
            <p>В случае если у нас в функции объединенный тип из двух объектов и нужно получить доступ к одному из
                них
                то используют синтаксис с in</p>
            <pre>
                function checkReadings (readings: {system: number} | {user: number}){
                   if ('system' in readings){
                      console.log(readings.system);
                   } else {
                      console.log(readings.user);
                   }
                }
            </pre>
        </div>
    </section>

    <h3 id="nullAndUndefinedTypes">Типы null и undefined</h3>

    <section>
        <div>
            <p>null является подтипом всех типов и может быть присвоен любой переменной с любой типизацией за
                исключением типа undefined, НО данная возможность дефолтно отключена в tsconfig и настраивается в
                "strictNullChecks"! Такая же ситуация с undefined, и в этой ситуации все так же работает
                "strictNullChecks"</p>
        </div>
    </section>

    <h3 id="symbolAndBigIntTypes">Типы symbol и BigInt</h3>

    <section>
        <div>
            <p>Синтаксис типизации символов:</p>
            <pre>
                let id: symbol = Symbol('id');

                const data = {
                   [id]: 1
                }

                console.log(data[id]);
            </pre>
            <p>BigInt позволяет безопасно работать с числами которые выходят за диапазоны стандартного типа данных
                number(+ или - 2^53-1)</p>
            <pre>
                const number1: bigint = 1n;
                const number2: bigint = 2n;

                console.log(number1 + number2);
                console.log(number1 + 1n);
            </pre>

            <p>Number и BigInt нельзя смешивать в операциях — они должны быть приведены к тому же типу.</p>
        </div>
    </section>

    <h3 id="typeAny">Тип any</h3>

    <section>
        <div>
            <p>Тип который означает кто у данной переменной может быть любой тип, является недопустимым при
                использовании TS!!!</p>
            <p>Примеры когда возвращается тип any:</p>
            <pre>
                //объявление переменной без присвоения ей значения
                let salary: number; // в данном случае type inference не сработает и без аннотации будет присвоен тип any
                salary = 5000;


                //возврат any в JSON.parse()

                const userDataJSON = '{"isBirthdayData": true, "ageData": 40, "userNameData": "John"}';

                interface userDataTypes {
                    isBirthday: boolean;
                    ageData: number;
                    userNameData: string
                }

                const userData: userDataTypes = JSON.parse(userDataJSON); // дабы не возвратилось any делаем аннотацию перепенной через интерфейс

                const logBirthday = (userData: userDataTypes) => {
                    return `Congrats to ${userData.userNameData}, he is ${userData.ageData} age today`;
                }

                console.log(logBirthday(userData));  // Congrats to John, he is 40 age today
            </pre>
        </div>
    </section>

    <h3 id="typeUnknown">Тип unknown</h3>

    <section>
        <div>
            <p>В случае если мы не знаем какой будет тип у данной переменной нужно присвоить ей тип unknown, данный
                тип
                ограничит любые потенциально опасные операции с данной переменной.</p>
            <pre>
                let someVariable: unknown;
                someVariable = 'str';
                //someVariable = ['1', '2', '3'];

                let someData: string[] = someVariable; //Type 'unknown' is not assignable to type 'string[]'

                //соответственно чтобы выполнить какую-то операцию нужно выполнить проверку типа:

                if (Array.isArray(someVariable) && someVariable.every(item => typeof item === 'string')){
                   let someData: string[] = someVariable;
                   someData.find(e => console.log(e));
                }

                //----------------------------------------------------------------------------------------//

                const userDataUnknown = '{"isBirthdayData": true, "ageData": 40, "userNameData": "John"}';

                function safeParse(str: string): unknown {
                   return JSON.parse(str)
                }

                const unknownData = safeParse(userDataUnknown);

                function transferData(data: unknown): void {
                    if (typeof data === 'string'){
                        console.log(data.toUpperCase());
                    } else if (typeof data === 'object' && data){
                        console.log(data); //{ isBirthdayData: true, ageData: 40, userNameData: 'John' }
                    } else {
                        console.error('Some Error')
                    }
                }

                transferData(unknownData);

                type T0 = number | unknown; // unknown всегда будет перекрывать number и любой другой тип
                type T1 = any | unknown; // за исключением типа any
                type T2 = number & unknown; // в данном случае ситуация обратная, number и другие типы будут перекрывать unknown
                type T3 = any & unknown; // и any тоже перекроет unknown
            </pre>
        </div>
    </section>

    <h3 id="returnVoid">Возвращаемый функцией тип void</h3>

    <section>
        <div>
            <p>Для того, чтобы обозначить что функция ничего не возвращает используют в аннотации тип void, аннотация
                можеть быть написана на прямую к блоку аргументов так и к имени функции, первый метод аннотации
                будет
                означать что функция вообще ничего не вернет, а второй метод будет игнорировать любое возвращаемое
                значение</p>
            <pre>
                type voidFunc = () => void;

                const returnString: voidFunc = () => {
                   return 'string';
                }

                console.log(returnString());

                const returnNumber: voidFunc = () => {
                   return 5;
                }

                console.log(returnNumber());

                const someFunc = (): void => {
                   //return true; //error: Type 'boolean' is not assignable to type 'void'
                }

                const names = ['Anna', 'John'];

                names.forEach((name, index, array) => array.push('Hello')) //Array< string >.forEach(callbackfn: (value: string, index: number, array: string[]) => void, thisArg?: any): void
                //комментарий к методу forEach говорит о том что callback функция проигнорирует возвращаемые значения других методов)
            </pre>
        </div>
    </section>

    <h3 id="requestsType">Запросы типа</h3>

    <section>
        <div>
            <p>В случае если интерфейс или тип не требуется по причине одинарного использования переменной, то можно
                на
                прямую запросить ее тип в аннотации следующим синтаксисом:</p>
            <pre>
                const dataFormControl = {
                   water: 200,
                   el: 350
                }

                function checkReadings(data: typeof dataFormControl): boolean{
                   const dataFromUser = {
                      water: 200,
                      el: 350
                   }

                   return data.water === dataFromUser.water && data.el === dataFromUser.el;
                }
            </pre>
            <p>Так же с помощью аннотации через typeof конструкции можно скопировать значение в другую переменную
                создав
                литерал:</p>
            <pre>
                const PI = 3.14;
                let PIClone: typeof PI; // let PIClone: 3.14
            </pre>
        </div>
    </section>

    <h3 id="optionalOperatorReadonly">Опциональный (Optional operator) и notNull/notUndefined операторы и модификатор
        readonly</h3>

    <section>
        <div>
            <p>В случае если нам требуется сделать одно или несколько свойств объекта опциональным, и мы точно знаем
                что
                свойство объекта будет существовать, то нам требуется использовать следующий синтаксис:</p>
            <pre>
                interface User {
                   readonly login: string;
                   password: string;
                   age: number;
                   readonly address?: string; // для опциональных свойств так же применяется
                   parents?: {
                      mother?: string;
                      father?: string;
                   }
                }

                const user: User = {
                   login: 'login',
                   password: 'password',
                   age: 30,
                   //address: 'address',  // ошибки не будет
                }

                const userFreeze: Readonly< User > = {
                   login: 'login',
                   password: 'password',
                   age: 30,
                }

                // user.login = 'another login'; //Cannot assign to 'login' because it is a read-only property.
                user.password = 'another password'; // ok

                let dbName: string;
                sendUserData(user, 'someDB');

                //console.log(dbName); // TS выдаст ошибку что переменная используется до декларации
                console.log(dbName!);  //notNull оператор же даст гарантию того что переменная будет существовать

                function sendUserData(obj: User, db?: string): void {
                   dbName = 'someDBName';
                   console.log(obj.parents!.mother?.toUpperCase(), db?.toLowerCase()) // где "!" указывает на то что объект parents точно будет существовать,
                                                                                      // а "?" проверяет на наличие вложенных в parents свойств
                }

                //const basicPorts: readonly number[] = [3000, 3001, 5555];
                const basicPorts: ReadonlyArray< number > = [3000, 3001, 5555]; // тоже самое что и readonly number[]
                //basicPorts[0] = 1000; //  Index signature in type 'readonly number[]' only permits reading
            </pre>
        </div>
    </section>

    <h3 id="arraysInTS">Массивы в TS</h3>

    <section>
        <div>
            <p>Typed arrays(Типизированные массивы) - Массивы, в которых каждый элемент - это значение определенного
                типа.</p>
            <p>Примеры:</p>
            <pre>
                const colors = ['green', 'red', 'yellow'];
                const numbers: number[] = [];
                const dates = [new Date(), new Date(), new Date(),];
                const fruitsByColor = [   // string[][]
                   ['apple','pear',],
                   ['tomato', 'dragonFruit',],
                   ['banana', 'pineapple',]
                ]

                const fruitsByColor1: string[][] = []
            </pre>
            <p>В случае если мы инициализируем пустой массив, обязательно нужно писать аннотацию, в обратном случае
                можно воспользоваться автоматическим выводом типов</p>
            <pre>
                const colors = ['blue', 'red', 'white']; // const colors: string[]
                const numbers: number[] = [];
            </pre>
            <p>Зачем TS для массивов?</p>
            <pre>
                //Помощь вывода типов при извлечении значения из массива
                const color = colors[0] // const color: string

                //TS может предотвратить добавление несовместимых типов в массив
                colors.push(true) //error

                //Мы можем получить помощь используя метод массивов "map", "forEach", "reduce"
                colors.map((color: string): string => color.toUpperCase())

                //Гибкость - массивы могут содержать значения разных типов
                const importantDates = [new Date(), '11.11.1991', new Date(), '05.05.1995']; //const importantDates: (string | Date)[]
                const importantDates1: (string | Date)[] = [new Date()];
                importantDates1.push('11.11.1993') // ошибки нет
            </pre>
            <p>Когда использовать типизированные массивы? - Каждый раз когда нам нужно представить коллекцию записей
                в
                случайном порядке.</p>
        </div>
    </section>

    <h3 id="tuples">Tuples(Кортежи) в TS</h3>

    <section>
        <div>
            <p>Tuples(кортежи) - Структуры похожие на массивы, в которых каждый элемент - это какое-то свойство
                записи.</p>
            <p>Пример:</p>
            <pre>
                //объект отображающий напиток
                const drink = {
                   color: 'brown',
                   carbonated: true,
                   sugar: 40,
                }

                //Кортеж отображающий напиток, данный синтаксис жестко фиксирует
                //тип значения с соответствующим индексом
                const cola: [string, boolean, number] = ['brown', true, 40];

                //также в кортежах можно использовать синтаксис типового alias
                type Drink = [string, boolean, number];
                const cola: Drink = ['brown', true, 40];
                const sprite: Drink = ['clear', true, 40];

                //в случае если количество элементов в кортеже не известно,
                //то можно использовать спред оператор
                const userDataTuple: [boolean, number, ...string[]] = [true, 40, "John", "Alex", "Ann"];
            </pre>
        </div>
    </section>

    <h3 id="interfaces">Интерфейсы</h3>

    <section>
        <div>
            <p>Interface - создает новый тип, описывая название свойств и типы значений объекта.</p>
            <p>Интерфейсы имеют следующий синтаксис:</p>
            <pre>
                interface Reportable  {
                   //name: string;
                   //year: number;
                   //broken: boolean;
                   summary?(): string;
                }

                const oldCivic = {
                   name: 'Civic',
                   year: 2000,
                   broken: true,
                   summary() {
                      return `
                      Name: ${this.name}
                      Year: ${this.year}
                      Broken?: ${this.broken}
                      `
                   }
                }

                const cola = {
                    color: 'brown',
                    carbonated: true,
                    sugar: 40,
                    summary(): string {
                        return `
                        color: ${this.color}
                        carbonated?: ${this.carbonated}
                        sugar: ${this.sugar}
                        `
                    }
                }

                const printSummary = (item: Reportable): void => {
                   if (item.summary){
                      console.log(item.summary());
                   }
                }

                printSummary(oldCivic);
                printSummary(cola);
            </pre>
            <p>В случае если мы не знаем какое количество аргументов будет, то используем следующий синтаксис:</p>
            <pre>
                interface IStyles {
                   [key: string]: string
                }

                const styles: IStyles = {
                   position: 'absolute',
                   top: '20px',
                   left: '50px'
                }
            </pre>
            <p>Основная стратегия повторно используемого кода в TS:</p>
            <ul>
                <li>Создание функций, которые принимают параметры, типизированные при помощи интерфейсов</li>
                <li>Объекты/Классы могут "имплементировать" нужный интерфейс для работы с функцией</li>
            </ul>
        </div>
    </section>

    <h3 id="interfaceVSTypes">Interface VS Types</h3>

    <section>
        <div>
            <p>Если нужен примитивный тип в качестве псевдонима типа, то используется только type, если берется
                готовый
                тип объекта и его нужно расширить то нужно использовать только interface, если работаем только с
                объектом то разницы в выборе нет, но чаще всего используют интерфейсы, type же используют когда
                нужен
                примитивный или объединенный тип</p>
        </div>
    </section>

    <h3 id="classesInTS">Классы в TS</h3>

    <section>
        <div>
            <p>Class - шаблон для создания объектов - с полями(значения) и методами(функции) для отображения
                "чего-то" в
                приложении.</p>
            <p>Пример:</p>
            <pre>
                class Vehicle {

                   //color: string; // поле класса

                   //constructor(color: string) {
                   //   this.color = color;
                   //}

                   constructor(public color: string) { // сокращенный способ с помощью конструктора конфигурировать поля
                   }

                   public drive(): void {
                      console.log("i'm driving");
                   }

                   public stop(): void {
                      console.log("i've stopped");
                   }

                   protected beep(): void {
                      console.log("Beeeep!");
                   }
                }

                class Car extends Vehicle {

                   constructor(public wheels: number, color: string) {
                      super(color);
                   }

                   private drive1(): void {
                      console.log("i'm a car and i'm driving");
                   }
                   startDrivingProcess(): void{
                      this.drive1(); // из-за модификатора private мы можем вызвать drive1 только внутри класса
                      this.beep(); //мы можем здесь вызвать метод "beep()" тк его модификатор protected
                   }
                }

                const vehicle = new Vehicle("black");
                vehicle.drive(); //i'm driving
                vehicle.stop(); //i've stopped
                console.log(vehicle.color); //black

                const car = new Car(4, 'red');
                //car.drive1(); //error cus private
                //car.beep(); //error cus protected
                car.startDrivingProcess(); //i'm driving
                car.stop(); //i'm a car and i'm driving
                console.log(car.color); //black
            </pre>
            <p>Где класс Vehicle является родительским(или супер) классом, а Car - дочерним</p>
            <p>Модификаторы - ключевые слова которые мы можем размещать для методов и свойств классов, цель
                модификаторов ограничивать для методов и свойств доступ.</p>
            <p>Существует три модификатора:</p>
            <ul>
                <li>public - этот метод может быть вызван откуда угодно, в любое время. Является дефолтным.</li>
                <li>private - Этот метод может быть вызван только другими методами внутри того же класса.</li>
                <li>protected - этот метод может быть вызван другими методами внутри того же класса или другими
                    методами
                    внутри класса наследника.
                </li>
            </ul>
            <p>Поля - свойства с какими-то значениями, поля так же имеют все те же самые модификаторы.</p>
            <p>interface + Class = повторное использование кода в TS. Внутри TS приложений классы используются
                практически всегда.</p>
        </div>
    </section>

    <h3 id="typeGuard">Type Guard (защита типов)</h3>

    <section>
        <div>
            <p>В случае когда у нас в аннотации присутвует объединенный тип двух интерфейсов, и свойства в них
                разные, а
                нам надо работать со всеми свойствами этих двух объектов, то требуется использовать защиту
                типов:</p>
            <pre>
                interface Car {
                   engine: string;
                   wheels: {
                      wheelsQuantity: number;
                      wheelsType: string;
                   }
                }

                interface Ship {
                   engine: string;
                   sail: string;
                }

                interface Airplane {
                   name: 'airplane';
                   engine: string;
                   wings: string;
                }

                interface Rocket {
                   name: 'rocket';
                   engine: string;
                   enginesQuantity: number;
                }

                type Vehicles = Car | Ship | Airplane | Rocket;

                function repairVehicle(vehicle: Car | Ship){
                   console.log(vehicle.engine) //доступно только свойство engine
                   if (isCar(vehicle)){
                      console.log(vehicle.wheels); // engine & wheels
                   } else if (isShip(vehicle)) {
                      console.log(vehicle.sail); // engine & sail
                   } else {
                      console.log(vehicle); //тк код сюда не дойдет то тип "never"
                   }
                }

                function isCar(car: Car | Ship): car is Car{ // именно "car is Car" является защитником типа
                    return 'wheels' in car;                  // если здесь будет просто boolean - данная конструкция не сработает
                }
            </pre>
            <p>Так же существует более продвинутая версия проверки на принадлежность к интерфейсу:</p>
            <pre>
                function isCar(car: Car | Ship): car is Car{
                   //return 'wheels' in car;
                   return (car as Car).wheels !== undefined; // фактически это тоже самое
                }
            </pre>
            <p>Вместо if else конструкции лучше использовать конструкцию switch case:</p>
            <pre>
                function repairVehicle(vehicle: Vehicles){
                   switch (vehicle.name){
                      case "car":
                         console.log(vehicle.wheels);
                         break;
                      case "ship":
                          console.log(vehicle.sail);
                          break;
                      case "airplane":
                          console.log(vehicle.wings);
                          break;
                      case "rocket":
                          console.log(vehicle.enginesQuantity);
                          break;
                      default:
                          console.log('Транспортного средства не найдено');
                          const someVar: never = vehicle; // vehicle: never
                   }
                }
            </pre>
            <p>В случае если мы забудем обработать какой-то новый интерфейс, то vehicle будет уже не never, что и
                будет
                сигналом ошибки</p>
        </div>
    </section>

    <h3 id="functionOverloads">Перегрузка функций (function overloads)</h3>

    <section>
        <div>
            <p>Для того чтобы было удобнее работать с функциями используют т.н. перегрузку функции, это своеобразная
                документация декларируемая до основной функции, где описываются сценарии количества аргументов и что
                будет
                возвращаться функцией:</p>

            <pre>
                interface Square {
                   side: number;
                   area: number;
                }

                interface Rectangle {
                   sideA: number;
                   sideB: number;
                   area: number;
                }

                function calculateArea(side: number): Square; // перегрузка функции
                function calculateArea(sideA: number, sideB: number): Rectangle;  // перегрузка функции

                function calculateArea(a: number, b?: number): Square | Rectangle {
                   if (b){
                       return {
                           sideA: a,
                           sideB: b,
                           area: a*b
                       } as Rectangle;
                   }else {
                       return {
                           side: a,
                           area: a*a,
                       } as Square;
                   }
                }

                calculateArea(5); //function calculateArea(side: number): Square
                calculateArea(5,10); //function calculateArea(sideA: number, sideB: number): Rectangle
            </pre>
            <p>Правила работы с перегрузкой функции:</p>
            <ul>
                <li>Перегрузка функции всегда записывается ДО основного тела функции</li>
                <li>Аргументы могут называться другими именами</li>
                <li>Все перегрузки должны быть совместимы с главной функцией</li>
            </ul>
        </div>
    </section>

    <h3 id="designPatternsInTS">Использование шаблонов проектирования(Design Patterns) в TS</h3>

    <section>
        <div>
            <p>Для того чтобы запускать TS сразу в браузере нужно установить parcel-bundler в командной строке:</p>
            <pre>
                npm install -g parcel-bundler
            </pre>
            <p>При запуске в командной строке нужно указать "parcel someFileName"</p>
            <p>При декларировании типов свойств объектов и инициализации этого объекта в классах, в конструкторе не
                нужно обращаться к свойству объекта на прямую, тк сам объект еще не инициализирован!:</p>
            <pre>
                export class Company {
                   companyName: string;
                   catchPhrase: string;
                   location: {             //здесь мы только декларируем типы, но не инициализируем
                      lat: number;
                      lng: number;
                   };

                   constructor() {
                      this.companyName = faker.company.companyName();
                      this.catchPhrase = faker.company.catchPhrase();
                      this.location = {  // а здесь мы уже производим инициализацию объекта, поэтому не надо обращаться к свойствам объекта, а нужно присваивать их!
                         lat: +faker.address.latitude(), // а не this.location.lat = +faker.address.latitude(); ЭТО ОШИБКА!!!
                         lng: +faker.address.longitude() // а не this.location.lng = +faker.address.longitude(); ЭТО ОШИБКА!!!
                      }
                   }
                }
            </pre>
            <p>Когда мы через оператор или | присваиваем переменной два типа, и допустим это два объекта, то во
                внимание
                будут приниматься только те свойства этих двух объектов, которые присутствуют в них обоих.</p>
            <pre>
                async addMarker(obj: Company | User): Promise< void > {
                   const { AdvancedMarkerElement } = await google.maps.importLibrary("marker") as google.maps.MarkerLibrary;
                   const marker = new AdvancedMarkerElement({
                      map: this.googleMap,
                      position: {
                         lat: obj.location.lat, // при этом нельзя обратиться к свойству obj.name или obj.companyName, исключительно только к свойству obj.location!!!
                         lng: obj.location.lng
                      },
                   });
                }
            </pre>
            <p>В случае если мы используем интерфейс и нам нужно точно получить место ошибки, то этот интерфейс
                нужно
                импортировать в используемый класс и имплементировать этот класс в интерфейс:</p>
            <pre>
                import * as faker from "faker";
                import {ObjInterface} from "./CustomMap";

                export class User implements ObjInterface{
                   name: string;
                   location: {
                      lat: number;
                      lng: number;
                   };
                   constructor() {
                      this.name = faker.name.firstName();
                      this.location = {
                         lat: +faker.address.latitude(),
                         lng: +faker.address.longitude()
                      }
                   };

                   markerContent(): string{
                      return `User Name: ${this.name}`
                   }
                }
            </pre>
            <p>В случае если при использовании объединенных типов нужно использовать весь набор свойств и методов
                определенного значения, то нужно применить охрану типов, т.е условную конструкцию с instanceof:</p>
            <pre>
                class Sorter {
                   constructor(public collection: number[] | string) {}
                   counter: number = 0;
                   sorting(): void{
                      let {length} = this.collection
                      for (let i = 0; i < length; i++){
                         for (let j = 0; j < length - i - 1; j++) {
                            if (this.collection instanceof Array){  //или Array.isArray(this.collection[j]) - type guard
                               if (this.collection[j] > this.collection[j + 1]){
                                  this.counter += 1;
                                  let acc = this.collection[j];
                                  this.collection[j] = this.collection[j+1];
                                  this.collection[j+1] = acc;
                               }
                            }
                            if (typeof this.collection === 'string'){ // type guard

                            }
                         }
                      }
                   }
                }
            </pre>
            <p>Если значения примитивного типа(string, number, symbol, boolean) то используется синтаксис typeof,
                если
                же любое другое значение созданное с помощью функции конструктора, то instanceof!!!</p>
        </div>
    </section>

    <h3 id="abstractClasses">Абстрактные классы</h3>

    <section>
        <div>
            <p>Абстрактные классы:</p>
            <ul>
                <li>Не может использоваться для создания объекта на прямую</li>
                <li>Используется только как родительский класс</li>
                <li>Может содержать реализацию некоторых методов</li>
                <li>Реализованные методы могут ссылаться на другие методы, которых на самом деле еще не
                    существует(но
                    нужно указать имена и типы для нереализованных методов)
                </li>
                <li>Может заставить дочерние классы пообещать реализовать какой-то другой метод</li>
            </ul>

            <pre>
                export abstract class Sorter {

                   abstract compare(leftHand: number, rightHand:number): boolean;
                   abstract swap(leftHand: number, rightHand:number): void;
                   abstract get length(): number;

                   sorting(): void {
                      let {length} = this
                      for (let i = 0; i < length; i++) {
                         for (let j = 0; j < length - i - 1; j++) {
                            if (this.compare(j, j+1)){
                               this.swap(j, j+1)
                            }
                         }
                      }
                   }
                }

                interface IEngine {
                    model: string;
                    capacity: number;
                    startEngine: (time: Date) => string;
                    stopEngine: (time: Date) => string;
                }

                abstract class AbstractVehicle{
                    model!: string;
                    capacity!: number;

                    constructor(model: string, capacity: number) {
                        this.model = model;
                        this.capacity = capacity;
                    }

                    abstract startEngine: (time: Date) => string;
                    stopEngine(time: Date): string {
                        return `Engine Stopped at ${time.toLocaleString()}`
                    }
                }

                class SomeVehicle extends AbstractVehicle{
                    startEngine = (time: Date): string => {
                        return `Engine Started at ${time.toLocaleString()}`;
                    }
                }

                const newVehicle = new SomeVehicle('1', 111);
                newVehicle.startEngine(new Date());
                newVehicle.stopEngine(new Date());
            </pre>
            <p>методы и свойства с модификатором abstract удаляются в js файле!(вопрос на собеседовании, что с ними
                происходит)</p>

            <p>Интерфейсы VS Абстрактные классы</p>

            <p>Интерфейсы:</p>
            <ul>
                <li>Устанавливают контракт между разными классами</li>
                <li>Используются, когда у нас есть очень разные объекты, с которыми мы хотим работать вместе</li>
                <li>Способствует слабому сцеплению</li>
            </ul>

            <p>Абстрактные классы / наследование:</p>
            <ul>
                <li>Устанавливают контракт между разными классами</li>
                <li>Используются, когда мы пытаемся создать определение класса</li>
                <li>Способствует сильному сцеплению</li>
            </ul>
        </div>
    </section>

    <h3 id="enumerations">Enumerations(enum)</h3>

    <section>
        <div>
            <p>Тип enum или по-другому перечисление - это особый тип данных, который позволяет задавать некий список
                взаимосвязанных констант. Переменные этого типа могут принимать значения только из заданного в
                перечислении набора. Это свойство перечислений делает их удобным инструментом для реализации списка
                связанных значений.</p>
            <pre>
                enum MatchResult {
                   HomeWin = 'H',
                   AwayWin = 'A',
                   Draw = 'D'
                }

                enum Directions {
                   RIGHT,
                   LEFT,
                   TOP,
                   BOTTOM
                }

                enum TFunction {
                   EASE = 'ease',
                   LINEAR = 'linear',
                   EASE_IN = 'ease-in',
                   EASE_OUT = 'ease-out',
                   EASE_IN_OUT = 'ease-in-out',
                   CUBIC_BEZIER = 'cubic-bezier'
                }

                function frame(elem: string, dir: Directions, tFunction: TFunction): void {
                   if (dir === Directions.RIGHT) {
                      console.log(tFunction);
                   }
                }

                frame('id', Directions.RIGHT, TFunction.EASE);
            </pre>
            <p>Когда мы создаем enum, мы так же создаем новый тип, в случае из примера это будет MatchResult.</p>
            <p>Enums перечисления:</p>
            <ul>
                <li>Соблюдает почти идентичные правила синтаксиса как обычный объект</li>
                <li>Создает объект с такими же ключами и значениями при преобразовании из TS в JS</li>
                <li>Основная цель - дать понять другим разработчикам, что все эти значения тесно связаны</li>
                <li>Используются всякий раз, когда у нас есть небольшой фиксированный набор значений(15ед макс),
                    которые
                    тесно
                    связаны и известны во время компиляции
                </li>
            </ul>
        </div>
    </section>

    <h3 id="typeAssertions">Type assertions(утверждение типа)</h3>

    <section>
        <div>
            <p>Для того чтобы переприсвоить какой-то переменной определенный тип можно использовать следующий
                синтаксис:</p>
            <pre>
                get getData(): string[][] {
                   return fs.readFileSync(this.fileName, {
                      encoding: 'utf-8'
                }).split('\n').map((match: string): string[] => match.split(',')).map((stringArray: string[]): any => {
                   return [
                         dateStringToDate(stringArray[0]),
                         stringArray[1],
                         stringArray[2],
                         parseInt(stringArray[3]),
                         parseInt(stringArray[4]),
                         stringArray[5] as MatchResult, // Type assertions
                         stringArray[6]
                      ]
                   })
                }
            </pre>

            <p>Существует три способа применения оператора "as":</p>
            <pre>
                //1 способ
                const requestOptions = {
                   url: 'https://someurl.com',
                   method: 'GET' as 'GET',
                }

                fetchData(requestOptions.url, requestOptions.method);

                //2 способ
                const requestOptions = {
                   url: 'https://someurl.com',
                   method: 'GET',
                }

                fetchData(requestOptions.url, requestOptions.method  as 'GET');

                //3 способ
                const requestOptions = {
                   url: 'https://someurl.com',
                   method: 'GET',
                } as const;

                fetchData(requestOptions.url, requestOptions.method);
            </pre>

            <p>Так же есть альтернативный синтаксис утверждения типа:</p>
            <p>Данный синтаксис нельзя использовать в React!!!</p>
            <pre>
                const requestOptions = {
                   url: 'https://someurl.com',
                   method: 'GET',
                };

                fetchData(requestOptions.url, <"GET">requestOptions.method);
            </pre>

            <p>Работа с HTML элементами:</p>
            <pre>
                //html
                &lt;input id="inputId" type="text" value="55"/&gt;
                &lt;div class="box"&gt;Hello&lt;/div&gt;


                //js/ts
                const box = document.querySelector('.box') as HTMLElement;
                const input = document.querySelector('#inputId') as HTMLInputElement;
                const someNumber: number = +input.value;
                //const someNumber: number = input.value as any as number; //нежелательно!!!

                console.log(someNumber); //55
            </pre>
            <p>Синтаксис "as const"</p>
            <pre>
                let a = 'value' as const; //let a: "value"
                let b = {f: 100} as const; //let b: {readonly f: 10}
                let c = ['a', 'b', 'c'] as const; //let c: readonly ["a", "b", "c"]

                let value = 'value';
                //let someVar = value as const; //A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals.
            </pre>

            <p>Утверждение к константе применимо только к простым выражениям!</p>
            <pre>
                let a = (Math.round(Math.random() * 1)
                  ? 'yes'
                  : 'no') as const; // Ошибка
                let b = Math.round(Math.random() * 1)
                  ? ('yes' as const)
                  : ('no' as const); // Ok, let b: "yes" | "no"
            </pre>
        </div>
    </section>

    <h3 id="typesOfConstructorCreatedVariables">Типы переменных значения которых созданы при помощи конструкторов
        класса</h3>

    <section>
        <div>
            <p>Когда присваиваем переменным значения созданные при помощи конструктора энного класса, то тип данной
                переменной будет соответствовать примитивному типу НО начинаться с большой буквы! И при сравнении
                двух
                переменных с примитивными значениями, но разным способом создания двойное сравнение даст true а
                тройное
                false!</p>
            <p>Так же благодаря неявному приведению типов переменной созданной с помощью конструктора можно
                присвоить
                обычную переменную с соответвующим обычным типом, обратно же выполнить данную операцию нельзя!</p>
            <pre>
                let num: Number = new Number(5);
                let num2: number = 5;
                let num3: number = Number(5); // данная функция так же создает примитивный тип number

                num = num2; //ok
                num2 = num //Type 'Number' is not assignable to type 'number'. 'number' is a primitive, but 'Number' is a wrapper object. Prefer using 'number' when possible.
            </pre>
            <p>Как видно из описания ошибки разработчики рекомендуют по возможности использовать не объектный способ
                декларации примитивной переменной.</p>

        </div>
    </section>

    <h3 id="objectCreation">Создание объектов на базе другого или других</h3>

    <section>
        <div>
            <p>В случае если требуется создать отдельный объект на базе другого, то можно использовать функцию
                конвертор
                с соответвующим возвращаемым интерфейсом требуемого объекта:</p>
            <pre>
                interface Department {
                   name: string;
                   budget: number;
                }

                const department: Department = {
                   name: 'web-dev',
                   budget: 50000
                }

                interface Project {
                   name: string;
                   projectBudget: number
                }

                function transformDepartment(department: Department, amount: number): Project {
                   return {
                      name: department.name,
                      projectBudget: amount
                   }
                }

                const mainProject: Project = transformDepartment(department, 5000);
            </pre>
            <p>Не стоит стремиться описать одним интерфейсом несколько сущностей, лучше создать несколько маленьких
                интерфейсов!</p>
            <pre>
                interface ComplexVehicle {
                    name: 'car' | 'ship' | 'airplane' | 'rocket';
                    engine: string;
                    wheels?: {
                        wheelsQuantity: number;
                        wheelsType: string;
                    };
                    sail?: string;
                    wings?: string;
                    enginesQuantity?: number;
                }

                const car: ComplexVehicle = {
                   name: "car",
                   engine: "v8",
                }

                function repairVehicle1(vehicle: ComplexVehicle){
                    switch (vehicle.name){
                        case "car":
                            console.log(vehicle.wheels.wheelsQuantity * 2); //NaN, в данном случае больше подойдет узкоспециализированный интерфейс
                            break;
                        case "ship":
                            console.log(vehicle.sail);
                           break;
                        case "airplane":
                            console.log(vehicle.wings);
                            break;
                        case "rocket":
                            console.log(vehicle.enginesQuantity);
                            break;
                        default:
                   }
                }
            </pre>
        </div>
    </section>

    <h3 id="TSGenerics">Дженерики/Обобщения (generics) в TS</h3>

    <section>
        <div>
            <p>Generics:</p>
            <ul>
                <li>Как аргументы функции, но для типов - в определениях классов/функций</li>
                <li>Позволяет нам определить тип свойства/аргумента/возвращаемого значения в будущем</li>
                <li>Часто используется при написании повторно используемого кода</li>
            </ul>
            <pre>
                class HoldAnything< TypeOfData >{
                   data: TypeOfData;
                }

                const holdNumber = new HoldAnything< number >();
                holdNumber.data = 111;

                const holdString = new HoldAnything< string >();
                holdString.data = 'something';

                function processingData< T, S >(data: T[], options: S): string {
                   switch (typeof data){
                       case 'string':
                           return `${data}, speed: ${options}`;
                           break;
                       case 'number':
                           return `${data}, speed: ${options}`;
                           break;
                       default:
                           return 'Not Valid'
                   }
                }

                let res1 = processingData([5], 'fast');
                let res2 = processingData(['5'], 'slow');
                const res3 = processingData([5], 5);
                const res4 = processingData< number, string >([5], 'slow');

                interface DataSaver {
                   //processing: < T >(data: T) => T;
                   processing: typeof processing;
                }

                const saver: DataSaver = {
                   processing(data) {
                       console.log(data);
                       return data;
                   }
                }

                const saver2: DataSaver = {
                   processing: < T >(data: T) => data,
                }

                const saver3: DataSaver = {
                   processing: (data) => {
                       return data
                   },
                   //processing: data => data;
                }

                class User2< T, S > {
                   name1: T;
                   age: S;

                   constructor(name1: T, age: S) {
                       this.name1 = name1;
                       this.age = age;
                   }

                   sayMyFullName< T >(surname: T): string{
                       return typeof surname !== 'string' ? `I have only name: ${this.name1}` : `Surname of ${this.name1} is ${surname}`
                   }
                }

                class Admin< G > extends User2< string, number >{
                   rules: G;
                   constructor(name1: string, age: number, rules: G) {
                       super(name1, age);
                       this.rules = rules;
                   }
                }

                const userJohn = new User2('John', 30);

                const nameData = 'David';
                const ageData = 30;

                const userDavid = new User2< string, number >(nameData, ageData);
                console.log(userDavid.sayMyFullName< string >('Bowie'));
            </pre>

            <p>По конвенции используют короткое название < T ></p>
            <pre>
                class HoldAnything< T >{
                   data: T;
                }
            </pre>
            <p>Для дженериков так же присущ автоматический вывод типов, НО, все-таки лучше указывать тип
                дженерика!:</p>
            <pre>
                function printAnything< T >(arr: T[]){
                   arr.forEach(el => console.log(el));
                }

                printAnything([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);  //function printAnything< number >, происходит автоматическое выведение типа
                printAnything< string >(['a', 'b', 'c', 'd', 'e', 'f', 'g']);  // НО все-таки лучше производить аннотацию типа!!!
            </pre>

            <p>Чтобы ограничит дженерики там, где будут использоваться наши кастомные методы или функции, есть
                специальный синтаксис ограничения(generics constraints):</p>
            <pre>
                //generics constraints

                class Human {
                   print() {
                      console.log('Im a human');
                   }
                }

                class Robot {
                   print() {
                      console.log('Im a robot');
                   }
                }

                interface Printable {
                   print(): void;
                }

                function printClass< T extends Printable > (arg: T[]): void {
                   arg.forEach(classEl => classEl.print());
                }

                printClass< Printable >([new Human(), new Robot(), new Human(), new Robot()]);

                //-----------------------------------------------------------------------------//

                interface User1< ParentsData extends ParentsOfUser > {
                   login: string;
                   age: number;
                   parents: ParentsData
                }

                interface ParentsOfUser {
                   father: string;
                   mother: string;
                }

                const user1: User1<{father: string, mother: string, married: boolean, anything: string}> = {
                   login: 'some Login',
                   age: 30,
                   parents: {
                       father: 'John',
                       mother: 'Ann',
                       married: true,
                       anything: 'anything'
                   }
                }

                //generic helpers type

                type OrNull< Type > = Type | null;
                type OneOrMany< Type > = Type | Type[];

                const data1: OneOrMany< number[] > = [5,5,5];

                //-----------------------------------------------------------//
                const depositMoney = < T extends number | string >(amount: T): T => {
                   console.log(`request to server with amount: ${amount}`);
                   return amount;
                }

                depositMoney(500);
                depositMoney('five hundreds');
            </pre>

            <p>Само ограничение создается при помощи синтаксиса < T extends ...></p>
            <p>Partial дженерики это встроенный дженерик который позволяет обойти обязательное использование всех
                свойств задекларированных в интерфейсе:</p>

            <pre>
                interface IState {
                   data: {
                      name: string;
                   };
                   tag: string;
                }

                const state: Partial< IState > = {
                   data: {
                      name: 'John'
                   }
                }
            </pre>

            <p>Если требуется сделать объект иммутабельным, то в блоке аргументов требуется применить ДЖЕНЕРИК(не
                путать
                с модификатором!!!) Readonly< interface > где interface это выбранный нами интерфейс для данного
                объекта:</p>
            <pre>
                interface IState {
                   data: {
                      name: string;
                   };
                   tag: string;
                }

                const action = (state: Readonly< IState >) => {
                   const newObj = state.data;
                }

                //Если же требуется обратная ситуация, где в интерфейсе есть опциональный оператор, а требуется чтобы все свойства
                //были обязательными, то нужно использовать дженерик Required

                interface IState {
                       data: {
                          name: string;
                       };
                       tag: string;
                    }
                    const strictState: Required< IState > = {
                       data: {
                           name: 'David',
                       },
                       tag: 'some tag',
                       someValue: 42,
                    }
            </pre>
        </div>
    </section>

    <h3 id="TSOperators">TypeScript операторы</h3>

    <section>
        <div>
            <p>Оператор keyof:</p>
            <pre>
                interface ICompany {
                   name: string;
                   debts: number;
                }

                type CompanyKeys = keyof ICompany;
                const keys: CompanyKeys = 'name';

                function printDebts< T, K extends keyof T, S extends keyof T >(company: T, name: K, debts: S): void{
                   console.log(`${company[name]}, debts: ${company[debts]}`);
                }

                const hh: ICompany = {
                   name: 'HH',
                   debts: 50000,
                }

                printDebts(hh, 'name', 'debts');

                const google = {
                   name: 'google',
                   debts: 1000000000,
                   open: true,
                }
                printDebts(google, 'name', 'debts');
            </pre>

            <p>Оператор typeof</p>
            <pre>
                const google = {
                   name: 'google',
                   debts: 1000000000,
                   open: true,
                }

                type GoogleKeys = keyof typeof google;
                const someKeys0: GoogleKeys = 'name';
                const someKeys1: GoogleKeys = 'debts';
                const someKeys2: GoogleKeys = 'open';
            </pre>
        </div>
    </section>

    <h3 id="TSClassPropertiesAndMethodsModifieres">TypeScript модификаторы свойств и методов класса</h3>

    <section>
        <div>
            <p>Существуют три модификатора в TS:</p>
            <ul>
                <li>public - дефолтный модификатор, который делает все свойства и методы доступны как внутри класса
                    так
                    и снаружи при создании инстанса класса
                </li>
                <li>private - модификатор, который скрывает свойства и методы вне класса</li>
                <li>protected - модификатор, который скрывает свойства и методы вне класса, НО оставляет их
                    доступными в
                    дочерних классах
                </li>
            </ul>
            <p>Так же в нативном JS свойство либо метод можно сделать приватным с помощью "#", и тогда
                свойство/метод
                будет приватным даже в скомпилированном файле! ДОСТУПНО С ES2015!!!</p>
            <pre>
                const setName = (): string => {
                    return "COD";
                }

                class Player {
                    private static game: string = "COD";
                    #login!: string;
                    private _password!: string;
                    public server!: string;
                    protected consent!: boolean;

                        static { // статичный блок который при первом вызове фиксирует свойства
                            Player.game = setName();
                        }

                    constructor(login: string) {
                        this.#login = login;
                    }

                    get password(){
                        return this._password;
                    }

                    set password(pas: string){
                        //validation
                        this._password = pas
                    }
                }

                class CompetitivePlayer extends Player{
                    rank!: number;

                    constructor(login: string, consent: boolean) {
                        super(login);
                        this.consent = consent;
                    }

                    isConsented(){
                        return this.consent ? 'yes' : 'no'
                    }
                }

                const player = new Player('abrwalg');

                player.password = '125zqu';

                const comPlayer = new CompetitivePlayer('abrwalgCompet', true);
                comPlayer.password = '125zqu';
                console.log(comPlayer.isConsented());
            </pre>
        </div>
        <p># лучше использовать для важных данных, которые следует обезопасить от изменений, в остальных случаях
            лучше
            использовать private/protected.</p>
    </section>

    <h3 id="indexedAccessTypes">Доступ по индексному ключу (Indexed Access Types)</h3>

    <section>
        <div>
            <p>Для того чтобы получить доступ к типу одного из значений интерфейса нужно использовать indexed access
                type, синтаксис следующий:</p>
            <pre>
                interface ICompany {
                   name: string;
                   debts: number;
                   departments: Department1[];
                   management: {
                       owner: string;
                   }
                }

                interface Department1 {
                    [key: string]: string;
                }

                //Indexed Access Types
                type CompanyDebtsType = ICompany['debts'];   //Alias for: ICompany["debts"]; Initial type: number;
                type CompanyOwnerType = ICompany["management"]['owner'];    //Alias for: ICompany["management"]["owner"]; Initial type: string
                type CompanyDepartmentsType = ICompany['departments'][number];    //Alias for: ICompany["departments"][number]; Initial type: Department1;
                type UnionTypeOfICompany = ICompany[keyof ICompany]; //Alias for: ICompany[keyof ICompany]; Initial type: number | {owner: string} | string | Department1[]
            </pre>

            <p>Для того чтобы в скобках использовать значение некой переменной которой мы присвоили ключ энного
                интерфейса в виде строки, то это значение нужно типизировать как примитивный стоковый литерал:</p>
            <pre>
                interface ICompany {
                   name: string;
                   debts: number; // требуется данный тип
                   departments: Department1[];
                   management: {
                       owner: string;
                   }
                }
                const debtsVar = 'debts';
                type CompanyDebtsTypeFromVariable = ICompany[typeof debtsVar]; //Initial type: number
            </pre>
        </div>
    </section>

    <h3 id="ternaryOperatorWithTS">Тернарный оператор и TS</h3>

    <section>
        <div>
            <p>Пример использования тернарного оператора и TS:</p>
            <pre>
                type Example = 'string' extends 'Hello' ? string : number; //Alias for: number
            </pre>
            <p>Где "string" и "Hello" это примитивные строковые литералы. Тк литерал "Hello" не является строкой(а
                строковый литерал), то итоговым типом будет number!!!</p>
            <p>Реальный пример использования тернарного оператора:</p>
            <pre>
                type Example = 'string' extends 'Hello' ? string : number;

                type FromUserOrFromBase< T extends string | number > = T extends string
                    ? IDataFromUser
                    : IDataFromBase;

                interface IDataFromUser {
                    weight: string;
                }

                interface IDataFromBase {
                    calories: number;
                }

                const testDataFromBase: FromUserOrFromBase< number > = {
                    calories: 500;
                }

                const testDataFromUser: FromUserOrFromBase< string > = {
                    weight: '500';
                }

                interface SomeUser< T extends 'created' | Date > {
                    created: T extends 'created' ? 'created' : Date;
                }

                const newUser: SomeUser<'created'> = {
                    created: "created",
                }

                function calculateDailyCalories< T extends string | number >(numOrStr: T): T extends string ? IDataFromUser : IDataFromBase {
                    if (typeof numOrStr === 'string'){
                        const userObj: IDataFromUser = {
                            weight: numOrStr,
                        };
                        return userObj as T extends string ? IDataFromUser : IDataFromBase;
                    }
                    else if(typeof numOrStr === 'number'){
                        const baseObj: IDataFromBase = {
                             calories: numOrStr,
                        };
                        return baseObj as T extends string ? IDataFromUser : IDataFromBase;
                    }
                }

                console.log(calculateDailyCalories(500));
                console.log(calculateDailyCalories('500'));
            </pre>
            <p>Здесь мы проверяем какой будет тип аннотирован в T дженерике, если тип будет
                строкой, то в условной тернарной конструкции будет возвращен IDataFromUser интерфейс, если же
                числовой тип, то IDataFromBase</p>
            <p>Задача на собеседованиях, как сделать type с дженериком, который всегда будет возвращать массив
                типов:</p>
            <pre>
                type ToArray< Type > = Type extends any ? Type[] : never;
                type ExArray = ToArray< string >; //Initial type: string[]
                type ExArray2 = ToArray< number >; //Initial type: number[]
            </pre>
        </div>
    </section>

    <h3 id="mappedTypes">Сопоставление типов (mapped types)</h3>

    <section>
        <div>
            <p>Mapped types имеет следующий условный синтаксис:</p>
            <pre>
                // type СопоставимыйТип = {
                    // [произвольныйИдентификатор in Множество] : ПроизвольныйТипДанных
                // }

                //example

                type Keys = 'name' | 'age' | 'role';

                type User3 = { //Initial type: {name: string, age: string, role: string}
                    [key in Keys]: string
                }

                const Alex: User3 = {
                    name: 'Alex',
                    age: '30',
                    role: 'admin'
                }

                type Currencies = {
                    usa: 'usd';
                    china: 'cny';
                    ukraine: 'uah',
                    kz: 'tenge';
                }

                //type ROnlyCurr = Readonly< Currencies >;

                type CreateCustomCurrencies< T > = {
                    readonly [key in keyof T]?: string
                }

                // type CustomCurrencies = {
                //     usa: string;
                //     china: string;
                //     ukraine: string,
                //     kz: string;
                // }

                type CustomCurrencies = CreateCustomCurrencies< Currencies >; //Initial type:
                //{readonly usa?: string, readonly china?: string, readonly ukraine?: string, readonly kz?: string}
            </pre>
            <p>Чтобы добавлять модификаторы или их убирать требуется перед модификаторами ставить + или -
                соответственно:</p>
            <pre>
                type Currencies = {
                    readonly usa?: 'usd';
                    readonly china?: 'cny';
                    readonly ukraine?: 'uah',
                    readonly kz?: 'tenge';
                }

                type CreateCustomCurrencies< T > = {
                    -readonly [key in keyof T]-?: string
                }

                type CustomCurrencies = CreateCustomCurrencies< Currencies >; //Initial type: {usa: string, china: string, ukraine: string, kz: string}
            </pre>
        </div>
    </section>

    <h3 id="templatesLiteralTypes">Шаблонные литеральные типы (Templates Literal Types)</h3>

    <section>
        <div>
            <p>Шаблонные литеральные типы работают +/- похоже как и шаблонные литеральные строки и основаны на
                строковых
                литеральных типах:</p>
            <pre>
                type MyAnimation = 'fade';
                type Direction = 'in' | 'out';
                type MyNewAnimation = `${MyAnimation}${Capitalize< Direction >}`; //Initial type:"fadeIn" | "fadeOut" | "swipeIn" | "swipeOut"

                type CreateCustomCurrencies1< T > = {
                    -readonly [key in keyof T as `custom${Capitalize< string & key >}`]-?: string
                }

                type Currencies1 = {
                    readonly usa?: 'usd';
                    readonly china?: 'cny';
                    readonly ukraine?: 'uah',
                    readonly kz?: 'tenge';
                }

                type CustomCurrencies1 = CreateCustomCurrencies1< Currencies1 >; //Initial type: {customUsa: string, customChina: string, customUkraine: string, customKz: string}
            </pre>
            <p>Дженерики Uppercase<>, Lowercase<>, Capitalize<>, Uncapitalize<> преобразуют строку в верхний регистр
                нижний регистр, делают первую букву заглавной или наоборот с малой.</p>
        </div>
    </section>

    <h3 id="utilityTypes">Utility Types</h3>

    <section>
        <div>
            <p>Существуют следующие встроенные типы:</p>
            <pre>
                //Omit - исключение свойств типа
                type CurrenciesWithoutUSA = Omit< Currencies2, 'usa' > // Initial type: {china: "cny", ukraine: "uah", kz: "tenge"}

                //Pick - фильтрация по свойству
                type CurrenciesUSAAndUkraine = Pick< Currencies2, 'usa' | 'ukraine' > // Initial type: {usa: "usd", ukraine: "uah"}

                //Exclude - удаление из union type
                type MyAnimation1 = 'fade' | 'swipe';
                type FadeType = Exclude< MyAnimation1, 'swipe' >; //Initial type: "fade"
                type CountriesWithoutUSA = Exclude< keyof Currencies2, 'usa' >; //Initial type: "china" | "ukraine" | "kz"

                //Extract - извлекает тип подходящий по условию
                type SwipeType = Extract< MyAnimation1, 'swipe' >; //Initial type: "swipe"

                //Record - позволяет сконструировать другой тип в формате ключ - значение
                type Currencies2 = {
                    usa: 'usd';
                    china: 'cny';
                    ukraine: 'uah',
                    kz: 'tenge';
                }
                type PlayersNames = 'Alex' | 'John';
                type CreateCustomCurrencies2< T > = {
                    -readonly [key in keyof T as `custom${Capitalize< string & key >}`]-?: string
                }

                type CustomCurrencies2 = CreateCustomCurrencies2< Currencies2 >; //Initial type: {customUsa: string, customChina: string, customUkraine: string, customKz: string}
                type GameDataCurrencies = Record< PlayersNames, CustomCurrencies2 >

                const gameData: GameDataCurrencies = {
                    Alex: {
                        customChina: 'qqqq',
                        customUkraine: '1111',
                        customUsa: '222',
                        customKz: 'dadad'
                    },
                    John: {
                        customKz: 'dawdawd',
                        customUsa: 'davada',
                        customUkraine: 'dawdawdac1',
                        customChina: '141rfd2r4e1'
                    }
                }

                ReturnType - позволяет вернуть тип из функции например
                function calculate(a: number, b: number): number {
                    return a*b;
                }

                type CalculateRT = ReturnType< typeof calculate >; //Initial type: number
                let anotherRes: CalculateRT = 5;

                Parameters - позволяет вернуть тип аргументов функции
                type calculatePT = Parameters< typeof calculate >; //Initial type: [number, number]
                type calculateFirstPT = Parameters< typeof calculate >[0]; //Initial type: number

                ConstructorParameters - позволяет извлечь типы из аргументов конструктора класса

                class Example3 {
                    constructor(a: number) {
                    }
                }

                type ConstructorParams = ConstructorParameters< typeof Example3 > //Initial type: [number]

                //для того чтобы "вытащить" тип из промиса используется дженерик Awaited:
                interface AwaitedUser {
                    name: string;
                }

                async function fetchUsers(): Promise< AwaitedUser[] >{
                    const users: AwaitedUser[] = [
                        {
                            name: "Alex"
                        }
                    ]
                    return users;
                }

                const users = fetchUsers();

                type FetchUsersReturnType = Awaited< ReturnType< typeof fetchUsers >>; //Initial type: AwaitedUser[]

                //до введения данного дженерика это действие выглядело вот так:
                type UnwrappedPromise< T > = T extends Promise< infer Return > ? Return : T;
                type FetchDataReturnType = UnwrappedPromise< ReturnType< typeof fetchUsers >>; //Initial type: AwaitedUser[]
            </pre>
            <p><a href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">Здесь можно
                посмотреть список всех встроенных типов.</a></p>
        </div>
    </section>

    <h3 id="TSFetchAndPromise">TS, Fetch и Promise</h3>

    <section>
        <div>
            <p>Для того чтобы работать с fetch запросами и соответственно с json строкой нужно пользоваться защитой
                типов при присваивании переменным уже сформированный из json'a объект:</p>
            <pre>
                interface Todos {
                    userId: number;
                    id: number;
                    title: string;
                    completed: boolean;
                }

                let toDoList: Todos[] = [];

                function isToDos(json: Todos[]): json is Todos[] {
                    return json.every(json => {
                        return 'userId' in json && 'id' in json && 'title' in json && 'completed' in json;
                    })
                }

                fetch('https://jsonplaceholder.typicode.com/todos').then(res => res.json()).then(data => {
                    if (isToDos(data)){
                        toDoList = [...data];
                    }
                    console.log(toDoList)
                })
            </pre>

            <p>При создании же промисов, сам Promise можно использовать как дженерик:</p>
            <pre>
                const proms = new Promise< string >((resolve,reject) => {
                    resolve('test');
                })

                proms.then(val => console.log(val.toUpperCase()));
            </pre>
        </div>
    </section>

    <h3 id="inheritanceVSComposition">Inheritance vs Composition</h3>

    <section>
        <div>
            <p>Inheritance:</p>
            <img src="./images/inheritanceInTS.png" alt="inheritanceInTS" width="644">
            <p>Inheritance - характеризуется при помощи отношения "это" между двумя классами. Т.е. класс MatchReader
                это
                CsvFileReader.</p>
            <p>Composition:</p>
            <img src="./images/compositionInTS.png" alt="compositionInTS" width="644">
            <p>Composition - характеризуется при помощи отношения "имеет" между двумя классами. Т.е. класс
                MatchReader
                имеет ссылку на объект класса CsvFileReader/ApiReader</p>
        </div>
    </section>

    <h3 id="staticMethodsAndProperties">Статические методы и свойства(static)</h3>

    <section>
        <div>
            <p>Cтатические методы используются для реализации функций, которые будут принадлежать классу в целом, но
                не
                какому-либо его конкретному объекту.</p>
            <p>Статические методы недоступны для отдельных объектов энного класса, только для самого класса!</p>
            <pre>
                class Article {
                   constructor(title, date) {
                     this.title = title;
                     this.date = date;
                   }

                   static compare(articleA, articleB) {
                     return articleA.date - articleB.date;
                   }
                }

                // использование
                let articles = [
                   new Article("HTML", new Date(2019, 1, 1)),
                   new Article("CSS", new Date(2019, 0, 1)),
                   new Article("JavaScript", new Date(2019, 11, 1))
                ];

                articles.sort(Article.compare);

                alert( articles[0].title ); // CSS
            </pre>
            <p>Статические свойства также возможны, они выглядят как свойства класса, но с static в начале:</p>
            <pre>
                class Article {
                   static publisher = "Илья Кантор";
                }

                alert( Article.publisher ); // Илья Кантор
            </pre>
            <p>Статические свойства используются в тех случаях, когда мы хотели бы сохранить данные на уровне
                класса, а
                не какого-то одного объекта.</p>
        </div>
    </section>

    <h3 id="TSWithJSLibraries">TS с JS библиотеками</h3>

    <section>
        <div>
            <p>Т.к. большинство библиотек было написано еще до введения классов и соответственно формирования
                представления о типах, то существует проблема внедрения TS в эти библиотеки. При работе с TS и некой
                библиотекой есть несколько подходов:</p>
            <ul>
                <li>Использование библиотеки, как обычно, добавляя, где возможно, базовые аннотации типов</li>
                <li>Использование библиотеки TS adapter, в которой есть помощники для использования нужной
                    библиотеки с
                    TS
                </li>
                <li>Рефактор библиотеки для работы с классами TS</li>
            </ul>

            <p>При совместной работе TS и требуемой библиотеки должен быть один из двух результатов:</p>
            <ul>
                <li>Повышение безопасности типов(помочь TS лучше выявлять ошибки)</li>
                <li>Значительно улучшить процесс разработки</li>
            </ul>
        </div>
    </section>

    <h3 id="ES2015ClassesInTS">Классы в ES2015 и TS</h3>

    <section>
        <div>
            <p>На самом деле классы как таковые не существуют в JavaScript, классы в JS - это синтаксический сахар
                при
                помощи прототипного наследования.</p>
            <p>Это объясняется следующими примерами, где использован синтаксис EcmaScript 2005 года(когда синтаксиса
                классов еще не было и использовались прототипы):</p>
            <pre>
                //синтаксис классов в ES5
                var Car = /** @class */ (function () {
                    function Car() {
                        this.color = 'red';
                    }
                    Car.prototype.drive = function () {
                        console.log('Im driving');
                    };
                    return Car;
                }());

                new Car().drive(); // -> Im driving

                // так же метод в классах можно создать когда объект класса уже был инициализирован.
                const carWithoutBrake = new Car();
                carWithoutBrake.stop(); // -> error: carWithoutBrake.stop() is not a function

                Car.prototype.stop = function() {
                   console.log('I have stopped')
                }
                carWithoutBrake.stop(); // -> I have stopped
            </pre>
            <p>и синтаксис 2015 года(когда добавили синтаксис классов):</p>
            <pre>
                class Car {
                   color: string = 'red';
                   drive(): void {
                    console.log('im driving')
                   }
                }

                // синтаксис вызова класса один и тот же что в ES5, что в ES2015
                new Car().drive(); // -> im driving
            </pre>
            <p>Когда мы вызываем различные методы для объекта энного класса, прежде всего мы обращаемся к прототипу
                этого класса, в котором уже задекларированы методы</p>
        </div>
    </section>

    <h3 id="setAnGetInTS">Сеттеры и геттеры в TS</h3>

    <section>
        <div>
            <p>сеттеры и геттеры имеют следующий синтаксис</p>
            <pre>
                class Box {
                    width!: number;
                    volume!: number | undefined;
                    private _content!: string | undefined; // если нет модификатора private, но есть "_" то обращаться к данной переменной вне класса так же запрещено!!!

                    constructor(width: number , public height: number, volume?: number, content?: string) {
                        this.width = width;
                        this.volume = volume;
                        this._content = content;
                    }

                    calcVol(): void{
                        if (this.volume){
                            console.log(`Объем посылки: ${this.volume}`)
                        } else {
                            if (typeof this.width === 'number'){
                                this.volume = this.width * this.height;
                                console.log(`Объем посылки: ${this.volume}`)
                            }
                        }
                    }

                    checkBpxSize(transport: number | number[]): string {
                        if (typeof transport === "number"){
                            return transport >= this.width ? 'Ok' : 'Not Ok';
                        } else {
                            return transport.some(tr => tr >= this.width) ? 'Ok' : 'Not Ok'
                        }
                    }

                    get content(){
                        return this._content;
                    }

                    set content(val){
                        this._content = `Date: ${new Date().toTimeString()}, Content: ${val}`;
                    }


                    //в случае если же нужна асинхронная операция, то set и get не могут с ними работать,
                    //нужно использовать обычный асинхронный метод
                    async asyncContent(val: string){
                        const date = await new Date().toTimeString();
                        this._content = `Date: ${date}, Content: ${val}`;
                    }
                }

                const firstBox = new Box(500, 500);
                firstBox.calcVol();
                console.log(firstBox.checkBpxSize([300, 350,400,500]));
                firstBox.content = 'test';
                console.log(firstBox.content);
            </pre>
        </div>
    </section>

    <h3 id="indexClassSignaturesInTS">Индексные сигнатуры классов в TS</h3>

    <section>
        <p>Для того чтобы создавать свойства в уже созданном объекте энного класса, требуется использовать индексные
            сигнатуры:</p>
        <div>
            class Styles {
            [s: string]: string;
            }

            const style = new Styles();
            style.color = 'red';
            style.width = '500 px';
            style.height = '500 px';

            console.log(style); // Styles { color: 'red', width: '500 px', height: '500 px' };
        </div>
        <p>НО!!! у данного метода есть недостаток - невозможно потом объявлять функции не аннотируя их в индексной
            сигнатуре:</p>
        <pre>
            class Styles {
            [s: string]: string | ((number: number) => number);

            method(number: number): number {
                    return number;
                }
            }
        </pre>
    </section>

    <h3 id="classInheritanceInTS">Наследование классов в TS и перезапись свойств и методов потомков</h3>

    <section>
        <div>
            <p>Наследование свойств классов в TS имеет аналогичный синтаксис JS, однако для методов существует
                модификатор override, который следит за тем чтобы в родительском классе есть метод с таким же
                названием, при этом можно так же с помощью super.parentsMethod() (parentsMethod - родительский
                метод)
                вызывать старую версию метода например при каком-то условии:</p>
            <pre>
                class PresentBox extends Box {
                    wrap!: string;
                    height: number = 600; // свойства перезаписываются новой декларацией.

                    constructor(wrap: string, width: number, height?: number,volume?: number, content?: string) {
                        super(width,height, volume, content ); // super - вызов конструктора родителя!

                        this.wrap = wrap;
                    }

                    override async asyncContent(val: string, text?: string) {
                        const date = await new Date().toTimeString();
                        if (!text){
                           await super.asyncContent(val); //вызов родительского метода в случае если text отсутствует
                        } else {
                            this._content = `Date: ${date}, Content: ${val}, Text: ${text ? text : "no text"}`;
                        }
                        console.log(this._content)
                    }
                }

                const presentBox = new PresentBox('red', 500);
            </pre>
        </div>
    </section>

    <h3 id="classInterfaces">Интерфейсы для классов(имплементация интерфейсов)</h3>

    <section>
        <div>
            <p>Для чтобы определить свойства у класса, в него имплементируют интерфейс:</p>
            <pre>
                interface IUser {
                    login: string;
                    password: string;
                }

                interface IValidation {
                    valid: boolean;
                    isValid: (data: string) => boolean;
                }

                class UserForm implements IUser {
                    login!: string;
                    password!: string;
                    isValid: boolean = false;

                    isValid(login: string): boolean { //расширение типа аргумента возможно!
                        return login.length > 3;
                    }
                }
            </pre>
        </div>
    </section>

    <h3 id="contextInClass">Контекст вызова в классе(this)</h3>

    <section>
        <div>
            <p>Когда мы в классе ссылаемся на this, то отсылка идет на свойство будущего экземпляра данного
                класса</p>
            <pre>
                const setName = (): string => {
                    return "COD";
                }

                class Player {
                    private static game: string = "COD";
                    #login!: string;
                    private _password!: string;
                    public server!: string;
                    protected consent!: boolean;

                    static {
                        Player.game = setName();
                    }

                    constructor(login: string) {
                        this.#login = login;
                    }

                    get password(){
                        return this._password;
                    }

                    set password(pas: string){
                        //validation
                        this._password = pas;
                    }

                    static getGameName(): string{
                        return Player.game;
                    }

                    logIn = () => {
                        return `Player ${this.#login} online`
                    }

                    // logIn(this: Player) { // таким образом мы аннотируем каким должен быть this при вызове метода в инстансе класса
                    //     return `Player ${this.#login} online`
                    // }

                    connect() {
                        //Do smth
                        return this;
                    }

                    isPro(): this is CompetitivePlayer{
                        return this instanceof CompetitivePlayer;
                    }


                }

                class CompetitivePlayer extends Player{
                    rank!: number;

                    constructor(login: string, consent: boolean) {
                        super(login);
                        this.consent = consent;
                    }

                    isConsented(){
                        return this.consent ? 'yes' : 'no'
                    }

                    checkLogin(){
                        return this.logIn(); // ВАЖНО!!! методы прописанные стрелочной функцией отсутствуют в прототипе!
                        //поэтому к ним невозможно обратиться с помощью super
                    }
                }

                const player = new Player('abrwalg');

                player.password = '125zqu';
                console.log(player.logIn());
                console.log(player.connect().logIn()); // chaining
                const test = player.logIn; //тк logIn - стрелочная функция то bind(player) не нужен!
                //const test = player.logIn.bind(player); // в случае если метод класса ligIn объявляется не стрелочной функцией!!!!!!
                                                          // тк при присваивании вызова данного метода в таком случае теряется контекст
                console.log(test());
                console.log(player.isPro()); // false

                const comPlayer = new CompetitivePlayer('abrwalgCompet', true);
                comPlayer.password = '125zqu';
                console.log(comPlayer.isConsented());
                console.log(comPlayer.checkLogin());
                console.log(comPlayer.isPro()); // true
            </pre>
        </div>
    </section>

    <h3 id="decoratorsWithTS">Декораторы в TypeScript</h3>

    <section>
        <div>
            <p>Decorators:</p>
            <ul>
                <li>Функции, которые можно использовать для модификации / изменения различных свойств или методов в
                    классе
                </li>
                <li>Не то же самое, что декораторы в JS</li>
                <li>Используются только с классами</li>
                <li>Понимание порядка, в котором запускаются декораторы, является ключом к их общему пониманию</li>
                <li>Экспериментальная фича</li>
            </ul>

            <p>Пример декоратора:</p>
            <pre>
                class DecoratedCar {
                   color: string = 'red';

                   get formattedColor(): string {
                      return `This color is ${this.color}`
                   }

                   @logError
                   @testDecorator
                   drive(): void {
                      console.log("I'm driving");
                   }
                }

                function testDecorator(target: any, key: string): void {
                   console.log('Target', target); // Target { drive: [Function (anonymous)] }
                   console.log('Key', key); // Key drive
                }


                function logError(target: any, key: string, descriptor: PropertyDescriptor): void {
                   const method = descriptor.value;

                   descriptor.value = function () {
                       try {
                           method();
                       } catch (err){
                           console.log('The car is crashed')
                       }
                   }
                }

                const someCar = new DecoratedCar();
                someCar.drive(); // The car is crashed

                //декораторы классов(курс Петриченко)
                interface ICar {
                    fuel: string;
                    open: boolean;
                    freeSeats: number;
                    isOpenAndFuel: () => string;
                }

                function closeCarDec< T extends {new (...args: any[]): {}} >(constructor: T) {
                    //constructor.prototype.fuel = '100%' не изменяет свойство тк конструктор перезаписывает его!
                    //constructor.prototype.open = false; не изменяет свойство тк конструктор перезаписывает его!
                    return class extends constructor {
                        fuel = '100%';
                        open = false;
                    }
                }

                @closeCarDec
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    freeSeats: number = 3;
                    isOpenAndFuel() {
                        return `${this.open} and ${this.fuel}`;
                    }
                }

                const newCar = new MyCar();
                //console.log(closeCar(addFuel(newCar).isOpenAndFuel())); //addFuel / close car / MyCar { fuel: '100%', open: false, freeSeats: 3 }
                console.log(newCar.isOpenAndFuel()); //false and 100%
            </pre>
            <p>Где target/constructor - прототип декорируемого класса DecoratedCar, key - ключ свойства / метода /
                аксессора к
                объекту(в нашем случае drive). Так же существует третий аргумент - дескриптор
                свойства(PropertyDescriptor - объект, который имеет конфигурационные опции о свойстве определенном
                для
                объекта). Декораторы применяются при запуске кода для этого класса(а не при создании экземпляра
                класса)</p>

            <table>
                <caption>PropertyDescriptor для методов:</caption>
                <tbody>
                <tr>
                    <td>writable:</td>
                    <td>Можно ли изменить это свойство</td>
                </tr>
                <tr>
                    <td>enumerable:</td>
                    <td>Можно ли итерировать это свойство при помощи цикла(for...in)</td>
                </tr>
                <tr>
                    <td>value:</td>
                    <td>Текущее значение</td>
                </tr>
                <tr>
                    <td>configurable:</td>
                    <td>Определение свойства можно изменить и свойство можно удалить</td>
                </tr>
                </tbody>
            </table>
        </div>
    </section>

    <h3 id="decoratorFactory">Decorator Factory (Фабрика декораторов)</h3>

    <section>
        <div>
            <p>Чтобы декоратор работал с конфигурационными параметрами нужно обернуть его в функцию, которая будет
                возвращать сам декоратор, данный подход называется фабрикой декораторов:</p>
            <pre>
                class DecoratedCar {
                   color: string = 'red';

                   get formattedColor(): string {
                      return `This color is ${this.color}`
                   }

                   @logError('The car is crashed')
                   drive(): void {
                      throw new Error();
                      console.log("I'm driving");
                   }
                }

                function logError(errorMessage: string) {
                   return function (target: any, key: string, descriptor: PropertyDescriptor): void {
                      const method = descriptor.value;

                      descriptor.value = function () {
                         try {
                            method();
                         } catch (err) {
                            console.log(errorMessage)
                         }
                      }
                   }
                }

                const someCar = new DecoratedCar();
                someCar.drive();

                //petrechenkos example

                function changeAmountOfFuel(amount: number){
                    console.log('fuel init');  // в консоли будет 1м месте
                    return < T extends { new(...args: any[]): {} } >(constructor: T) => {
                        console.log('fuel changed'); // в консоли будет на 4м месте
                        return class extends constructor {
                            fuel = `${amount}%`;
                        }
                    }
                }

                function changeDoorStatus(status: boolean) {
                    console.log('door init'); // в консоли будет 2м месте
                    return < T extends { new(...args: any[]): {} } >(constructor: T) => {
                        console.log('door changed'); // в консоли будет 3м месте
                        return class extends constructor {
                            open = status;
                        }
                    }
                }

                @changeAmountOfFuel(75)
                @changeDoorStatus(false) // цепочка вызова декораторов
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    freeSeats: number = 3;
                    isOpenAndFuel() {
                    return `${this.open} and ${this.fuel}`;
                    }
                }

                const newCar = new MyCar();
                console.log(newCar.isOpenAndFuel()); //false and 75%
            </pre>
            <p>Порядок вызова функций от нижнего декоратора к верхнему, т.е. сначала сработает changeDoorStatus тк
                он
                ближе к декорируемому классу, а потом changeAmountOfFuel!!! Суть +- та же что и в декораторах
                JS(первыми
                срабатывают те что вложены в функцию). НО инициализация функций происходит по порядку следования
                кода!!! Т.е. инициализируются функции от первой к последней, а срабатывают от последней к первой по
                позициям в коде</p>
        </div>
    </section>

    <h3 id="ESDecorators">ES декораторы из версии 5+, ES декораторы классов.</h3>

    <section>
        <div>
            <p>Тема требует разбора!</p>
        </div>
    </section>

    <h3 id="methodsDecoratorsAndThis">Декораторы методов класса и работа с this</h3>

    <section>
        <div>
            <p>Чтобы создавать декораторы для методов класса нужно использовать три параметра: target - который
                указывает на декорируемый объект,
                propertyKey - название метода и descriptor - объект дескриптора, соответствующий методу, для
                которого
                вызывается декоратор./p>
            <pre>
                function changeAmountOfFuel(amount: number){
                    console.log('fuel init')
                    return < T extends { new(...args: any[]): {} } >(target: T) => {
                        console.log('fuel changed');
                        return class extends target {
                            fuel = `${amount}%`;
                        }
                    }
                }

                function changeDoorStatus(status: boolean) {
                    console.log('door init')
                    return < T extends { new(...args: any[]): {} } >(target: T) => {
                        console.log('door changed');
                        return class extends target {
                            open = status;
                        }
                    }
                }

                function checkAmountOfFuel(target: Object,propertyKey: string | symbol, descriptor: PropertyDescriptor): PropertyDescriptor | void{
                    const isOpenAndFuelFunction = descriptor.value;
                    descriptor.value = function(this: any, ...args: any[]) {
                        return `${isOpenAndFuelFunction.apply(this, args)}, fuel amount: ${this.fuel}`; //функционал старого метода класса и добавление нового функционала
                    }
                }

                //@closeCarDec
                @changeAmountOfFuel(75)
                @changeDoorStatus(false)
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    freeSeats: number = 3;

                    @checkAmountOfFuel
                    isOpenAndFuel(value: string) {
                        return `isOpen?: ${this.open} ${value}`;
                    }
                }
                const newCar = new MyCar();
                console.log(newCar.isOpenAndFuel('checked')); //isOpen?: false checked, fuel amount: 75%
            </pre>
            <p>Чтобы старый фукционал метода работал, необходимо создать новую переменную которой нужно присвоить
                descriptor.value где собственно и хранится ссылка на старый метод, и вызвать ее в теле новой
                функции, но
                тк в старом методе могут
                содержаться контексты this иногда требуется привязать контекст к переменной с ссылкой через
                apply(this)</p>
            <p>Так же в декорируемом методе могут быть аргументы, и для этого в функции требуется задать второй
                параметр
                где мы разворачиваем блок возможных переменных ...args: any[] и используем args в переменной со
                ссылкой
                на старый метод вторым аргументом после this</p>
        </div>
    </section>

    <h3 id="decoratorsAndClassProperties">Декораторы и свойства класса</h3>

    <section>
        <div>
            <p>Мы можем получить через декоратор доступ к названию свойства, но к его содержимому получить доступ
                уже не
                можем, тк декоратор запускается до создания объекта данного класса.</p>
        </div>
    </section>

    <h3 id="argumentsDecorators">Декораторы аргументов методов класса и декораторы самого класса</h3>

    <section>
        <div>
            <p>Декораторы можно использовать как для самого класса, как для аргументов метода этого класса, так и
                для
                статических методов:</p>
            <pre>
                @classDecorator
                class DecoratedCar {
                    color: string = 'red';

                    get formattedColor(): string {
                        return `This color is ${this.color}`
                    }

                    @logError('The car is crashed')
                    drive(@propsDecorator speed: string): void {
                        //throw new Error();
                        if (speed === 'fast'){
                            console.log("I'm driving fast")
                        } else {
                            console.log("I'm driving");
                        }
                    }
                }

                function classDecorator(constructor: typeof DecoratedCar | Function) {
                    console.log(constructor);
                }

                function propsDecorator(target: any, key: string, index: number) {
                    console.log(key, index);
                }

                function logError(errorMessage: string) {
                    return function (target: any, key: string, descriptor: PropertyDescriptor): void {
                        const method = descriptor.value;

                        descriptor.value = function () {
                            try {
                                method();
                            } catch (err) {
                                console.log(errorMessage)
                            }
                        }
                    }
                }

                const someCar = new DecoratedCar();
                someCar.drive('fast');
            </pre>
        </div>
    </section>

    <h3 id="propertiesDecorators">Декораторы свойств класса</h3>

    <section>
        <div>
            <p>Декораторы свойств работают по принципу set | get, мы в ручную создаем setter и getter с аналогичным
                функционалом в декораторе и с помощью Object.defineProperty заменяем set на setter и get на
                getter:</p>
            <pre>
                function checkNumberOfSeats(limit: number){
                    return function (target: Object, propertyKey: string | symbol){
                        let value: number;
                        const getter = function (){
                            return value;
                        }
                        const setter = function (newAmount: number) {
                            if (newAmount >= 1 && newAmount < limit){
                                value = newAmount;
                            } else {
                                //console.log(`Больше ${limit} сидений быть не может`);
                                Object.defineProperty(target, 'errors', {
                                    value: `Больше ${limit} сидений быть не может`,
                                })
                            }
                        }

                        Object.defineProperty(target, propertyKey, {
                            get: getter,
                            set: setter,
                        })
                    }
                }

                @changeAmountOfFuel(75)
                @changeDoorStatus(false)
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;

                    @checkNumberOfSeats(4)
                    freeSeats!: number;

                    @checkAmountOfFuel
                    isOpenAndFuel(value: string) {
                        return `isOpen?: ${this.open} ${value}`;
                    }
                }

                const newCar = new MyCar();
                newCar.freeSeats = 3;
                console.log(newCar.freeSeats)
            </pre>
            <p>При создании декоратора так же используется фабрика декораторов, но только с двумя аргумента
                аргументами
                - target: Object, propertyKey: string | symbol</p>
        </div>
    </section>

    <h3 id="accessorsDecorators">Декоратор аксесоров класса</h3>

    <section>
        <div>
            <p>Декораторы аксесоров похожи на декораторы методов, но вместо descriptor.value используется
                descriptor.set и descriptor.get изменяя соответственно сеттер и геттер класса. Декорировать @ можно
                как
                set так и get, но одновременно применять нельзя.</p>
            <pre>
                function logAddWeight(
                    target: Object,
                    propertyKey: string | symbol,
                    descriptor: PropertyDescriptor
                ): PropertyDescriptor | void {
                    const oldFunction = descriptor.set;
                    const oldGet = descriptor.get;

                    descriptor.set = function (this: any, ...args: any){
                        console.log(`Изменяем значения на ${[...args]}`)
                        return oldFunction?.apply(this, args)
                    }

                    descriptor.get = function () {
                        console.log('some text');
                        return oldGet?.apply(this)
                    }
                }

                @changeAmountOfFuel(75)
                @changeDoorStatus(false)
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    _weight1: number = 1000;

                    @logAddWeight
                    set weight1(weight: number){
                        this._weight1 = this._weight1 + weight;
                    }

                    get weight1(){
                        return this._weight1;
                    }

                    @checkNumberOfSeats(4)
                    freeSeats!: number;

                    @checkAmountOfFuel
                    isOpenAndFuel(value: string) {
                        return `isOpen?: ${this.open} ${value}`;
                    }
                }

                newCar.freeSeats = 3;//Изменяем значения на 300
                console.log(newCar.weight1);//some text //1300
                console.log(newCar); //MyCar { fuel: '75%', open: false, _weight1: 1300 }
            </pre>
        </div>
    </section>

    <h3 id="parameterDecorators">Декораторы параметров</h3>

    <section>
        <div>
            <p>Декораторы параметров класса применяются прежде всего для их валидации. Для работы с параметрами
                методов
                класса нужно использовать библиотеку
                <a href="https://github.com/rbuckton/reflect-metadata?ysclid=lnksrp3jye581655524" target="_blank">Metadata
                    Reflection API</a>, для того чтобы через метадату настраивать функционал. Так же нужно
                декорировать
                как метод, так и параметры этого метода:</p>
            <pre>
                import 'reflect-metadata';
                const limitMetaDataKey = Symbol('limit');

                function passengersLimit(
                    target: Object,
                    propertyKey: string | symbol,
                    parameterIndex: number,
                ){
                    // console.log(Reflect.getOwnMetadata('design:type', target, propertyKey));
                    // console.log(Reflect.getOwnMetadata('design:paramtypes', target, propertyKey));
                    // console.log(Reflect.getOwnMetadata('design:returntype', target, propertyKey));

                    let limitedParams: number[] = Reflect.getOwnMetadata(limitMetaDataKey, target, propertyKey) || [];
                    limitedParams.push(parameterIndex);
                    Reflect.defineMetadata(limitMetaDataKey, limitedParams, target, propertyKey);
                }

                function validateLimits(
                    target: Object,
                    propertyKey: string | symbol,
                    descriptor: PropertyDescriptor,
                ): PropertyDescriptor | void {
                    let method = descriptor.value;
                    descriptor.value = function (...args: any) {
                        let limitedParams: number[] = Reflect.getOwnMetadata(limitMetaDataKey, target, propertyKey);
                        if (limitedParams) {
                            for (let index of limitedParams){
                                if (args[index] > 4){
                                    throw new Error('Нельзя посадить больше 4х пассажиров')
                                }
                            }
                        }

                        return method?.apply(this, args);
                    }
                }

                //@changeAmountOfFuel(75)
                //@changeDoorStatus(false)
                class MyCar implements ICar{
                    fuel: string = '50%';
                    open: boolean = true;
                    _weight1: number = 1000;

                    //@logAddWeight
                    set weight1(weight: number){
                        this._weight1 = this._weight1 + weight;
                    }

                    get weight1(): number {
                        return this._weight1;
                    }

                    //@checkNumberOfSeats(4)
                    freeSeats!: number;

                    //@checkAmountOfFuel
                    isOpenAndFuel(value: string) {
                        return `isOpen?: ${this.open} ${value}`;
                    }

                    @validateLimits
                    startTravel(@passengersLimit passengers: number){
                        console.log(`Started with ${passengers} passengers`)
                    }
                }
                const newCar = new MyCar();
                newCar.startTravel(3); // Started with 3 passengers
                newCar.startTravel(5); // error
            </pre>
        </div>
    </section>

    <h3 id="decoratorsOrder">Порядок выполнения всех типов декораторов</h3>

    <section>
        <div>
            <p>Порядок выполнения декораторов имеет следующую последовательность:</p>
            <ol>
                <li>Декораторы параметров, за которыми следуют декораторы методов, аксессоров или свойств,
                    применяемые
                    для каждого члена экземпляра.
                </li>
                <li>Декораторы параметров, за которыми следуют декораторы методов, аксессоров или свойств,
                    применяемые
                    для каждого статического члена.
                </li>
                <li>Декораторы параметров применяемые для конструктора.</li>
                <li>Декораторы класса применяемые к классу.</li>
            </ol>
        </div>
    </section>

    <h3 id="typeUnion">Type union(Объединение типов)</h3>

    <section>
        <div>
            <p>В случае если какой либо аргумент будет принимать различные объекты с различными типами/интерфейсами
                -
                используют объединение типов:</p>
            <img src="./images/typeUnion.png" alt="typeUnion" width="644">
        </div>
    </section>
    <p>Где Action это тип в который мы поместили все возможные типы action применяемые в редьюсере.</p>
    <br>

    <h3 id="typeIntersection">Пересечение типов(intersection)</h3>

    <section>
        <div>
            <p>Пересечение типов позволяет использовать сразу несколько типов:</p>
            <pre>
                interface ServerConfiguration {
                   protocol: 'http' | 'https';
                   port: 3000 | 3001;
                }

                interface Role {
                   role: 'admin' | 'sysadmin';
                }

                //type ServerConfigurationWithRole = ServerConfiguration & Role;
                interface ServerConfigurationWithRole extends ServerConfiguration, Role{
                   test: string;
                }

                const serverConfig: ServerConfigurationWithRole = {
                   protocol: 'https',
                   port: 3001,
                   role: 'admin',
                   test: 'some test'
                }

                const backupConfig: ServerConfigurationWithRole = {
                   protocol: "http",
                   port: 3000,
                   role: 'sysadmin',
                   test: 'some test'
                }
            </pre>
        </div>
    </section>

    <h3 id="reactWithRedux1">React при работе с TypeScript 1</h3>

    <section>
        <div>
            <p>Для того чтобы типизировать функциональные компоненты, используют FC тип(function component).</p>
            <p>В случае если нам требуется затипизировать props, то нужно создать type alias, который мы будем
                передавать как дженерик в FC.</p>
            <p>в случае если нам нужно запретить передачу children при последующем использовании компонентов, то
                нужно
                просто не передавать его в наш type alias, и обратно если нужно.</p>
            <p>В случае если мы хотим стилизовать некий элемент, и нам требуется взять некие стили из props, мы так
                же
                можем их типизировать.</p>
            <pre>
                import React from "react";

                type TodoItemProps = {
                    id: string;
                    title: string;
                    completed: boolean;
                    children?: React.ReactNode; // в случае если children не нужен, то просто удалить из type alias
                    style?: React.CSSProperties;
                }

                const TodoItem: React.FC< TodoItemProps> = ({id, title, completed, children, style}) => {
                    return (
                        < ul>
                            < li style={{color: "red", background: "white", ...style}}>
                                < input type="checkbox" checked={completed}/>
                            < /li>
                            < span>{title}< /span>
                            < span>&times;< /span>
                            < span>{children}< /span>
                        < /ul>
                    )
                }

                TodoItem.defaultProps = {
                    id: 'default id',
                    title: 'default title',
                    completed: false,
                }

                export default TodoItem;
            </pre>
            <p>В случае если нам нужен доступ к дефолтным props, то нужно типизировать саму функцию как в примере
                выше,
                если это не требуется, то вместо нее можно типизировать блок аргументов с props</p>
            <pre>
                const TodoItem = ({id, title, completed, children, style}: TodoItemProps) => {
                   ...
                }
            </pre>

            <p>Когда мы работаем с useState, и передаем в него примитивные типы, то можно полагаться на вывод
                типов(type
                inference), вывод типов отлично справится с контролем ошибок, в случае если же передаем НЕ
                примитивные
                типы, массивы объекты и тд, то useState< T> можно использовать как дженерик, где вместо T мы
                подставим
                свой type alias или напрямую аннотируем тип(например < string[]>. [1]</p>

            <p>В случае если мы работаем с хендлерами и их ивентами, то нам нужно их типизировать следующим образом:
                [2]</p>
            <p>Тип хендлера можно узнать из описания onChange(или другого примененного атрибута, например onClick).
                [3]</p>
            <p>При работе с useEffect в котором мы делаем запрос на сервер и ожидаем некий ответ от него, мы можем
                столкнуться с проблемой типа "any" ибо парсинг JSON объекта всегда возвращает неопределенный объект.
                Для
                решения данной проблемы мы можем создать type guard который будет сверять свойства в объекте и в
                случае
                если распаршеный объект соответствует нашему интерфейсу, мы можем выполнять с ним какое-то действие.
                [4]</p>
            <p>В случае если мы используем useRef, то нам нужно задать ему дженерик в который мы поместим тот HTML
                элемент, к которому относится наш useRef, а при работе с .current.value нам нужно проверить сам Ref
                на
                наличие. [5]</p>

            <pre>
                //NewTodoForm React Component

                interface NewTodoFormProps {
                    //value: string;
                    //onChange: (event: React.ChangeEvent< HTMLInputElement>) => void; //[2] //React.ChangeEventHandler< HTMLInputElement>
                    clickHandler: (text: string) => void;
                    //clickHandler: () => void; // [2]
                }

                const NewTodoForm = ({value, onChange, clickHandler }: NewTodoFormProps) => {
                    const inputRef = useRef< HTMLInputElement>(null); //[5]

                    const onClick = () => {
                        if (inputRef.current){ //[5]
                            clickHandler(inputRef.current.value)
                        }
                    }

                    return (
                        <>
                            < input
                                type="text"
                                placeholder='new todo'
                                //value={value}
                                //onChange={onChange} //[3] - React.InputHTMLAttributes< T>.onChange?: React.ChangeEventHandler< HTMLInputElement> | undefined
                                ref={inputRef}
                            />
                            < button onClick={onClick /*clickHandler*/}>Add todo< /button>
                        < />
                    )
                }

                export default NewTodoForm;

                //----------------------------------------------------------------------------//

                //App React Component

                import React, {useState} from 'react';

                import './App.css';
                import TodoItem from "./components/TodoItem";
                import NewTodoForm from "./components/NewTodoForm";

                type ITodo = {
                    id: string;
                    title: string;
                    completed: boolean;
                }

                function App() {
                    //const [text, setText] = useState(''); //[1]
                    const [todos, setTodos] = useState< ITodo[]>([]); //[1]; если не типизировать дженерик то будет never[]

                    //const inputChangeHandler = (event: React.ChangeEvent< HTMLInputElement>) => {
                    //    setText(event.target.value)
                    //}

                    const addTodoHandler = (text: string) => { // const addTodoHandler = () => {...}; если не используем useRef
                        const newTodo: ITodo = {
                            id: new Date().toLocaleString(),
                            title: text,
                            completed: false,
                        }

                        setTodos([newTodo, ...todos]);
                        //setText('');
                    }

                    const dataIsTodo = (data: Todo[]): data is Todo[] => { //[4]
                        return data.every(todo => {
                            return 'id' in todo && 'title' in todo && 'completed' in todo;
                        });
                    }

                    useEffect(() => { //[4]
                        fetch('https://jsonplaceholder.typicode.com/todos')
                            .then(res => res.json())
                            .then((data: Todo[]) => {
                                if (dataIsTodo(data)){
                                    setTodos(data)
                                } else {
                                    throw new Error('Data is not Todo List')
                                }
                            })
                    }, [])

                    return (
                      < div className="App">
                          < NewTodoForm
                                  //value={text}
                                  //onChange={inputChangeHandler}
                                  clickHandler={addTodoHandler}
                          />
                          < TodoItem id={'qwerty'} title={'someTodo'} completed={false} style={{border: '1px solid white',}}>Some children title< /TodoItem>
                      < /div>
                    );
                }

                export default App;
            </pre>
        </div>
    </section>

    <h3 id="reactWithRedux2">React+Redux при работе с TypeScript 2</h3>

    <section>
        <div>
            <p>Плюсы:</p>
            <ul>
                <li>Намного проще избежать очень распространенных опечаток, таких как неправильные типы action</li>
                <li>Дает разработчикам лучшее понимание типов передаваемых данных</li>
                <li>Намного проще делать рефакторинг</li>
            </ul>
            <p>Минусы:</p>
            <ul>
                <li>Не самые лучшие файлы определения типа(особенно для Redux)</li>
                <li>Огромное количество Generics</li>
                <li>Очень много импортов, т.к. почти всё(action creator, action, reducer, store, component) должно
                    знать
                    о разных типах
                </li>
                <li>Redux по своей сути функциональный и его трудно интегрировать с классами TS</li>
            </ul>

            <p>Для того, чтобы работать с props и state в КЛАССОВЫХ компонентах React, нужно наследовать(extends)
                наш
                классовый компонент от дженерика React.Component< propArg, stateArg >, где propArg это интерфейс
                описывающий типы props, а stateArg это интерфейс описывающий типы состояний:</p>
            <pre>
                import React from "react";
                import ReactDOM from "react-dom";

                interface AppProps {
                   color?: string;
                }

                interface AppState {
                   counter: number;
                }

                class App extends React.Component< AppProps, AppState >{

                    constructor(props: AppProps) {
                        super(props);
                        this.state = {counter: 0}
                    }

                    onIncrement(): void{
                        this.setState({
                            counter: this.state.counter + 1,
                        })
                    }
                    onDecrement(): void{
                        this.setState({
                            counter: this.state.counter - 1,
                        })
                    }

                    render() {
                        return (
                            < div >
                                < p >{this.state.counter}< /p >
                                < button onClick={this.onIncrement.bind(this)}>+< /button>
                                < button onClick={this.onDecrement.bind(this)}>-< /button>
                            < /div >
                        )
                    }
                }

                ReactDOM.render(< App color='green'/ >, document.getElementById('root'));
            </pre>
        </div>
    </section>

    <h3 id="reduxWithTS3">Redux + TS 3</h3>

    <section>
        <div>
            <p>При миграции приложения на React-Redux в перую очередь нужно создать хранилище состояний(store,
                который
                вложим в качестве зависимости, оборачивающего компонента < Provider store={store}> < App /> <
                Provider/>):</p>
            <pre>
                //store.ts

                import { configureStore } from "@reduxjs/toolkit";
                import { combineReducers } from "@reduxjs/toolkit";

                const rootReducer = combineReducers({});

                export const store = configureStore({
                    reducer: rootReducer,
                });

                //export type RootState = ReturnType< typeof rootReducer >;
                export type RootState = ReturnType< typeof store.getState >;
                export type AppDispatch = typeof store.dispatch;
            </pre>
            <p>Далее мы создаем файл с кастомными Redux хуками(вцелом можно обойтись и без данного файла и
                использовать
                useDispatch совместно с дженериком в каждом файле где он применяется, но лучше вынести в отдельный
                файл):</p>
            <pre>
                import {TypedUseSelectorHook, useDispatch, useSelector} from 'react-redux';
                import { AppDispatch, RootState } from './store';

                export const useAppDispatch = () => useDispatch< AppDispatch>();
                export const useAppSelector: TypedUseSelectorHook< RootState> = useSelector;
            </pre>
            <p>В файле со слайсами типизируются initialState и сами редьюсеры(а именно action при помощи дженерика
                PayloadAction<>):</p>
            <pre>
                //todoSlice

                import { createSlice, PayloadAction } from "@reduxjs/toolkit";

                import {Todo} from "../../types";

                const initialState: Todo[] = [];

                const todoSlice = createSlice({
                    name: '@todos',
                    initialState,
                    reducers: {
                        addTodo(state, action: PayloadAction< string>){
                            const newTodo: Todo = {
                                id: new Date().toLocaleString(),
                                title: action.payload,
                                completed: false,
                            }

                            return [newTodo, ...state];
                        },
                        toggleTodo(state, action: PayloadAction< Todo['id']>) {
                            // return state.map(todo => {
                            //         if (todo.id !== action.payload) return todo
                            //         return {
                            //             ...todo,
                            //             completed: !todo.completed,
                            //         }
                            // })
                            const todo = state.find(el => el.id === action.payload);
                            if (todo) {
                                todo.completed = !todo.completed;
                            }
                        },
                        removeTodo(state, action: PayloadAction< Todo['id']>){
                            return state.filter(todo => todo.id !== action.payload);
                        }
                    }
                })

                export default todoSlice.reducer;
                export const {
                    addTodo,
                    removeTodo,
                    toggleTodo
                } = todoSlice.actions
            </pre>
            <p>Для типизации селекторов, селектор выносят в отдельный файл и типизируют state:</p>
            <pre>
                //todoSelectors.ts

                import {RootState} from "../../store";

                export const selectAllTodos = (state: RootState) => state.todos;
            </pre>
            <p>Async thunk actions типизируются только внутренные переменные:</p>
            <pre>
                import { createAsyncThunk } from "@reduxjs/toolkit";
                import {Todo} from "../../types";

                export const fetchAllTodos = createAsyncThunk(
                    'todos/fetchTodos',
                    async () => {
                        const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');
                        const data = await response.json() as Todo[];
                        return data;
                    }
                )

                export const createTodo = createAsyncThunk(
                    'todo/createTodo',
                    async (text: string) => {
                        const newTodo: Todo = {
                            title: text,
                            id: Math.random(),
                            completed: false,
                            userId: Math.random(),
                        }

                        const response = await fetch('https://jsonplaceholder.typicode.com/todos',{
                            method: 'POST',
                            headers: {
                                'Content-Type' : 'application/json',
                            },
                            body: JSON.stringify(newTodo)
                        });

                        return (await response.json()) as Todo;
                    }
                )
            </pre>
            <p>Сами же экстра редьюсеры в типизации не нуждаются тк они уже протипизированны "из коробки":</p>
            <pre>
                import { createSlice } from "@reduxjs/toolkit";

                import { Todo } from "../../types";
                import { createTodo, fetchAllTodos } from "./todoAsyncActions";

                interface IInitialState {
                    status: 'idle' | 'loading' | 'finished' | 'error';
                    todoList: Todo[];
                }

                const initialState: IInitialState = {
                    status: 'idle',
                    todoList: [],
                }

                const todoSlice = createSlice({
                    name: '@todos',
                    initialState,
                    reducers: {},
                    extraReducers: (builder) => {
                        builder
                            .addCase(fetchAllTodos.pending, (state) => {
                                state.status = 'loading';
                            })
                            .addCase(fetchAllTodos.fulfilled, (state, action) => {
                                state.status = 'finished';
                                state.todoList = action.payload;
                            })
                            .addCase(fetchAllTodos.rejected, (state) => {
                                state.status = 'error';
                            })
                            .addCase(createTodo.fulfilled, (state, action) => {
                                state.todoList.push(action.payload);
                            })
                    }
                })

                export default todoSlice.reducer;
            </pre>
            <p>AsyncThunk как дженерик имеет следующие аргументы:</p>
            <pre>
                function createAsyncThunk<
                    Returned, // возвращаемое значение
                    ThunkArg, // аргумент который принимает функция
                    ThunkApiConfig extends AsyncThunkConfig
                >
                //где AsyncThunkConfig:

                type AsyncThunkConfig = {
                    state?: unknown
                    dispatch?: Dispatch
                    extra?: unknown
                    rejectValue?: unknown
                    serializedErrorType?: unknown
                    pendingMeta?: unknown
                    fulfilledMeta?: unknown
                    rejectedMeta?: unknown
                }
            </pre>
            <p>Пример:</p>
            <pre>
                import {createAsyncThunk} from "@reduxjs/toolkit";
                import {Todo} from "../../types";
                import {IInitialState} from "./asyncTodoSlice";

                export const fetchAllTodos = createAsyncThunk<
                    Todo[], // возвращаемое значение
                    undefined, // аргумент(в данном случае он отсутствует)
                    {state: {asyncTodos: IInitialState} // cостояние из хранилища
                }>(
                    'todos/fetchTodos',
                    async () => {
                        const response = await fetch('https://jsonplaceholder.typicode.com/todos?_limit=10');
                        return await response.json();
                    },
                    {
                        condition(_, {getState}){
                            const {status} = getState().asyncTodos; //деструктурирование status из полученного состояния asyncTodos из getState

                            if (status === 'loading'){
                                return false;
                            }
                        }
                    }
                )

                export const createTodo = createAsyncThunk<
                    Todo, // возвращаемое значение
                    string // тип text
                    >(
                    'todo/createTodo',
                    async (text: string) => {
                        const newTodo: Todo = {
                            title: text,
                            id: Math.random(),
                            completed: false,
                            userId: Math.random(),
                        }

                        const response = await fetch('https://jsonplaceholder.typicode.com/todos',{
                            method: 'POST',
                            headers: {
                                'Content-Type' : 'application/json',
                            },
                            body: JSON.stringify(newTodo)
                        });

                        return await response.json();
                    }
                )
            </pre>
        </div>
    </section>

    <h2 id="nodeJS">Основы Node JS</h2>

    <h3 id="nodeJSModules">Стандартные модули Node JS</h3>

    <section>
        <div>
            <p>В node JS существуют следующие глобально доступные объекты</p>
            <ol>
                <li>process</li>
                <li>URL</li>
            </ol>
            <p>Так же можно экспортировать следующие модули:</p>
            <ol>
                <li>fs (file-system)</li>
                <li>path</li>
                <li>http</li>
                <li>events (Event Emitter)</li>
            </ol>
        </div>
    </section>

    <h3 id="NJSCryptoModule">Потоки в node JS и модуль crypcto</h3>

    <section>
        <div>
            <p>Сам по себе node JS однопоточный, НО при этом библиотеки могут быть многопоточными благодаря <a
                    href="https://github.com/libuv/libuv" target="_blank">Libuv</a>, рассмотрим на примере глобального
                объекта crypto</p>
            <p>Модуль crypto предназначен для криптографических операций - для шифрования, дешифорования и
                хеширования.</p>
            <pre>
                const crypto = require('crypto');

                const start = Date.now();

                crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
                    console.log('1 end', Date.now() - start)
                })

                crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
                    console.log('2 end', Date.now() - start)
                })

                crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
                    console.log('3 end', Date.now() - start)
                })

                crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
                    console.log('4 end', Date.now() - start)
                })

                crypto.pbkdf2('123ttt', '5', 1000000, 64, 'sha512', () => {
                    console.log('5 end', Date.now() - start)
                })

                // 'end 1-4 выполняются первыми, после того как один из потоков освободился начинатеся выполняться "end 5"'
            </pre>

            <p>С помощью модуля crypto можно наглядно посмотреть как расспараллеливается выполнение задач в node JS,
                библиотека Libuv по умолчанию поддерживает 4 потока, посему первые четыри вызова будут выполнены
                одновременно, пятый же начнет выполнение после того как один из потоков освободится.</p>
        </div>
    </section>

    <h3 id="nodeJSEventLoop">Событийный цикл (Event Loop)</h3>

    <section>
        <div>
            <p>Идея событийного цикла очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи,
                исполняет их и снова ожидает появления новых.</p>
            <p>Общий алгоритм движка:</p>
            <ol>
                <li>Пока есть задачи выполнить их, начиная с самой старой</li>
                <li>Бездействовать до появления новой задачи, а затем перейти к пункту 1</li>
            </ol>

            <p>Фазы выполнения операций в цикле событий:</p>
            <ol>
                <li>Таймеры (setTimeout/setInterval)</li>
                <li>Input/Output коллбэки, здесь выполняются все коллбеки за исключением событий "close", таймеров и
                    событий которые были определены с помощью функции setImmediate в Node JS.
                </li>
                <li>Ожидание, подготовка. Используется для внутренних целей</li>
                <li>Опрос - получение новый I/O событий(при этом Node JS может блокироваться!!!)</li>
                <li>Проверка - вызываются коллбеки, которые были определены с помощью функции setImmediate</li>
                <li>Коллбеки события "close", закрытие вебсокет соединений(событие "close"), закрытие стрима,
                    считывающего данные и тд
                </li>
            </ol>
        </div>
    </section>

    <h3 id="nodeJSProcess">Глобально доступный объект process</h3>

    <section>
        <div>
            <p>process - глобальный объект с помощью которого можно получить информацию о текущем процессе</p>
            <p>process.pid - возвращает id процесса, его так же можно найти в диспетчере задач во кладке
                "Подробности"</p>
            <p>process.env - переменные окружения, их можно указывать в конфигурационных файлах, отдельные переменные
                можно указывать при запуске приложения при конфигурации Docker контейнера.</p>
            <pre>
                console.log(process.env);

                //  (env object) {
                //     USERDOMAIN_ROAMINGPROFILE: 'COMPUTER',
                //     PROCESSOR_LEVEL: '6',
                //     NVM_SYMLINK: 'C:\\Program Files\\nodejs',
                //     SESSIONNAME: 'Console',
                //     ALLUSERSPROFILE: 'C:\\ProgramData',
                //     PROCESSOR_ARCHITECTURE: 'AMD64',
                //     GATEWAY_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\gateway.vmoptions',
                //     PSModulePath: 'C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules;C:\\Program Files\\Intel\\Wired Networking\\',
                //     SystemDrive: 'C:',
                //     RIDER_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\rider.vmoptions',
                //     USERNAME: 'Slipbang',
                //     DEVECOSTUDIO_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\devecostudio.vmoptions',
                //     STUDIO_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\studio.vmoptions',
                //     'ProgramFiles(x86)': 'C:\\Program Files (x86)',
                //     GPU_USE_SYNC_OBJECTS: '1',
                //     GPU_MAX_ALLOC_PERCENT: '100',
                //     FPS_BROWSER_USER_PROFILE_STRING: 'Default',
                //     PATHEXT: '.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY;.PYW',
                //     APPCODE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\appcode.vmoptions',
                //     DriverData: 'C:\\Windows\\System32\\Drivers\\DriverData',
                //     ProgramData: 'C:\\ProgramData',
                //     DATASPELL_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\dataspell.vmoptions',
                //     ProgramW6432: 'C:\\Program Files',
                //     HOMEPATH: '\\Users\\Slipbang',
                //     PROCESSOR_IDENTIFIER: 'Intel64 Family 6 Model 158 Stepping 13, GenuineIntel',
                //     ProgramFiles: 'C:\\Program Files',
                //     PUBLIC: 'C:\\Users\\Public',
                //     windir: 'C:\\WINDOWS',
                //     GPU_MAX_HEAP_SIZE: '100',
                //     DATAGRIP_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\datagrip.vmoptions',
                //     LOCALAPPDATA: 'C:\\Users\\Slipbang\\AppData\\Local',
                //     ChocolateyLastPathUpdate: '133193147669235416',
                //     GPU_SINGLE_ALLOC_PERCENT: '100',
                //     USERDOMAIN: 'COMPUTER',
                //     GPU_FORCE_64BIT_PTR: '0',
                //     WEBSTORM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\webstorm.vmoptions',
                //     LOGONSERVER: '\\\\COMPUTER',
                //     PYCHARM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\pycharm.vmoptions',
                //     FPS_BROWSER_APP_PROFILE_STRING: 'Internet Explorer',
                //     CLION_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\clion.vmoptions',
                //     JETBRAINSCLIENT_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\jetbrainsclient.vmoptions',
                //     GOLAND_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\goland.vmoptions',
                //     OneDrive: 'C:\\Users\\Slipbang\\OneDrive',
                //     APPDATA: 'C:\\Users\\Slipbang\\AppData\\Roaming',
                //     VBOX_HWVIRTEX_IGNORE_SVM_IN_USE: '1',
                //     IDEA_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\idea.vmoptions',
                //     RUBYMINE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\rubymine.vmoptions',
                //     ChocolateyInstall: 'C:\\ProgramData\\chocolatey',
                //     JETBRAINS_CLIENT_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\jetbrains_client.vmoptions',
                //     CommonProgramFiles: 'C:\\Program Files\\Common Files',
                //     Path: 'C:\\Python311\\Scripts\\;C:\\Python311\\;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\ProgramData\\chocolatey\\bin;C:\\Users\\Slipbang\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Users\\Slipbang\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\Slipbang\\AppData\\Roaming\\npm;C:\
                // \Users\\Slipbang\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\Slipbang\\AppData\\Local\\GitHubDesktop\\bin',
                //     OS: 'Windows_NT',
                //     COMPUTERNAME: 'COMPUTER',
                //     NVM_HOME: 'C:\\Users\\Slipbang\\AppData\\Roaming\\nvm',
                //     PROCESSOR_REVISION: '9e0d',
                //     CommonProgramW6432: 'C:\\Program Files\\Common Files',
                //     ComSpec: 'C:\\WINDOWS\\system32\\cmd.exe',
                //     TEMP: 'C:\\Users\\Slipbang\\AppData\\Local\\Temp',
                //     SystemRoot: 'C:\\WINDOWS',
                //     WEBIDE_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\webide.vmoptions',
                //     HOMEDRIVE: 'C:',
                //     USERPROFILE: 'C:\\Users\\Slipbang',
                //     TMP: 'C:\\Users\\Slipbang\\AppData\\Local\\Temp',
                //     'CommonProgramFiles(x86)': 'C:\\Program Files (x86)\\Common Files',
                //     NUMBER_OF_PROCESSORS: '6',
                //     PHPSTORM_VM_OPTIONS: 'C:\\jetbra\\vmoptions\\phpstorm.vmoptions',
                //     IDEA_INITIAL_DIRECTORY: 'C:\\Users\\Slipbang\\Desktop'
                // }
            </pre>

            <p>Важные переменные, которые можно инициализировать самостоятельно - PORT, NODE_ENV</p>
            <p>process.argv - возвращает массив с командами которые мы можем выполнять при запуске файла</p>
            <pre>
                console.log(process.argv);
                node process.js command1 command2 command3 command4
                const commands = [
                    'C:\\Program Files\\nodejs\\node.exe',
                    'C:\\Users\\Slipbang\\Desktop\\node JS\\process.js',
                    'command1',
                    'command2',
                    'command3',
                    'command4'
                ]
            </pre>
        </div>
    </section>

    <h3 id="nodeJSPath">Модуль path</h3>

    <section>
        <div>
            <p>Модуль path позволяет удобным образом взаимодействовать с путями(абсолютными или относительными)</p>
            <p>path имеет следующие методы:</p>

            <p>join() позволяет соединить несколько участков пути вне зависимости от ОС:</p>
            <pre>
                console.log(path.join(__dirname, 'first', 'second', 'third')) // C:\Users\Slipbang\Desktop\nodeJS\modules_in_NodeJS\first\second\third
                //с помощью __dirname можно на любом устройстве получить абсолютный путь от корня до директории выполнения, __filename - имя файла
            </pre>

            <p>Метод resolve() похожа на join(), но всегда возвращает абсолютный путь, есть нюансы с работой!:</p>
            <pre>
                console.log(path.resolve('first', 'second', 'third')) // C:\Users\Slipbang\Desktop\nodeJS\modules_in_NodeJS\first\second\third
            </pre>

            <p>Метод parse() парсит путь в объект:</p>
            <pre>
                const fullPath = path.resolve(__dirname, 'first', 'second', 'third.js');
                console.log('парсинг пути', path.parse(fullPath));
                // результат выполнения
                {
                    root: 'C:\\',
                    dir: 'C:\\Users\\Slipbang\\Desktop\\node JS\\first\\second',
                    base: 'third',
                    ext: '.js',
                    name: 'third'
                }
            </pre>
            <p>path.sep - Разделитель в ОС("\").</p>
            <p>path.isAbsolute('first/second') - Проверка на абсолютный путь.</p>
            <p>path.basename(fullPath) - Название файла.</p>
            <p>path.extname(fullPath) - Расширение файла.</p>
        </div>
    </section>

    <h3 id="nodeJSURL">Глобально доступный объект URL</h3>

    <section>
        <div>
            <p>Объект URL предназначен для работы со ссылками и их параметрами.</p>
            <pre>
                const siteIRL = 'http://localhost:8080/users?id=5123';

                const url = new URL(siteIRL);

                console.log(url)

                результат вывода в консоль: {
                    href: 'http://localhost:8080/users?id=5123',
                    origin: 'http://localhost:8080',
                    protocol: 'http:',
                    username: '',
                    password: '',
                    host: 'localhost:8080',
                    hostname: 'localhost',
                    port: '8080',
                    pathname: '/users',
                    search: '?id=5123',
                    searchParams: URLSearchParams { 'id' => '5123' },
                    hash: ''
                }
            </pre>
        </div>
    </section>

    <h3>Модуль fs (file-system)</h3>

    <section>
        <div>
            <p>fs (file-system) служит для взаимодействия с файловой системой: создание или удаление файлов/папок,
                считывание, запись.</p>
            <p>Медоты в fs дублированы на обычные и синхронные! Первый тип методов не блокирует главный поток, второй же
                - блокирует! </p>

            <p>mkdir/mkdirSync позволяет создать папку, в случае если папка уже существует - произойдет ошибка.</p>
            <pre>
                const fs = require('fs');
                const path = require('path');

                fs.mkdirSync(path.resolve(__dirname, 'newDirName1', 'newDirName2', 'newDirName3'), {recursive: true});

                // Асинхронный вариант mkdirSync
                console.log('START');
                fs.mkdir(path.resolve(__dirname, 'newDir1', 'newDir2', 'newDir3'),{recursive: true}, (err, ) => {
                    if (err) {
                        console.log(err);
                        return;
                    }
                    console.log('Папка создана');
                });
                console.log('END');
            </pre>

            <p>fs.rmdir() - асинхронное удаление директории</p>
            <pre>
                fs.rmdir(path.resolve(__dirname, 'dirName'), (err) => {
                    if (err) {
                        throw err;
                    }
                })
            </pre>

            <p>fs.unlink() - асинхронное удаление файла</p>
            <pre>
                fs.unlink('./text-files/test.txt', (err) => {
                    if (err && err.code !== 'ENOENT') throw err;
                    fs.rmdir('./text-files', (err) => {
                        if (err && err.code !== 'ENOENT') throw err;
                    })
                })
            </pre>

            <p>fs.writeFile() - создание и запись в файл, второй переданный аргумент будет ПЕРЕЗАТИРАТЬ данные в случае если
                они есть в файле</p>
            <pre>
                fs.writeFile(path.resolve(__dirname, 'test.txt'), '123456qwerty', (err) => {
                    if (err) throw err;
                    console.log('Файл создан')
                })
            </pre>

            <p>fs.appendFile() - если нужно дозаписать в файл не удаляя старое содержимое(запись идет в конце файла).</p>
            <pre>
                fs.appendFile(path.resolve(__dirname, 'test.txt'), '123456qwerty', (err) => {
                    if (err) throw err;
                    console.log('Запись добавлена')
                })
            </pre>

            <p>fs.readFile() - чтение файла, по умолчанию метод считывает буфер, для преобразования данных нужно передать
                аргумент опций {encoding: 'utf-8'} (utf-8 как пример)</p>
            <pre>
                fs.readFile(path.resolve(__dirname, '../test.txt'), {encoding: 'utf-8'}, (err, data) => {
                    if (err) throw err;

                    console.log(data)
                })
            </pre>

            <p>В случае если требуются операции выполняемые по цепочке, методы надо вызывать в колбеке родительских
                методов, и для избежания "ада колбеков", колбеки можно заменить на промисы.</p>
            <pre>
                //Асинхронное создание, запись и чтение файла с помощью промисов
                const writeFileAsync = async (path, data) => {
                    return new Promise((resolve, reject) => fs.writeFile(path, data, (err) => {
                        if (err) reject(err.message);
                        resolve()
                    }))
                }

                const appendFileAsync = async (path, data) => {
                    return new Promise((resolve, reject) => fs.appendFile(path, data, (err) => {
                        if (err) reject(err.message);
                        resolve()
                    }))
                }

                const readFileAsync = async (path) => {
                    return new Promise((resolve, reject) => fs.readFile(path, {encoding: 'utf-8'}, (err, data) => {
                        if (err) reject(err.message);
                        resolve(data);
                    }))
                }

                const removeFileAsync = async (path) => {
                    return new Promise((resolve, reject) => fs.rm(path, (err) => {
                        if (err) reject(err.message);
                        resolve();
                    }))
                }
                writeFileAsync(path.resolve(__dirname, 'test1.txt'), 'data')
                    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '123'))
                    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '456'))
                    .then(() => appendFileAsync(path.resolve(__dirname, 'test1.txt'), '789'))
                    .then(() => readFileAsync(path.resolve(__dirname, 'test1.txt')))
                    .then(data => console.log(data))
                    .then(() => {
                        removeFileAsync(path.resolve(__dirname, 'test1.txt'))
                        console.log('Файл удален')
                    })
                    .catch(err => console.log(err));
            </pre>
            <p>Так же можно импортировать promise вариант fs, в данном варианте fa можно использовать then/catch цепочки:</p>
            <pre>
                const fs = require('fs/promises');

                fs.readFile('./example.txt', 'utf-8')
                    .then(data => {
                        console.log(data);
                    })
                    .catch(error => console.log(error));
            </pre>
        </div>
    </section>

    <h3 id="nodeJSOS">Модули os (operation-system) и cluster</h3>

    <section>
        <div>
            <p>platform позволяет получить текущую операционную систему</p>
            <pre>
                console.log(os.platform()) //win32
            </pre>

            <p>arch позволяет получить архитектуру процессора</p>
            <pre>
                console.log(os.arch()) //x64
            </pre>

            <p>cpus возвращает массив, где каждый объект массива - описание ядра процессора</p>
            <pre>
                console.log(os.cpus())

                // cpusArray [
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: {
                //             user: 447250,
                //             nice: 0,
                //             sys: 1707546,
                //             idle: 38694796,
                //             irq: 482984
                //         }
                //     },
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: {
                //             user: 1808562,
                //             nice: 0,
                //             sys: 26226046,
                //             idle: 12814984,
                //             irq: 3656
                //         }
                //     },
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: { user: 960375, nice: 0, sys: 1049437, idle: 38839781, irq: 3609 }
                //     },
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: { user: 528000, nice: 0, sys: 580375, idle: 39741218, irq: 4484 }
                //     },
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: { user: 434343, nice: 0, sys: 196265, idle: 40218984, irq: 3546 }
                //     },
                //     {
                //         model: 'Intel(R) Core(TM) i5-9600KF CPU @ 3.70GHz',
                //         speed: 3696,
                //         times: { user: 624765, nice: 0, sys: 161656, idle: 40063171, irq: 2203 }
                //     }
                // ]
            </pre>

            <p>Модуль cluster предназначен для того чтобы однопоточному nodeJS приложению использовать все возможности
                многоядерных систем.</p>

            <pre>
                // cluster.isMaster определяет является ли текущий процесс главым
                if (cluster.isMaster) {
                    for (let i = 0; i < os.cpus().length-2; i++) {
                        // cluster.fork() запускает дочерний процессж
                        cluster.fork();
                    }

                    cluster.on() - подписка на определенное событие, в примере ниже это событие 'exit'
                    cluster.on('exit', (worker, code, signal) => {
                        console.log(`Воркер с pid=${worker.process.pid} был остановлен`);
                        if (code === '...') {
                            cluster.fork()
                        } else {
                            console.log('Воркер умер')
                        }

                    })
                } else {
                    console.log(`Воркер с pid=${process.pid} запущен`)

                    setInterval(() => {
                        console.log(`Воркер с pid=${process.pid} работает`)
                    }, 5000)
                }

            </pre>
        </div>
    </section>

    <h3 id="nodeJSEvents">Модуль events</h3>

    <section>
        <div>
            <p>Модуль events позволяет создавать события, подписываться на них и генерировать эти события.</p>
            <p>У данного модуля присутствуют те же методы, что есть у document - addEventListener, removeEventListener и
                тд </p>
            <pre>
                const { EventEmitter } = require('events');
                const emitter = new EventEmitter();

                // создание пользовательского события
                const callback = (data, secondArg, thirdArg, ect) => {
                    console.log('Вы прислали сообщение ' + data);
                    console.log('Второй аргумент ' + secondArg);
                }

                emitter.on('message', callback);
                const MESSAGE = process.env.message || '';

                if (MESSAGE) {
                    //Функция emit используется для генерации событий, ее аргумент - название события которое мы генерируем.
                    emitter.emit('message', MESSAGE, 123);
                } else {
                    emitter.emit('message', 'вы не указали сообщение')
                }
            </pre>

            <p>Данную концепцию удобно использовать в следующих случаях:</p>
            <ol>
                <li>При создании http серверов</li>
                <li>В вебсокетах</li>
                <li>long pulling</li>
                <li>В кластеризации</li>
            </ol>
            <p>В случае если событие нужно сгенерировать единожды - можно применить метод once(вместо on)</p>
            <p>С помощью removeAllListeners можно удалять все слушатели, removeListener('eventName', callback) можно
                удалить определенный слушатель</p>
        </div>
    </section>

    <h3 id="nodeJSStreams">Стримы в nodeJS</h3>

    <section>
        <div>
            <p>В nodeJS существуют 4 типа стримов:</p>
            <ol>
                <li>Readable - чтение</li>
                <li>Writable - запись</li>
                <li>Duplex - для чтения и записи (Readable + Writable)</li>
                <li>Transform - то же что и Duplex, но может изменить данные по мере чтения</li>
            </ol>
            <p>Стримы используются для разбивки больших файлов на чанки и постепенная их загрузка, запись, чтение и тд.
                По умолчанию размер чанка равен 64кб</p>
            <pre>
                const fs = require('fs');
                const path = require('path');

                // Чтение файла testDataFile методом readFile, в данном случае файл прочитан целиком
                fs.readFile(path.resolve(__dirname, 'testDataFile.txt'), (err, data) => {
                    if (err) {
                        throw err;
                    }
                    console.log(data)
                }) // &lt;Buffer 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 64 61 74 61 31 32 33 34 35 36 ... 301241 more bytes&gt;

                // Чтение файла testDataFile при помощи стримов, а именно fs.createReadStream()
                const stream = fs.createReadStream(path.resolve(__dirname, 'testDataFile.txt'), {encoding: 'utf-8'});

                // Один чанк по умолчанию - 64кб
                stream.on('data', (chunk) => {
                    console.log(chunk) // выводит в лог информацию из файла порциями(чанками)
                })

                // Стримы имеют ряд событий таких как open/close/end/error и тд
                stream.on('open', () => console.log('Начали читать'));
                stream.on('end', () => console.log('Закончили читать'));
                stream.on('error', (err) => console.log(err));

                // Запись в файл при помощи стрима fs.createWriteStream()
                const writableStream = fs.createWriteStream(path.resolve(__dirname, 'test.txt'));

                for (let k = 0; k < 20; k++) {
                    writableStream.write(k + '\n');
                }
                //writableStream нужно завершать в ручную!
                writableStream.end();

                // закрытие стрима
                // writableStream.close();

                // уничтожение созданного потока, после вызова данного метода, метод write() более вызвать нельзя
                writableStream.destroy();
            </pre>

            <p>При работе с http сервером для нас доступно два объекта - request и response, они так же являются
                стримами! При этом request - readable stream, а response - writable stream.</p>

            <pre>
                const http = require('http');
                http.createServer((req, res) => {
                    // req - readable stream
                    // res - writable stream
                    const stream = fs.createReadStream(path.resolve(__dirname, 'test.txt'));

                    Важный момент!!! Синхронизация стримов чтения и записи!
                    stream.pipe(res)

                    stream.on('data', chunk => res.write(chunk));
                    stream.on('end', chunk => res.end());
                })
            </pre>
        </div>
    </section>

    <h3 id="nodeJSHttp">Модуль http</h3>

    <section>
        <div>
            <p>Модуль http используется для создания серверов.</p>
            <pre>
                const http = require('http');
                const PORT = process.env.PORT || 5000;

                const server = http.createServer((req, res) => {
                    // Сервер сайд рендеринг
                    // res.writeHead(200, {
                    //     'Content-type': 'text/html;'
                    // })
                    // res.end('&lt;h1&gt;Hello world&lt;/h1&gt;');

                    // отправка JSON
                    res.writeHead(200, {
                        'Content-type': 'application/json'
                    })

                    if (req.url === '/users') {
                        return res.end(JSON.stringify([
                            {id: 1, name: 'Dmitry'}
                        ]))
                    }

                    if (req.url === '/posts') {
                        return res.end('POSTS')
                    }
                })

                server.listen(PORT, () => console.log(`Server started on PORT ${PORT}`));
            </pre>

            <p>Подробнее по созданию собственного сервера nodeJS можно изучить в <a href="https://github.com/Slipbang/nodeJS" target="_blank">данном репозитории Гитхаб</a></p>
        </div>
    </section>

    <h3>Экспорты и импорты модулей в javaScript</h3>

    //5:38:22
    <section>
        <div>
            <p>В javaScript существует два способа экспортировать и импортировать модули:</p>
            <ul>
                <li>CommonJS Modules [require]</li>
                <li>ECMAScript Modules(ESM) [import]</li>
            </ul>
            <p>Модули служат для: разделения приложения на части, организации кода, разделения ответственности, упрощение поддержки приложения.</p>
            <p>Характеристики модулей:</p>
            <ol>
                <li>По умолчанию ни одна из переменных в модуле не доступна для импорта в других модулях</li>
                <li>Чтобы переменная стала доступна для импорта в других модулях, ее необходимо экспортировать из модуля</li>
                <li>Для использования в определенном модуле переменных из других модулей, их необходимо импортировать</li>
                <li>При импортировании названия переменных можно изменять</li>
            </ol>
        </div>
    </section>

    <h3>Синтаксис CommonJS Modules</h3>

    <section>
        <div>
            <pre>
                // single-export.js
                function greeting(name) {
                    console.log(`Hello ${name}`)
                }

                module.exports = greeting;

                // multiple-exports.js
                const name = 'Dmitriy';
                const hobbies = ['swimming', 'boxing', 'cycling'];
                const favoriteNumber = 77;

                console.log('console log from multiple-exports commonJS module')

                module.exports = {
                    name,
                    hobbies,
                    favoriteNumber
                }

                // index.js
                const {name: myName, favoriteNumber, hobbies} = require('./multiple-exports.js');
                const greetingFunction = require('./single-export.js');

                console.log(myName, favoriteNumber, hobbies); // Dmitriy 77 [ 'swimming', 'boxing', 'cycling' ]
                greetingFunction(name); // Hello Dmitriy
            </pre>
        </div>
    </section>

    <h3>Синтаксис ECMAScript Modules (ESM)</h3>

    <section>
        <div>
            <p>Существует два способа перехода с CommonJS на ESM:</p>
            <ol>
                <li>Изменить расширение файла на .mjs</li>
                <li>Добавить "type": "module" в файле package.json</li>
            </ol>
            <p>Внутри ESM нет доступа к переменным из модуля CommonJS!!! тк модули ESM не оборачиваются в анонимную функцию с данными аргументами:</p>
            <pre>
                console.log(module); // ReferenceError: module is not defined in ES module scope
                console.log(require); //ReferenceError: require is not defined in ES module scope, you can use import instead
                console.log(exports); // ReferenceError: exports is not defined in ES module scope
                console.log(__filename); // ReferenceError: __filename is not defined in ES module scope
                console.log(__dirname); // ReferenceError: __dirname is not defined in ES module scope
            </pre>

            <p>Типы экспортов в ESM:</p>
            <ul>
                <li>Именованные экспорты (экспорт одной или нескольких переменных)</li>
                <li>Экспорт по умолчанию</li>
                <li>Смешанные экспорты (комбинация из двух выше перечисленных)</li>
            </ul>

            <p>Именованный экспорт:</p>
            <pre>
                // constants.mjs
                const URL = 'http://localhost:5000';
                const USERNAME = 'admin';
                const PASSWORD = 'some_pass';

                export { URL, USERNAME, PASSWORD }; // ключевое слово export является инструкцией (statement)
                // ЛИБО inline експорты(в случае если переменных много следует использовать первый вариант!!!)
                export const URL = 'http://localhost:5000';
                export const USERNAME = 'admin';
                export const PASSWORD = 'some_pass';

                // index.mjs
                import { URL, USERNAME, PASSWORD } from './hello.mjs';
            </pre>

            <p>Если требуются псевдонимы, то можно использовать следующий синтаксис:</p>
            <pre>
                // someFile.mjs
                const season = 'spring';
                const temperature = 13;

                export {season as spring, temperature};

                // index.mjs
                import {spring, temperature} from './someFile.mjs';

                console.log(spring, temperature)

                //ЛИБО псевдоним можно присвоить в импорте
                // someFile.mjs
                const season = 'spring';
                const temperature = 13;

                export {season, temperature};

                // index.mjs
                import {season as spring, temperature} from './someFile.mjs';
                console.log(spring, temperature);

                //НО для того чтобы не возникло путаницы лучше переименовывать переменную в импорте!
            </pre>
            <p>Импорт по умолчанию имеет следующий синтаксис:</p>
            <pre>
                // default-export.mjs
                async function getData(url) {
                    const response = await fetch(url);
                    const posts = await response.json();
                    return posts;
                }

                export default getData;

                //index.mjs
                import getDataFromServer from "./default-export.mjs";
                getDataFromServer('https://jsonplaceholder.typicode.com/todos/1')
                    .then(post => console.log(post))
                    .catch(err => console.log(err))

            </pre>
            <p>Примером смешанного импорта является импорт react хуков и самого React из библиотеки:</p>
            <pre>
                import React, { useState, useEffect } from 'react';
            </pre>
        </div>
    </section>

    <div class="sideBar">
        <div class="sideBarContainer"></div>
    </div>

    <!-- Local scripts -->
    <script src="./scripts/UI.js"></script>
    <script src="./scripts/scripts.js"></script>
    <script src="./scripts/OOPclasses.js"></script>
</main>
<footer>Footer</footer>
</body>
</html>